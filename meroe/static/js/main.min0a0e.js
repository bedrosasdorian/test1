!function () {
    "use strict";

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function e(e, t, n, i) {
        var r, s = arguments.length, a = s < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, n) : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, i); else for (var o = e.length - 1; o >= 0; o--) (r = e[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(t, n, a) : r(t, n)) || a);
        return s > 3 && a && Object.defineProperty(t, n, a), a
    }

    function t(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }

    function n(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
    }

    /*!
     * GSAP 3.10.1
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var i, r, s, a, o, l, c, h, u, d = {autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: {lineHeight: ""}},
        p = {duration: .5, overwrite: !1, delay: 0}, f = 1e8, m = 1e-8, g = 2 * Math.PI, v = g / 4, _ = 0,
        y = Math.sqrt, x = Math.cos, b = Math.sin, w = function (e) {
            return "string" == typeof e
        }, T = function (e) {
            return "function" == typeof e
        }, S = function (e) {
            return "number" == typeof e
        }, E = function (e) {
            return void 0 === e
        }, M = function (e) {
            return "object" == typeof e
        }, A = function (e) {
            return !1 !== e
        }, L = function () {
            return "undefined" != typeof window
        }, C = function (e) {
            return T(e) || w(e)
        }, R = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {
        }, P = Array.isArray, I = /(?:-?\.?\d|\.)+/gi, O = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        D = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, N = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, B = /[+-]=-?[.\d]+/,
        k = /[^,'"\[\]\s]+/gi, U = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, F = {}, H = {}, z = function (e) {
            return (H = pe(e, F)) && rn
        }, G = function (e, t) {
            return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
        }, V = function (e, t) {
            return !t && console.warn(e)
        }, W = function (e, t) {
            return e && (F[e] = t) && H && (H[e] = t) || F
        }, j = function () {
            return 0
        }, $ = {}, X = [], q = {}, Y = {}, K = {}, J = 30, Z = [], Q = "", ee = function (e) {
            var t, n, i = e[0];
            if (M(i) || T(i) || (e = [e]), !(t = (i._gsap || {}).harness)) {
                for (n = Z.length; n-- && !Z[n].targetTest(i);) ;
                t = Z[n]
            }
            for (n = e.length; n--;) e[n] && (e[n]._gsap || (e[n]._gsap = new Mt(e[n], t))) || e.splice(n, 1);
            return e
        }, te = function (e) {
            return e._gsap || ee(je(e))[0]._gsap
        }, ne = function (e, t, n) {
            return (n = e[t]) && T(n) ? e[t]() : E(n) && e.getAttribute && e.getAttribute(t) || n
        }, ie = function (e, t) {
            return (e = e.split(",")).forEach(t) || e
        }, re = function (e) {
            return Math.round(1e5 * e) / 1e5 || 0
        }, se = function (e) {
            return Math.round(1e7 * e) / 1e7 || 0
        }, ae = function (e, t) {
            var n = t.charAt(0), i = parseFloat(t.substr(2));
            return e = parseFloat(e), "+" === n ? e + i : "-" === n ? e - i : "*" === n ? e * i : e / i
        }, oe = function (e, t) {
            for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;) ;
            return i < n
        }, le = function () {
            var e, t, n = X.length, i = X.slice(0);
            for (q = {}, X.length = 0, e = 0; e < n; e++) (t = i[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
        }, ce = function (e, t, n, i) {
            X.length && le(), e.render(t, n, i), X.length && le()
        }, he = function (e) {
            var t = parseFloat(e);
            return (t || 0 === t) && (e + "").match(k).length < 2 ? t : w(e) ? e.trim() : e
        }, ue = function (e) {
            return e
        }, de = function (e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        }, pe = function (e, t) {
            for (var n in t) e[n] = t[n];
            return e
        }, fe = function e(t, n) {
            for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (t[i] = M(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]);
            return t
        }, me = function (e, t) {
            var n, i = {};
            for (n in e) n in t || (i[n] = e[n]);
            return i
        }, ge = function (e) {
            var t, n = e.parent || r, i = e.keyframes ? (t = P(e.keyframes), function (e, n) {
                for (var i in n) i in e || "duration" === i && t || "ease" === i || (e[i] = n[i])
            }) : de;
            if (A(e.inherit)) for (; n;) i(e, n.vars.defaults), n = n.parent || n._dp;
            return e
        }, ve = function (e, t, n, i, r) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var s, a = e[i];
            if (r) for (s = t[r]; a && a[r] > s;) a = a._prev;
            return a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = a, t.parent = t._dp = e, t
        }, _e = function (e, t, n, i) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var r = t._prev, s = t._next;
            r ? r._next = s : e[n] === t && (e[n] = s), s ? s._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null
        }, ye = function (e, t) {
            e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e), e._act = 0
        }, xe = function (e, t) {
            if (e && (!t || t._end > e._dur || t._start < 0)) for (var n = e; n;) n._dirty = 1, n = n.parent;
            return e
        }, be = function (e) {
            for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
            return e
        }, we = function e(t) {
            return !t || t._ts && e(t.parent)
        }, Te = function (e) {
            return e._repeat ? Se(e._tTime, e = e.duration() + e._rDelay) * e : 0
        }, Se = function (e, t) {
            var n = Math.floor(e /= t);
            return e && n === e ? n - 1 : n
        }, Ee = function (e, t) {
            return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
        }, Me = function (e) {
            return e._end = se(e._start + (e._tDur / Math.abs(e._ts || e._rts || m) || 0))
        }, Ae = function (e, t) {
            var n = e._dp;
            return n && n.smoothChildTiming && e._ts && (e._start = se(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Me(e), n._dirty || xe(n, e)), e
        }, Le = function (e, t) {
            var n;
            if ((t._time || t._initted && !t._dur) && (n = Ee(e.rawTime(), t), (!t._dur || He(0, t.totalDuration(), n) - t._tTime > m) && t.render(n, !0)), xe(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                if (e._dur < e.duration()) for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                e._zTime = -1e-8
            }
        }, Ce = function (e, t, n, i) {
            return t.parent && ye(t), t._start = se((S(n) ? n : n || e !== r ? ke(e, n, t) : e._time) + t._delay), t._end = se(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), ve(e, t, "_first", "_last", e._sort ? "_start" : 0), Oe(t) || (e._recent = t), i || Le(e, t), e
        }, Re = function (e, t) {
            return (F.ScrollTrigger || G("scrollTrigger", t)) && F.ScrollTrigger.create(t, e)
        }, Pe = function (e, t, n, i) {
            return Dt(e, t), e._initted ? !n && e._pt && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && c !== pt.frame ? (X.push(e), e._lazy = [t, i], 1) : void 0 : 1
        }, Ie = function e(t) {
            var n = t.parent;
            return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
        }, Oe = function (e) {
            var t = e.data;
            return "isFromStart" === t || "isStart" === t
        }, De = function (e, t, n, i) {
            var r = e._repeat, s = se(t) || 0, a = e._tTime / e._tDur;
            return a && !i && (e._time *= s / e._dur), e._dur = s, e._tDur = r ? r < 0 ? 1e10 : se(s * (r + 1) + e._rDelay * r) : s, a > 0 && !i ? Ae(e, e._tTime = e._tDur * a) : e.parent && Me(e), n || xe(e.parent, e), e
        }, Ne = function (e) {
            return e instanceof Lt ? xe(e) : De(e, e._dur)
        }, Be = {_start: 0, endTime: j, totalDuration: j}, ke = function e(t, n, i) {
            var r, s, a, o = t.labels, l = t._recent || Be, c = t.duration() >= f ? l.endTime(!1) : t._dur;
            return w(n) && (isNaN(n) || n in o) ? (s = n.charAt(0), a = "%" === n.substr(-1), r = n.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (a ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in o || (o[n] = c), o[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), a && i && (s = s / 100 * (P(i) ? i[0] : i).totalDuration()), r > 1 ? e(t, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n
        }, Ue = function (e, t, n) {
            var i, r, s = S(t[1]), a = (s ? 2 : 1) + (e < 2 ? 0 : 1), o = t[a];
            if (s && (o.duration = t[1]), o.parent = n, e) {
                for (i = o, r = n; r && !("immediateRender" in i);) i = r.vars.defaults || {}, r = A(r.vars.inherit) && r.parent;
                o.immediateRender = A(i.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[a - 1]
            }
            return new Ft(t[0], o, t[a + 1])
        }, Fe = function (e, t) {
            return e || 0 === e ? t(e) : t
        }, He = function (e, t, n) {
            return n < e ? e : n > t ? t : n
        }, ze = function (e, t) {
            return w(e) && (t = U.exec(e)) ? t[1] : ""
        }, Ge = [].slice, Ve = function (e, t) {
            return e && M(e) && "length" in e && (!t && !e.length || e.length - 1 in e && M(e[0])) && !e.nodeType && e !== s
        }, We = function (e, t, n) {
            return void 0 === n && (n = []), e.forEach((function (e) {
                var i;
                return w(e) && !t || Ve(e, 1) ? (i = n).push.apply(i, je(e)) : n.push(e)
            })) || n
        }, je = function (e, t, n) {
            return !w(e) || n || !a && ft() ? P(e) ? We(e, n) : Ve(e) ? Ge.call(e, 0) : e ? [e] : [] : Ge.call((t || o).querySelectorAll(e), 0)
        }, $e = function (e) {
            return e.sort((function () {
                return .5 - Math.random()
            }))
        }, Xe = function (e) {
            if (T(e)) return e;
            var t = M(e) ? e : {each: e}, n = bt(t.ease), i = t.from || 0, r = parseFloat(t.base) || 0, s = {},
                a = i > 0 && i < 1, o = isNaN(i) || a, l = t.axis, c = i, h = i;
            return w(i) ? c = h = {
                center: .5,
                edges: .5,
                end: 1
            }[i] || 0 : !a && o && (c = i[0], h = i[1]), function (e, a, u) {
                var d, p, m, g, v, _, x, b, w, T = (u || t).length, S = s[T];
                if (!S) {
                    if (!(w = "auto" === t.grid ? 0 : (t.grid || [1, f])[1])) {
                        for (x = -1e8; x < (x = u[w++].getBoundingClientRect().left) && w < T;) ;
                        w--
                    }
                    for (S = s[T] = [], d = o ? Math.min(w, T) * c - .5 : i % w, p = w === f ? 0 : o ? T * h / w - .5 : i / w | 0, x = 0, b = f, _ = 0; _ < T; _++) m = _ % w - d, g = p - (_ / w | 0), S[_] = v = l ? Math.abs("y" === l ? g : m) : y(m * m + g * g), v > x && (x = v), v < b && (b = v);
                    "random" === i && $e(S), S.max = x - b, S.min = b, S.v = T = (parseFloat(t.amount) || parseFloat(t.each) * (w > T ? T - 1 : l ? "y" === l ? T / w : w : Math.max(w, T / w)) || 0) * ("edges" === i ? -1 : 1), S.b = T < 0 ? r - T : r, S.u = ze(t.amount || t.each) || 0, n = n && T < 0 ? yt(n) : n
                }
                return T = (S[e] - S.min) / S.max || 0, se(S.b + (n ? n(T) : T) * S.v) + S.u
            }
        }, qe = function (e) {
            var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
            return function (n) {
                var i = Math.round(parseFloat(n) / e) * e * t;
                return (i - i % 1) / t + (S(n) ? 0 : ze(n))
            }
        }, Ye = function (e, t) {
            var n, i, r = P(e);
            return !r && M(e) && (n = r = e.radius || f, e.values ? (e = je(e.values), (i = !S(e[0])) && (n *= n)) : e = qe(e.increment)), Fe(t, r ? T(e) ? function (t) {
                return i = e(t), Math.abs(i - t) <= n ? i : t
            } : function (t) {
                for (var r, s, a = parseFloat(i ? t.x : t), o = parseFloat(i ? t.y : 0), l = f, c = 0, h = e.length; h--;) (r = i ? (r = e[h].x - a) * r + (s = e[h].y - o) * s : Math.abs(e[h] - a)) < l && (l = r, c = h);
                return c = !n || l <= n ? e[c] : t, i || c === t || S(t) ? c : c + ze(t)
            } : qe(e))
        }, Ke = function (e, t, n, i) {
            return Fe(P(e) ? !t : !0 === n ? !!(n = 0) : !i, (function () {
                return P(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * i) / i
            }))
        }, Je = function (e, t, n) {
            return Fe(n, (function (n) {
                return e[~~t(n)]
            }))
        }, Ze = function (e) {
            for (var t, n, i, r, s = 0, a = ""; ~(t = e.indexOf("random(", s));) i = e.indexOf(")", t), r = "[" === e.charAt(t + 7), n = e.substr(t + 7, i - t - 7).match(r ? k : I), a += e.substr(s, t - s) + Ke(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1;
            return a + e.substr(s, e.length - s)
        }, Qe = function (e, t, n, i, r) {
            var s = t - e, a = i - n;
            return Fe(r, (function (t) {
                return n + ((t - e) / s * a || 0)
            }))
        }, et = function (e, t, n) {
            var i, r, s, a = e.labels, o = f;
            for (i in a) (r = a[i] - t) < 0 == !!n && r && o > (r = Math.abs(r)) && (s = i, o = r);
            return s
        }, tt = function (e, t, n) {
            var i, r, s = e.vars, a = s[t];
            if (a) return i = s[t + "Params"], r = s.callbackScope || e, n && X.length && le(), i ? a.apply(r, i) : a.call(r)
        }, nt = function (e) {
            return ye(e), e.scrollTrigger && e.scrollTrigger.kill(!1), e.progress() < 1 && tt(e, "onInterrupt"), e
        }, it = function (e) {
            var t = (e = !e.name && e.default || e).name, n = T(e), i = t && !n && e.init ? function () {
                    this._props = []
                } : e, r = {init: j, render: qt, add: It, kill: Kt, modifier: Yt, rawVars: 0},
                s = {targetTest: 0, get: 0, getSetter: Wt, aliases: {}, register: 0};
            if (ft(), e !== i) {
                if (Y[t]) return;
                de(i, de(me(e, r), s)), pe(i.prototype, pe(r, me(e, s))), Y[i.prop = t] = i, e.targetTest && (Z.push(i), $[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
            }
            W(t, i), e.register && e.register(rn, i, Qt)
        }, rt = 255, st = {
            aqua: [0, rt, rt],
            lime: [0, rt, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, rt],
            navy: [0, 0, 128],
            white: [rt, rt, rt],
            olive: [128, 128, 0],
            yellow: [rt, rt, 0],
            orange: [rt, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [rt, 0, 0],
            pink: [rt, 192, 203],
            cyan: [0, rt, rt],
            transparent: [rt, rt, rt, 0]
        }, at = function (e, t, n) {
            return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * rt + .5 | 0
        }, ot = function (e, t, n) {
            var i, r, s, a, o, l, c, h, u, d, p = e ? S(e) ? [e >> 16, e >> 8 & rt, e & rt] : 0 : st.black;
            if (!p) {
                if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), st[e]) p = st[e]; else if ("#" === e.charAt(0)) {
                    if (e.length < 6 && (i = e.charAt(1), r = e.charAt(2), s = e.charAt(3), e = "#" + i + i + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & rt, p & rt, parseInt(e.substr(7), 16) / 255];
                    p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & rt, e & rt]
                } else if ("hsl" === e.substr(0, 3)) if (p = d = e.match(I), t) {
                    if (~e.indexOf("=")) return p = e.match(O), n && p.length < 4 && (p[3] = 1), p
                } else a = +p[0] % 360 / 360, o = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), p.length > 3 && (p[3] *= 1), p[0] = at(a + 1 / 3, i, r), p[1] = at(a, i, r), p[2] = at(a - 1 / 3, i, r); else p = e.match(I) || st.transparent;
                p = p.map(Number)
            }
            return t && !d && (i = p[0] / rt, r = p[1] / rt, s = p[2] / rt, l = ((c = Math.max(i, r, s)) + (h = Math.min(i, r, s))) / 2, c === h ? a = o = 0 : (u = c - h, o = l > .5 ? u / (2 - c - h) : u / (c + h), a = c === i ? (r - s) / u + (r < s ? 6 : 0) : c === r ? (s - i) / u + 2 : (i - r) / u + 4, a *= 60), p[0] = ~~(a + .5), p[1] = ~~(100 * o + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p
        }, lt = function (e) {
            var t = [], n = [], i = -1;
            return e.split(ht).forEach((function (e) {
                var r = e.match(D) || [];
                t.push.apply(t, r), n.push(i += r.length + 1)
            })), t.c = n, t
        }, ct = function (e, t, n) {
            var i, r, s, a, o = "", l = (e + o).match(ht), c = t ? "hsla(" : "rgba(", h = 0;
            if (!l) return e;
            if (l = l.map((function (e) {
                return (e = ot(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
            })), n && (s = lt(e), (i = n.c).join(o) !== s.c.join(o))) for (a = (r = e.replace(ht, "1").split(D)).length - 1; h < a; h++) o += r[h] + (~i.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
            if (!r) for (a = (r = e.split(ht)).length - 1; h < a; h++) o += r[h] + l[h];
            return o + r[a]
        }, ht = function () {
            var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (e in st) t += "|" + e + "\\b";
            return new RegExp(t + ")", "gi")
        }(), ut = /hsl[a]?\(/, dt = function (e) {
            var t, n = e.join(" ");
            if (ht.lastIndex = 0, ht.test(n)) return t = ut.test(n), e[1] = ct(e[1], t), e[0] = ct(e[0], t, lt(e[1])), !0
        }, pt = function () {
            var e, t, n, i, r, c, h = Date.now, d = 500, p = 33, f = h(), m = f, g = 1e3 / 240, v = g, _ = [],
                y = function n(s) {
                    var a, o, l, u, y = h() - m, x = !0 === s;
                    if (y > d && (f += y - p), ((a = (l = (m += y) - f) - v) > 0 || x) && (u = ++i.frame, r = l - 1e3 * i.time, i.time = l /= 1e3, v += a + (a >= g ? 4 : g - a), o = 1), x || (e = t(n)), o) for (c = 0; c < _.length; c++) _[c](l, r, u, s)
                };
            return i = {
                time: 0, frame: 0, tick: function () {
                    y(!0)
                }, deltaRatio: function (e) {
                    return r / (1e3 / (e || 60))
                }, wake: function () {
                    l && (!a && L() && (s = a = window, o = s.document || {}, F.gsap = rn, (s.gsapVersions || (s.gsapVersions = [])).push(rn.version), z(H || s.GreenSockGlobals || !s.gsap && s || {}), n = s.requestAnimationFrame), e && i.sleep(), t = n || function (e) {
                        return setTimeout(e, v - 1e3 * i.time + 1 | 0)
                    }, u = 1, y(2))
                }, sleep: function () {
                    (n ? s.cancelAnimationFrame : clearTimeout)(e), u = 0, t = j
                }, lagSmoothing: function (e, t) {
                    d = e || 1e8, p = Math.min(t, d, 0)
                }, fps: function (e) {
                    g = 1e3 / (e || 240), v = 1e3 * i.time + g
                }, add: function (e, t, n) {
                    var r = t ? function (t, n, s, a) {
                        e(t, n, s, a), i.remove(r)
                    } : e;
                    return i.remove(e), _[n ? "unshift" : "push"](r), ft(), r
                }, remove: function (e, t) {
                    ~(t = _.indexOf(e)) && _.splice(t, 1) && c >= t && c--
                }, _listeners: _
            }, i
        }(), ft = function () {
            return !u && pt.wake()
        }, mt = {}, gt = /^[\d.\-M][\d.\-,\s]/, vt = /["']/g, _t = function (e) {
            for (var t, n, i, r = {}, s = e.substr(1, e.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++) n = s[o], t = o !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, t), r[a] = isNaN(i) ? i.replace(vt, "").trim() : +i, a = n.substr(t + 1).trim();
            return r
        }, yt = function (e) {
            return function (t) {
                return 1 - e(1 - t)
            }
        }, xt = function e(t, n) {
            for (var i, r = t._first; r;) r instanceof Lt ? e(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? e(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
        }, bt = function (e, t) {
            return e && (T(e) ? e : mt[e] || function (e) {
                var t, n, i, r, s = (e + "").split("("), a = mt[s[0]];
                return a && s.length > 1 && a.config ? a.config.apply(null, ~e.indexOf("{") ? [_t(s[1])] : (t = e, n = t.indexOf("(") + 1, i = t.indexOf(")"), r = t.indexOf("(", n), t.substring(n, ~r && r < i ? t.indexOf(")", i + 1) : i)).split(",").map(he)) : mt._CE && gt.test(e) ? mt._CE("", e) : a
            }(e)) || t
        }, wt = function (e, t, n, i) {
            void 0 === n && (n = function (e) {
                return 1 - t(1 - e)
            }), void 0 === i && (i = function (e) {
                return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
            });
            var r, s = {easeIn: t, easeOut: n, easeInOut: i};
            return ie(e, (function (e) {
                for (var t in mt[e] = F[e] = s, mt[r = e.toLowerCase()] = n, s) mt[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = mt[e + "." + t] = s[t]
            })), s
        }, Tt = function (e) {
            return function (t) {
                return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
            }
        }, St = function e(t, n, i) {
            var r = n >= 1 ? n : 1, s = (i || (t ? .3 : .45)) / (n < 1 ? n : 1), a = s / g * (Math.asin(1 / r) || 0),
                o = function (e) {
                    return 1 === e ? 1 : r * Math.pow(2, -10 * e) * b((e - a) * s) + 1
                }, l = "out" === t ? o : "in" === t ? function (e) {
                    return 1 - o(1 - e)
                } : Tt(o);
            return s = g / s, l.config = function (n, i) {
                return e(t, n, i)
            }, l
        }, Et = function e(t, n) {
            void 0 === n && (n = 1.70158);
            var i = function (e) {
                return e ? --e * e * ((n + 1) * e + n) + 1 : 0
            }, r = "out" === t ? i : "in" === t ? function (e) {
                return 1 - i(1 - e)
            } : Tt(i);
            return r.config = function (n) {
                return e(t, n)
            }, r
        };
    ie("Linear,Quad,Cubic,Quart,Quint,Strong", (function (e, t) {
        var n = t < 5 ? t + 1 : t;
        wt(e + ",Power" + (n - 1), t ? function (e) {
            return Math.pow(e, n)
        } : function (e) {
            return e
        }, (function (e) {
            return 1 - Math.pow(1 - e, n)
        }), (function (e) {
            return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2
        }))
    })), mt.Linear.easeNone = mt.none = mt.Linear.easeIn, wt("Elastic", St("in"), St("out"), St()), function (e, t) {
        var n = 1 / t, i = function (i) {
            return i < n ? e * i * i : i < .7272727272727273 ? e * Math.pow(i - 1.5 / t, 2) + .75 : i < .9090909090909092 ? e * (i -= 2.25 / t) * i + .9375 : e * Math.pow(i - 2.625 / t, 2) + .984375
        };
        wt("Bounce", (function (e) {
            return 1 - i(1 - e)
        }), i)
    }(7.5625, 2.75), wt("Expo", (function (e) {
        return e ? Math.pow(2, 10 * (e - 1)) : 0
    })), wt("Circ", (function (e) {
        return -(y(1 - e * e) - 1)
    })), wt("Sine", (function (e) {
        return 1 === e ? 1 : 1 - x(e * v)
    })), wt("Back", Et("in"), Et("out"), Et()), mt.SteppedEase = mt.steps = F.SteppedEase = {
        config: function (e, t) {
            void 0 === e && (e = 1);
            var n = 1 / e, i = e + (t ? 0 : 1), r = t ? 1 : 0;
            return function (e) {
                return ((i * He(0, .99999999, e) | 0) + r) * n
            }
        }
    }, p.ease = mt["quad.out"], ie("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (e) {
        return Q += e + "," + e + "Params,"
    }));
    var Mt = function (e, t) {
        this.id = _++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : ne, this.set = t ? t.getSetter : Wt
    }, At = function () {
        function e(e) {
            this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, De(this, +e.duration, 1, 1), this.data = e.data, u || pt.wake()
        }

        var t = e.prototype;
        return t.delay = function (e) {
            return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay
        }, t.duration = function (e) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
        }, t.totalDuration = function (e) {
            return arguments.length ? (this._dirty = 0, De(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, t.totalTime = function (e, t) {
            if (ft(), !arguments.length) return this._tTime;
            var n = this._dp;
            if (n && n.smoothChildTiming && this._ts) {
                for (Ae(this, e), !n._dp || n.parent || Le(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && Ce(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === m || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), ce(this, e, t)), this
        }, t.time = function (e, t) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + Te(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
        }, t.totalProgress = function (e, t) {
            return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
        }, t.progress = function (e, t) {
            return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + Te(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
        }, t.iteration = function (e, t) {
            var n = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? Se(this._tTime, n) + 1 : 1
        }, t.timeScale = function (e) {
            if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
            if (this._rts === e) return this;
            var t = this.parent && this._ts ? Ee(this.parent._time, this) : this._tTime;
            return this._rts = +e || 0, this._ts = this._ps || -1e-8 === e ? 0 : this._rts, this.totalTime(He(-this._delay, this._tDur, t), !0), Me(this), be(this)
        }, t.paused = function (e) {
            return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (ft(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== m && (this._tTime -= m)))), this) : this._ps
        }, t.startTime = function (e) {
            if (arguments.length) {
                this._start = e;
                var t = this.parent || this._dp;
                return t && (t._sort || !this.parent) && Ce(t, this, e - this._delay), this
            }
            return this._start
        }, t.endTime = function (e) {
            return this._start + (A(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }, t.rawTime = function (e) {
            var t = this.parent || this._dp;
            return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ee(t.rawTime(e), this) : this._tTime : this._tTime
        }, t.globalTime = function (e) {
            for (var t = this, n = arguments.length ? e : t.rawTime(); t;) n = t._start + n / (t._ts || 1), t = t._dp;
            return n
        }, t.repeat = function (e) {
            return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, Ne(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
        }, t.repeatDelay = function (e) {
            if (arguments.length) {
                var t = this._time;
                return this._rDelay = e, Ne(this), t ? this.time(t) : this
            }
            return this._rDelay
        }, t.yoyo = function (e) {
            return arguments.length ? (this._yoyo = e, this) : this._yoyo
        }, t.seek = function (e, t) {
            return this.totalTime(ke(this, e), A(t))
        }, t.restart = function (e, t) {
            return this.play().totalTime(e ? -this._delay : 0, A(t))
        }, t.play = function (e, t) {
            return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
        }, t.reverse = function (e, t) {
            return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
        }, t.pause = function (e, t) {
            return null != e && this.seek(e, t), this.paused(!0)
        }, t.resume = function () {
            return this.paused(!1)
        }, t.reversed = function (e) {
            return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)), this) : this._rts < 0
        }, t.invalidate = function () {
            return this._initted = this._act = 0, this._zTime = -1e-8, this
        }, t.isActive = function () {
            var e, t = this.parent || this._dp, n = this._start;
            return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - m))
        }, t.eventCallback = function (e, t, n) {
            var i = this.vars;
            return arguments.length > 1 ? (t ? (i[e] = t, n && (i[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete i[e], this) : i[e]
        }, t.then = function (e) {
            var t = this;
            return new Promise((function (n) {
                var i = T(e) ? e : ue, r = function () {
                    var e = t.then;
                    t.then = null, T(i) && (i = i(t)) && (i.then || i === t) && (t.then = e), n(i), t.then = e
                };
                t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r
            }))
        }, t.kill = function () {
            nt(this)
        }, e
    }();
    de(At.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Lt = function (e) {
        function i(n, i) {
            var s;
            return void 0 === n && (n = {}), (s = e.call(this, n) || this).labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = A(n.sortChildren), r && Ce(n.parent || r, t(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && Re(t(s), n.scrollTrigger), s
        }

        n(i, e);
        var s = i.prototype;
        return s.to = function (e, t, n) {
            return Ue(0, arguments, this), this
        }, s.from = function (e, t, n) {
            return Ue(1, arguments, this), this
        }, s.fromTo = function (e, t, n, i) {
            return Ue(2, arguments, this), this
        }, s.set = function (e, t, n) {
            return t.duration = 0, t.parent = this, ge(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new Ft(e, t, ke(this, n), 1), this
        }, s.call = function (e, t, n) {
            return Ce(this, Ft.delayedCall(0, e, t), n)
        }, s.staggerTo = function (e, t, n, i, r, s, a) {
            return n.duration = t, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = a, n.parent = this, new Ft(e, n, ke(this, r)), this
        }, s.staggerFrom = function (e, t, n, i, r, s, a) {
            return n.runBackwards = 1, ge(n).immediateRender = A(n.immediateRender), this.staggerTo(e, t, n, i, r, s, a)
        }, s.staggerFromTo = function (e, t, n, i, r, s, a, o) {
            return i.startAt = n, ge(i).immediateRender = A(i.immediateRender), this.staggerTo(e, t, i, r, s, a, o)
        }, s.render = function (e, t, n) {
            var i, s, a, o, l, c, h, u, d, p, f, g, v = this._time, _ = this._dirty ? this.totalDuration() : this._tDur,
                y = this._dur, x = e <= 0 ? 0 : se(e), b = this._zTime < 0 != e < 0 && (this._initted || !y);
            if (this !== r && x > _ && e >= 0 && (x = _), x !== this._tTime || n || b) {
                if (v !== this._time && y && (x += this._time - v, e += this._time - v), i = x, d = this._start, c = !(u = this._ts), b && (y || (v = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) {
                    if (f = this._yoyo, l = y + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * l + e, t, n);
                    if (i = se(x % l), x === _ ? (o = this._repeat, i = y) : ((o = ~~(x / l)) && o === x / l && (i = y, o--), i > y && (i = y)), p = Se(this._tTime, l), !v && this._tTime && p !== o && (p = o), f && 1 & o && (i = y - i, g = 1), o !== p && !this._lock) {
                        var w = f && 1 & p, T = w === (f && 1 & o);
                        if (o < p && (w = !w), v = w ? 0 : y, this._lock = 1, this.render(v || (g ? 0 : se(o * l)), t, !y)._lock = 0, this._tTime = x, !t && this.parent && tt(this, "onRepeat"), this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1), v && v !== this._time || c !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                        if (y = this._dur, _ = this._tDur, T && (this._lock = 2, v = w ? y : -1e-4, this.render(v, !0), this.vars.repeatRefresh && !g && this.invalidate()), this._lock = 0, !this._ts && !c) return this;
                        xt(this, g)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (h = function (e, t, n) {
                    var i;
                    if (n > t) for (i = e._first; i && i._start <= n;) {
                        if ("isPause" === i.data && i._start > t) return i;
                        i = i._next
                    } else for (i = e._last; i && i._start >= n;) {
                        if ("isPause" === i.data && i._start < t) return i;
                        i = i._prev
                    }
                }(this, se(v), se(i)), h && (x -= i - (i = h._start))), this._tTime = x, this._time = i, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, v = 0), !v && i && !t && (tt(this, "onStart"), this._tTime !== x)) return this;
                if (i >= v && e >= 0) for (s = this._first; s;) {
                    if (a = s._next, (s._act || i >= s._start) && s._ts && h !== s) {
                        if (s.parent !== this) return this.render(e, t, n);
                        if (s.render(s._ts > 0 ? (i - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (i - s._start) * s._ts, t, n), i !== this._time || !this._ts && !c) {
                            h = 0, a && (x += this._zTime = -1e-8);
                            break
                        }
                    }
                    s = a
                } else {
                    s = this._last;
                    for (var S = e < 0 ? e : i; s;) {
                        if (a = s._prev, (s._act || S <= s._end) && s._ts && h !== s) {
                            if (s.parent !== this) return this.render(e, t, n);
                            if (s.render(s._ts > 0 ? (S - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (S - s._start) * s._ts, t, n), i !== this._time || !this._ts && !c) {
                                h = 0, a && (x += this._zTime = S ? -1e-8 : m);
                                break
                            }
                        }
                        s = a
                    }
                }
                if (h && !t && (this.pause(), h.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1, this._ts)) return this._start = d, Me(this), this.render(e, t, n);
                this._onUpdate && !t && tt(this, "onUpdate", !0), (x === _ && this._tTime >= this.totalDuration() || !x && v) && (d !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((e || !y) && (x === _ && this._ts > 0 || !x && this._ts < 0) && ye(this, 1), t || e < 0 && !v || !x && !v && _ || (tt(this, x === _ && e >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(x < _ && this.timeScale() > 0) && this._prom())))
            }
            return this
        }, s.add = function (e, t) {
            var n = this;
            if (S(t) || (t = ke(this, t, e)), !(e instanceof At)) {
                if (P(e)) return e.forEach((function (e) {
                    return n.add(e, t)
                })), this;
                if (w(e)) return this.addLabel(e, t);
                if (!T(e)) return this;
                e = Ft.delayedCall(0, e)
            }
            return this !== e ? Ce(this, e, t) : this
        }, s.getChildren = function (e, t, n, i) {
            void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === i && (i = -1e8);
            for (var r = [], s = this._first; s;) s._start >= i && (s instanceof Ft ? t && r.push(s) : (n && r.push(s), e && r.push.apply(r, s.getChildren(!0, t, n)))), s = s._next;
            return r
        }, s.getById = function (e) {
            for (var t = this.getChildren(1, 1, 1), n = t.length; n--;) if (t[n].vars.id === e) return t[n]
        }, s.remove = function (e) {
            return w(e) ? this.removeLabel(e) : T(e) ? this.killTweensOf(e) : (_e(this, e), e === this._recent && (this._recent = this._last), xe(this))
        }, s.totalTime = function (t, n) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = se(pt.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, n), this._forcing = 0, this) : this._tTime
        }, s.addLabel = function (e, t) {
            return this.labels[e] = ke(this, t), this
        }, s.removeLabel = function (e) {
            return delete this.labels[e], this
        }, s.addPause = function (e, t, n) {
            var i = Ft.delayedCall(0, t || j, n);
            return i.data = "isPause", this._hasPause = 1, Ce(this, i, ke(this, e))
        }, s.removePause = function (e) {
            var t = this._first;
            for (e = ke(this, e); t;) t._start === e && "isPause" === t.data && ye(t), t = t._next
        }, s.killTweensOf = function (e, t, n) {
            for (var i = this.getTweensOf(e, n), r = i.length; r--;) Ct !== i[r] && i[r].kill(e, t);
            return this
        }, s.getTweensOf = function (e, t) {
            for (var n, i = [], r = je(e), s = this._first, a = S(t); s;) s instanceof Ft ? oe(s._targets, r) && (a ? (!Ct || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, t)).length && i.push.apply(i, n), s = s._next;
            return i
        }, s.tweenTo = function (e, t) {
            t = t || {};
            var n, i = this, r = ke(i, e), s = t, a = s.startAt, o = s.onStart, l = s.onStartParams,
                c = s.immediateRender, h = Ft.to(i, de({
                    ease: t.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration: t.duration || Math.abs((r - (a && "time" in a ? a.time : i._time)) / i.timeScale()) || m,
                    onStart: function () {
                        if (i.pause(), !n) {
                            var e = t.duration || Math.abs((r - (a && "time" in a ? a.time : i._time)) / i.timeScale());
                            h._dur !== e && De(h, e, 0, 1).render(h._time, !0, !0), n = 1
                        }
                        o && o.apply(h, l || [])
                    }
                }, t));
            return c ? h.render(0) : h
        }, s.tweenFromTo = function (e, t, n) {
            return this.tweenTo(t, de({startAt: {time: ke(this, e)}}, n))
        }, s.recent = function () {
            return this._recent
        }, s.nextLabel = function (e) {
            return void 0 === e && (e = this._time), et(this, ke(this, e))
        }, s.previousLabel = function (e) {
            return void 0 === e && (e = this._time), et(this, ke(this, e), 1)
        }, s.currentLabel = function (e) {
            return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + m)
        }, s.shiftChildren = function (e, t, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, s = this.labels; r;) r._start >= n && (r._start += e, r._end += e), r = r._next;
            if (t) for (i in s) s[i] >= n && (s[i] += e);
            return xe(this)
        }, s.invalidate = function () {
            var t = this._first;
            for (this._lock = 0; t;) t.invalidate(), t = t._next;
            return e.prototype.invalidate.call(this)
        }, s.clear = function (e) {
            void 0 === e && (e = !0);
            for (var t, n = this._first; n;) t = n._next, this.remove(n), n = t;
            return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), xe(this)
        }, s.totalDuration = function (e) {
            var t, n, i, s = 0, a = this, o = a._last, l = f;
            if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -e : e));
            if (a._dirty) {
                for (i = a.parent; o;) t = o._prev, o._dirty && o.totalDuration(), (n = o._start) > l && a._sort && o._ts && !a._lock ? (a._lock = 1, Ce(a, o, n - o._delay, 1)._lock = 0) : l = n, n < 0 && o._ts && (s -= n, (!i && !a._dp || i && i.smoothChildTiming) && (a._start += n / a._ts, a._time -= n, a._tTime -= n), a.shiftChildren(-n, !1, -Infinity), l = 0), o._end > s && o._ts && (s = o._end), o = t;
                De(a, a === r && a._time > s ? a._time : s, 1, 1), a._dirty = 0
            }
            return a._tDur
        }, i.updateRoot = function (e) {
            if (r._ts && (ce(r, Ee(e, r)), c = pt.frame), pt.frame >= J) {
                J += d.autoSleep || 120;
                var t = r._first;
                if ((!t || !t._ts) && d.autoSleep && pt._listeners.length < 2) {
                    for (; t && !t._ts;) t = t._next;
                    t || pt.sleep()
                }
            }
        }, i
    }(At);
    de(Lt.prototype, {_lock: 0, _hasPause: 0, _forcing: 0});
    var Ct, Rt, Pt = function (e, t, n, i, r, s, a) {
        var o, l, c, h, u, d, p, f, m = new Qt(this._pt, e, t, 0, 1, Xt, null, r), g = 0, v = 0;
        for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = Ze(i)), s && (s(f = [n, i], e, t), n = f[0], i = f[1]), l = n.match(N) || []; o = N.exec(i);) h = o[0], u = i.substring(g, o.index), c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1), h !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = {
            _next: m._pt,
            p: u || 1 === v ? u : ",",
            s: d,
            c: "=" === h.charAt(1) ? ae(d, h) - d : parseFloat(h) - d,
            m: c && c < 4 ? Math.round : 0
        }, g = N.lastIndex);
        return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = a, (B.test(i) || p) && (m.e = 0), this._pt = m, m
    }, It = function (e, t, n, i, r, s, a, o, l) {
        T(i) && (i = i(r || 0, e, s));
        var c, h = e[t],
            u = "get" !== n ? n : T(h) ? l ? e[t.indexOf("set") || !T(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : h,
            p = T(h) ? l ? Gt : zt : Ht;
        if (w(i) && (~i.indexOf("random(") && (i = Ze(i)), "=" === i.charAt(1) && ((c = ae(u, i) + (ze(u) || 0)) || 0 === c) && (i = c)), u !== i || Rt) return isNaN(u * i) || "" === i ? (!h && !(t in e) && G(t, i), Pt.call(this, e, t, u, i, p, o || d.stringFilter, l)) : (c = new Qt(this._pt, e, t, +u || 0, i - (u || 0), "boolean" == typeof h ? $t : jt, 0, p), l && (c.fp = l), a && c.modifier(a, this, e), this._pt = c)
    }, Ot = function (e, t, n, i, r, s) {
        var a, o, l, c;
        if (Y[e] && !1 !== (a = new Y[e]).init(r, a.rawVars ? t[e] : function (e, t, n, i, r) {
            if (T(e) && (e = Bt(e, r, t, n, i)), !M(e) || e.style && e.nodeType || P(e) || R(e)) return w(e) ? Bt(e, r, t, n, i) : e;
            var s, a = {};
            for (s in e) a[s] = Bt(e[s], r, t, n, i);
            return a
        }(t[e], i, r, s, n), n, i, s) && (n._pt = o = new Qt(n._pt, r, e, 0, 1, a.render, a, 0, a.priority), n !== h)) for (l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length; c--;) l[a._props[c]] = o;
        return a
    }, Dt = function e(t, n) {
        var s, a, o, l, c, h, u, d, g, v, _, y, x, b = t.vars, w = b.ease, T = b.startAt, S = b.immediateRender,
            E = b.lazy, M = b.onUpdate, L = b.onUpdateParams, C = b.callbackScope, R = b.runBackwards, P = b.yoyoEase,
            I = b.keyframes, O = b.autoRevert, D = t._dur, N = t._startAt, B = t._targets, k = t.parent,
            U = k && "nested" === k.data ? k.parent._targets : B, F = "auto" === t._overwrite && !i, H = t.timeline;
        if (H && (!I || !w) && (w = "none"), t._ease = bt(w, p.ease), t._yEase = P ? yt(bt(!0 === P ? w : P, p.ease)) : 0, P && t._yoyo && !t._repeat && (P = t._yEase, t._yEase = t._ease, t._ease = P), t._from = !H && !!b.runBackwards, !H || I && !b.stagger) {
            if (y = (d = B[0] ? te(B[0]).harness : 0) && b[d.prop], s = me(b, $), N && (ye(N.render(-1, !0)), N._lazy = 0), T) if (ye(t._startAt = Ft.set(B, de({
                data: "isStart",
                overwrite: !1,
                parent: k,
                immediateRender: !0,
                lazy: A(E),
                startAt: null,
                delay: 0,
                onUpdate: M,
                onUpdateParams: L,
                callbackScope: C,
                stagger: 0
            }, T))), n < 0 && !S && !O && t._startAt.render(-1, !0), S) {
                if (n > 0 && !O && (t._startAt = 0), D && n <= 0) return void (n && (t._zTime = n))
            } else !1 === O && (t._startAt = 0); else if (R && D) if (N) !O && (t._startAt = 0); else if (n && (S = !1), o = de({
                overwrite: !1,
                data: "isFromStart",
                lazy: S && A(E),
                immediateRender: S,
                stagger: 0,
                parent: k
            }, s), y && (o[d.prop] = y), ye(t._startAt = Ft.set(B, o)), n < 0 && t._startAt.render(-1, !0), t._zTime = n, S) {
                if (!n) return
            } else e(t._startAt, m);
            for (t._pt = t._ptCache = 0, E = D && A(E) || E && !D, a = 0; a < B.length; a++) {
                if (u = (c = B[a])._gsap || ee(B)[a]._gsap, t._ptLookup[a] = v = {}, q[u.id] && X.length && le(), _ = U === B ? a : U.indexOf(c), d && !1 !== (g = new d).init(c, y || s, t, _, U) && (t._pt = l = new Qt(t._pt, c, g.name, 0, 1, g.render, g, 0, g.priority), g._props.forEach((function (e) {
                    v[e] = l
                })), g.priority && (h = 1)), !d || y) for (o in s) Y[o] && (g = Ot(o, s, t, _, c, U)) ? g.priority && (h = 1) : v[o] = l = It.call(t, c, o, "get", s[o], _, U, 0, b.stringFilter);
                t._op && t._op[a] && t.kill(c, t._op[a]), F && t._pt && (Ct = t, r.killTweensOf(c, v, t.globalTime(n)), x = !t.parent, Ct = 0), t._pt && E && (q[u.id] = 1)
            }
            h && Zt(t), t._onInit && t._onInit(t)
        }
        t._onUpdate = M, t._initted = (!t._op || t._pt) && !x, I && n <= 0 && H.render(f, !0, !0)
    }, Nt = function (e, t, n, i) {
        var r, s, a = t.ease || i || "power1.inOut";
        if (P(t)) s = n[e] || (n[e] = []), t.forEach((function (e, n) {
            return s.push({t: n / (t.length - 1) * 100, v: e, e: a})
        })); else for (r in t) s = n[r] || (n[r] = []), "ease" === r || s.push({t: parseFloat(e), v: t[r], e: a})
    }, Bt = function (e, t, n, i, r) {
        return T(e) ? e.call(t, n, i, r) : w(e) && ~e.indexOf("random(") ? Ze(e) : e
    }, kt = Q + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Ut = {};
    ie(kt + ",id,stagger,delay,duration,paused,scrollTrigger", (function (e) {
        return Ut[e] = 1
    }));
    var Ft = function (e) {
        function s(n, s, a, o) {
            var l;
            "number" == typeof s && (a.duration = s, s = a, a = null);
            var c, h, u, p, f, m, g, v, _ = (l = e.call(this, o ? s : ge(s)) || this).vars, y = _.duration, x = _.delay,
                b = _.immediateRender, w = _.stagger, T = _.overwrite, E = _.keyframes, L = _.defaults,
                I = _.scrollTrigger, O = _.yoyoEase, D = s.parent || r,
                N = (P(n) || R(n) ? S(n[0]) : "length" in s) ? [n] : je(n);
            if (l._targets = N.length ? ee(N) : V("GSAP target " + n + " not found. https://greensock.com", !d.nullTargetWarn) || [], l._ptLookup = [], l._overwrite = T, E || w || C(y) || C(x)) {
                if (s = l.vars, (c = l.timeline = new Lt({
                    data: "nested",
                    defaults: L || {}
                })).kill(), c.parent = c._dp = t(l), c._start = 0, w || C(y) || C(x)) {
                    if (p = N.length, g = w && Xe(w), M(w)) for (f in w) ~kt.indexOf(f) && (v || (v = {}), v[f] = w[f]);
                    for (h = 0; h < p; h++) (u = me(s, Ut)).stagger = 0, O && (u.yoyoEase = O), v && pe(u, v), m = N[h], u.duration = +Bt(y, t(l), h, m, N), u.delay = (+Bt(x, t(l), h, m, N) || 0) - l._delay, !w && 1 === p && u.delay && (l._delay = x = u.delay, l._start += x, u.delay = 0), c.to(m, u, g ? g(h, m, N) : 0), c._ease = mt.none;
                    c.duration() ? y = x = 0 : l.timeline = 0
                } else if (E) {
                    ge(de(c.vars.defaults, {ease: "none"})), c._ease = bt(E.ease || s.ease || "none");
                    var B, k, U, F = 0;
                    if (P(E)) E.forEach((function (e) {
                        return c.to(N, e, ">")
                    })); else {
                        for (f in u = {}, E) "ease" === f || "easeEach" === f || Nt(f, E[f], u, E.easeEach);
                        for (f in u) for (B = u[f].sort((function (e, t) {
                            return e.t - t.t
                        })), F = 0, h = 0; h < B.length; h++) (U = {
                            ease: (k = B[h]).e,
                            duration: (k.t - (h ? B[h - 1].t : 0)) / 100 * y
                        })[f] = k.v, c.to(N, U, F), F += U.duration;
                        c.duration() < y && c.to({}, {duration: y - c.duration()})
                    }
                }
                y || l.duration(y = c.duration())
            } else l.timeline = 0;
            return !0 !== T || i || (Ct = t(l), r.killTweensOf(N), Ct = 0), Ce(D, t(l), a), s.reversed && l.reverse(), s.paused && l.paused(!0), (b || !y && !E && l._start === se(D._time) && A(b) && we(t(l)) && "nested" !== D.data) && (l._tTime = -1e-8, l.render(Math.max(0, -x))), I && Re(t(l), I), l
        }

        n(s, e);
        var a = s.prototype;
        return a.render = function (e, t, n) {
            var i, r, s, a, o, l, c, h, u, d = this._time, p = this._tDur, f = this._dur,
                g = e > p - m && e >= 0 ? p : e < m ? 0 : e;
            if (f) {
                if (g !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != e < 0) {
                    if (i = g, h = this.timeline, this._repeat) {
                        if (a = f + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * a + e, t, n);
                        if (i = se(g % a), g === p ? (s = this._repeat, i = f) : ((s = ~~(g / a)) && s === g / a && (i = f, s--), i > f && (i = f)), (l = this._yoyo && 1 & s) && (u = this._yEase, i = f - i), o = Se(this._tTime, a), i === d && !n && this._initted) return this._tTime = g, this;
                        s !== o && (h && this._yEase && xt(h, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(se(a * s), !0).invalidate()._lock = 0))
                    }
                    if (!this._initted) {
                        if (Pe(this, e < 0 ? e : i, n, t)) return this._tTime = 0, this;
                        if (d !== this._time) return this;
                        if (f !== this._dur) return this.render(e, t, n)
                    }
                    if (this._tTime = g, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (u || this._ease)(i / f), this._from && (this.ratio = c = 1 - c), i && !d && !t && (tt(this, "onStart"), this._tTime !== g)) return this;
                    for (r = this._pt; r;) r.r(c, r.d), r = r._next;
                    h && h.render(e < 0 ? e : !i && l ? -1e-8 : h._dur * h._ease(i / this._dur), t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (e < 0 && this._startAt && this._startAt.render(e, !0, n), tt(this, "onUpdate")), this._repeat && s !== o && this.vars.onRepeat && !t && this.parent && tt(this, "onRepeat"), g !== this._tDur && g || this._tTime !== g || (e < 0 && this._startAt && !this._onUpdate && this._startAt.render(e, !0, !0), (e || !f) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && ye(this, 1), t || e < 0 && !d || !g && !d || (tt(this, g === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < p && this.timeScale() > 0) && this._prom()))
                }
            } else !function (e, t, n, i) {
                var r, s, a, o = e.ratio,
                    l = t < 0 || !t && (!e._start && Ie(e) && (e._initted || !Oe(e)) || (e._ts < 0 || e._dp._ts < 0) && !Oe(e)) ? 0 : 1,
                    c = e._rDelay, h = 0;
                if (c && e._repeat && (h = He(0, e._tDur, t), s = Se(h, c), e._yoyo && 1 & s && (l = 1 - l), s !== Se(e._tTime, c) && (o = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== o || i || e._zTime === m || !t && e._zTime) {
                    if (!e._initted && Pe(e, t, i, n)) return;
                    for (a = e._zTime, e._zTime = t || (n ? m : 0), n || (n = t && !a), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = h, r = e._pt; r;) r.r(l, r.d), r = r._next;
                    e._startAt && t < 0 && e._startAt.render(t, !0, !0), e._onUpdate && !n && tt(e, "onUpdate"), h && e._repeat && !n && e.parent && tt(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && ye(e, 1), n || (tt(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                } else e._zTime || (e._zTime = t)
            }(this, e, t, n);
            return this
        }, a.targets = function () {
            return this._targets
        }, a.invalidate = function () {
            return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), e.prototype.invalidate.call(this)
        }, a.resetTo = function (e, t, n, i) {
            u || pt.wake(), this._ts || this.play();
            var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
            return this._initted || Dt(this, r), function (e, t, n, i, r, s, a) {
                var o, l, c, h = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                if (!h) for (h = e._ptCache[t] = [], l = e._ptLookup, c = e._targets.length; c--;) {
                    if ((o = l[c][t]) && o.d && o.d._pt) for (o = o.d._pt; o && o.p !== t;) o = o._next;
                    if (!o) return Rt = 1, e.vars[t] = "+=0", Dt(e, a), Rt = 0, 1;
                    h.push(o)
                }
                for (c = h.length; c--;) (o = h[c]).s = !i && 0 !== i || r ? o.s + (i || 0) + s * o.c : i, o.c = n - o.s, o.e && (o.e = re(n) + ze(o.e)), o.b && (o.b = o.s + ze(o.b))
            }(this, e, t, n, i, this._ease(r / this._dur), r) ? this.resetTo(e, t, n, i) : (Ae(this, 0), this.parent || ve(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
        }, a.kill = function (e, t) {
            if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? nt(this) : this;
            if (this.timeline) {
                var n = this.timeline.totalDuration();
                return this.timeline.killTweensOf(e, t, Ct && !0 !== Ct.vars.overwrite)._first || nt(this), this.parent && n !== this.timeline.totalDuration() && De(this, this._dur * this.timeline._tDur / n, 0, 1), this
            }
            var i, r, s, a, o, l, c, h = this._targets, u = e ? je(e) : h, d = this._ptLookup, p = this._pt;
            if ((!t || "all" === t) && function (e, t) {
                for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];) ;
                return n < 0
            }(h, u)) return "all" === t && (this._pt = 0), nt(this);
            for (i = this._op = this._op || [], "all" !== t && (w(t) && (o = {}, ie(t, (function (e) {
                return o[e] = 1
            })), t = o), t = function (e, t) {
                var n, i, r, s, a = e[0] ? te(e[0]).harness : 0, o = a && a.aliases;
                if (!o) return t;
                for (i in n = pe({}, t), o) if (i in n) for (r = (s = o[i].split(",")).length; r--;) n[s[r]] = n[i];
                return n
            }(h, t)), c = h.length; c--;) if (~u.indexOf(h[c])) for (o in r = d[c], "all" === t ? (i[c] = t, a = r, s = {}) : (s = i[c] = i[c] || {}, a = t), a) (l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || _e(this, l, "_pt"), delete r[o]), "all" !== s && (s[o] = 1);
            return this._initted && !this._pt && p && nt(this), this
        }, s.to = function (e, t) {
            return new s(e, t, arguments[2])
        }, s.from = function (e, t) {
            return Ue(1, arguments)
        }, s.delayedCall = function (e, t, n, i) {
            return new s(t, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: e,
                onComplete: t,
                onReverseComplete: t,
                onCompleteParams: n,
                onReverseCompleteParams: n,
                callbackScope: i
            })
        }, s.fromTo = function (e, t, n) {
            return Ue(2, arguments)
        }, s.set = function (e, t) {
            return t.duration = 0, t.repeatDelay || (t.repeat = 0), new s(e, t)
        }, s.killTweensOf = function (e, t, n) {
            return r.killTweensOf(e, t, n)
        }, s
    }(At);
    de(Ft.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), ie("staggerTo,staggerFrom,staggerFromTo", (function (e) {
        Ft[e] = function () {
            var t = new Lt, n = Ge.call(arguments, 0);
            return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n)
        }
    }));
    var Ht = function (e, t, n) {
        return e[t] = n
    }, zt = function (e, t, n) {
        return e[t](n)
    }, Gt = function (e, t, n, i) {
        return e[t](i.fp, n)
    }, Vt = function (e, t, n) {
        return e.setAttribute(t, n)
    }, Wt = function (e, t) {
        return T(e[t]) ? zt : E(e[t]) && e.setAttribute ? Vt : Ht
    }, jt = function (e, t) {
        return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
    }, $t = function (e, t) {
        return t.set(t.t, t.p, !!(t.s + t.c * e), t)
    }, Xt = function (e, t) {
        var n = t._pt, i = "";
        if (!e && t.b) i = t.b; else if (1 === e && t.e) i = t.e; else {
            for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + i, n = n._next;
            i += t.c
        }
        t.set(t.t, t.p, i, t)
    }, qt = function (e, t) {
        for (var n = t._pt; n;) n.r(e, n.d), n = n._next
    }, Yt = function (e, t, n, i) {
        for (var r, s = this._pt; s;) r = s._next, s.p === i && s.modifier(e, t, n), s = r
    }, Kt = function (e) {
        for (var t, n, i = this._pt; i;) n = i._next, i.p === e && !i.op || i.op === e ? _e(this, i, "_pt") : i.dep || (t = 1), i = n;
        return !t
    }, Jt = function (e, t, n, i) {
        i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
    }, Zt = function (e) {
        for (var t, n, i, r, s = e._pt; s;) {
            for (t = s._next, n = i; n && n.pr > s.pr;) n = n._next;
            (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s, (s._next = n) ? n._prev = s : r = s, s = t
        }
        e._pt = i
    }, Qt = function () {
        function e(e, t, n, i, r, s, a, o, l) {
            this.t = t, this.s = i, this.c = r, this.p = n, this.r = s || jt, this.d = a || this, this.set = o || Ht, this.pr = l || 0, this._next = e, e && (e._prev = this)
        }

        return e.prototype.modifier = function (e, t, n) {
            this.mSet = this.mSet || this.set, this.set = Jt, this.m = e, this.mt = n, this.tween = t
        }, e
    }();
    ie(Q + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (e) {
        return $[e] = 1
    })), F.TweenMax = F.TweenLite = Ft, F.TimelineLite = F.TimelineMax = Lt, r = new Lt({
        sortChildren: !1,
        defaults: p,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), d.stringFilter = dt;
    var en = {
        registerPlugin: function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            t.forEach((function (e) {
                return it(e)
            }))
        },
        timeline: function (e) {
            return new Lt(e)
        },
        getTweensOf: function (e, t) {
            return r.getTweensOf(e, t)
        },
        getProperty: function (e, t, n, i) {
            w(e) && (e = je(e)[0]);
            var r = te(e || {}).get, s = n ? ue : he;
            return "native" === n && (n = ""), e ? t ? s((Y[t] && Y[t].get || r)(e, t, n, i)) : function (t, n, i) {
                return s((Y[t] && Y[t].get || r)(e, t, n, i))
            } : e
        },
        quickSetter: function (e, t, n) {
            if ((e = je(e)).length > 1) {
                var i = e.map((function (e) {
                    return rn.quickSetter(e, t, n)
                })), r = i.length;
                return function (e) {
                    for (var t = r; t--;) i[t](e)
                }
            }
            e = e[0] || {};
            var s = Y[t], a = te(e), o = a.harness && (a.harness.aliases || {})[t] || t, l = s ? function (t) {
                var i = new s;
                h._pt = 0, i.init(e, n ? t + n : t, h, 0, [e]), i.render(1, i), h._pt && qt(1, h)
            } : a.set(e, o);
            return s ? l : function (t) {
                return l(e, o, n ? t + n : t, a, 1)
            }
        },
        quickTo: function (e, t, n) {
            var i, r = rn.to(e, pe(((i = {})[t] = "+=0.1", i.paused = !0, i), n || {})), s = function (e, n, i) {
                return r.resetTo(t, e, n, i)
            };
            return s.tween = r, s
        },
        isTweening: function (e) {
            return r.getTweensOf(e, !0).length > 0
        },
        defaults: function (e) {
            return e && e.ease && (e.ease = bt(e.ease, p.ease)), fe(p, e || {})
        },
        config: function (e) {
            return fe(d, e || {})
        },
        registerEffect: function (e) {
            var t = e.name, n = e.effect, i = e.plugins, r = e.defaults, s = e.extendTimeline;
            (i || "").split(",").forEach((function (e) {
                return e && !Y[e] && !F[e] && V(t + " effect requires " + e + " plugin.")
            })), K[t] = function (e, t, i) {
                return n(je(e), de(t || {}, r), i)
            }, s && (Lt.prototype[t] = function (e, n, i) {
                return this.add(K[t](e, M(n) ? n : (i = n) && {}, this), i)
            })
        },
        registerEase: function (e, t) {
            mt[e] = bt(t)
        },
        parseEase: function (e, t) {
            return arguments.length ? bt(e, t) : mt
        },
        getById: function (e) {
            return r.getById(e)
        },
        exportRoot: function (e, t) {
            void 0 === e && (e = {});
            var n, i, s = new Lt(e);
            for (s.smoothChildTiming = A(e.smoothChildTiming), r.remove(s), s._dp = 0, s._time = s._tTime = r._time, n = r._first; n;) i = n._next, !t && !n._dur && n instanceof Ft && n.vars.onComplete === n._targets[0] || Ce(s, n, n._start - n._delay), n = i;
            return Ce(r, s, 0), s
        },
        utils: {
            wrap: function e(t, n, i) {
                var r = n - t;
                return P(t) ? Je(t, e(0, t.length), n) : Fe(i, (function (e) {
                    return (r + (e - t) % r) % r + t
                }))
            }, wrapYoyo: function e(t, n, i) {
                var r = n - t, s = 2 * r;
                return P(t) ? Je(t, e(0, t.length - 1), n) : Fe(i, (function (e) {
                    return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e)
                }))
            }, distribute: Xe, random: Ke, snap: Ye, normalize: function (e, t, n) {
                return Qe(e, t, 0, 1, n)
            }, getUnit: ze, clamp: function (e, t, n) {
                return Fe(n, (function (n) {
                    return He(e, t, n)
                }))
            }, splitColor: ot, toArray: je, selector: function (e) {
                return e = je(e)[0] || V("Invalid scope") || {}, function (t) {
                    var n = e.current || e.nativeElement || e;
                    return je(t, n.querySelectorAll ? n : n === e ? V("Invalid scope") || o.createElement("div") : e)
                }
            }, mapRange: Qe, pipe: function () {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return function (e) {
                    return t.reduce((function (e, t) {
                        return t(e)
                    }), e)
                }
            }, unitize: function (e, t) {
                return function (n) {
                    return e(parseFloat(n)) + (t || ze(n))
                }
            }, interpolate: function e(t, n, i, r) {
                var s = isNaN(t + n) ? 0 : function (e) {
                    return (1 - e) * t + e * n
                };
                if (!s) {
                    var a, o, l, c, h, u = w(t), d = {};
                    if (!0 === i && (r = 1) && (i = null), u) t = {p: t}, n = {p: n}; else if (P(t) && !P(n)) {
                        for (l = [], c = t.length, h = c - 2, o = 1; o < c; o++) l.push(e(t[o - 1], t[o]));
                        c--, s = function (e) {
                            e *= c;
                            var t = Math.min(h, ~~e);
                            return l[t](e - t)
                        }, i = n
                    } else r || (t = pe(P(t) ? [] : {}, t));
                    if (!l) {
                        for (a in n) It.call(d, t, a, "get", n[a]);
                        s = function (e) {
                            return qt(e, d) || (u ? t.p : t)
                        }
                    }
                }
                return Fe(i, s)
            }, shuffle: $e
        },
        install: z,
        effects: K,
        ticker: pt,
        updateRoot: Lt.updateRoot,
        plugins: Y,
        globalTimeline: r,
        core: {
            PropTween: Qt,
            globals: W,
            Tween: Ft,
            Timeline: Lt,
            Animation: At,
            getCache: te,
            _removeLinkedListItem: _e,
            suppressOverwrites: function (e) {
                return i = e
            }
        }
    };
    ie("to,from,fromTo,delayedCall,set,killTweensOf", (function (e) {
        return en[e] = Ft[e]
    })), pt.add(Lt.updateRoot), h = en.to({}, {duration: 0});
    var tn = function (e, t) {
        for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
        return n
    }, nn = function (e, t) {
        return {
            name: e, rawVars: 1, init: function (e, n, i) {
                i._onInit = function (e) {
                    var i, r;
                    if (w(n) && (i = {}, ie(n, (function (e) {
                        return i[e] = 1
                    })), n = i), t) {
                        for (r in i = {}, n) i[r] = t(n[r]);
                        n = i
                    }
                    !function (e, t) {
                        var n, i, r, s = e._targets;
                        for (n in t) for (i = s.length; i--;) (r = e._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = tn(r, n)), r && r.modifier && r.modifier(t[n], e, s[i], n))
                    }(e, n)
                }
            }
        }
    }, rn = en.registerPlugin({
        name: "attr", init: function (e, t, n, i, r) {
            var s, a;
            for (s in t) (a = this.add(e, "setAttribute", (e.getAttribute(s) || 0) + "", t[s], i, r, 0, 0, s)) && (a.op = s), this._props.push(s)
        }
    }, {
        name: "endArray", init: function (e, t) {
            for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n])
        }
    }, nn("roundProps", qe), nn("modifiers"), nn("snap", Ye)) || en;
    Ft.version = Lt.version = rn.version = "3.10.1", l = 1, L() && ft(), mt.Power0, mt.Power1, mt.Power2, mt.Power3, mt.Power4, mt.Linear, mt.Quad, mt.Cubic, mt.Quart, mt.Quint, mt.Strong, mt.Elastic, mt.Back, mt.SteppedEase, mt.Bounce, mt.Sine, mt.Expo, mt.Circ;
    /*!
     * CSSPlugin 3.10.1
     * https://greensock.com
     *
     * Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var sn, an, on, ln, cn, hn, un, dn = {}, pn = 180 / Math.PI, fn = Math.PI / 180, mn = Math.atan2, gn = /([A-Z])/g,
        vn = /(left|right|width|margin|padding|x)/i, _n = /[\s,\(]\S/,
        yn = {autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity"}, xn = function (e, t) {
            return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
        }, bn = function (e, t) {
            return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
        }, wn = function (e, t) {
            return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
        }, Tn = function (e, t) {
            var n = t.s + t.c * e;
            t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
        }, Sn = function (e, t) {
            return t.set(t.t, t.p, e ? t.e : t.b, t)
        }, En = function (e, t) {
            return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
        }, Mn = function (e, t, n) {
            return e.style[t] = n
        }, An = function (e, t, n) {
            return e.style.setProperty(t, n)
        }, Ln = function (e, t, n) {
            return e._gsap[t] = n
        }, Cn = function (e, t, n) {
            return e._gsap.scaleX = e._gsap.scaleY = n
        }, Rn = function (e, t, n, i, r) {
            var s = e._gsap;
            s.scaleX = s.scaleY = n, s.renderTransform(r, s)
        }, Pn = function (e, t, n, i, r) {
            var s = e._gsap;
            s[t] = n, s.renderTransform(r, s)
        }, In = "transform", On = In + "Origin", Dn = function (e, t) {
            var n = an.createElementNS ? an.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : an.createElement(e);
            return n.style ? n : an.createElement(e)
        }, Nn = function e(t, n, i) {
            var r = getComputedStyle(t);
            return r[n] || r.getPropertyValue(n.replace(gn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && e(t, kn(n) || n, 1) || ""
        }, Bn = "O,Moz,ms,Ms,Webkit".split(","), kn = function (e, t, n) {
            var i = (t || cn).style, r = 5;
            if (e in i && !n) return e;
            for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(Bn[r] + e in i);) ;
            return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Bn[r] : "") + e
        }, Un = function () {
            "undefined" != typeof window && window.document && (sn = window, an = sn.document, on = an.documentElement, cn = Dn("div") || {style: {}}, Dn("div"), In = kn(In), On = In + "Origin", cn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", un = !!kn("perspective"), ln = 1)
        }, Fn = function e(t) {
            var n,
                i = Dn("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
            if (on.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e
            } catch (e) {
            } else this._gsapBBox && (n = this._gsapBBox());
            return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), on.removeChild(i), this.style.cssText = a, n
        }, Hn = function (e, t) {
            for (var n = t.length; n--;) if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
        }, zn = function (e) {
            var t;
            try {
                t = e.getBBox()
            } catch (n) {
                t = Fn.call(e, !0)
            }
            return t && (t.width || t.height) || e.getBBox === Fn || (t = Fn.call(e, !0)), !t || t.width || t.x || t.y ? t : {
                x: +Hn(e, ["x", "cx", "x1"]) || 0,
                y: +Hn(e, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        }, Gn = function (e) {
            return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !zn(e))
        }, Vn = function (e, t) {
            if (t) {
                var n = e.style;
                t in dn && t !== On && (t = In), n.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), n.removeProperty(t.replace(gn, "-$1").toLowerCase())) : n.removeAttribute(t)
            }
        }, Wn = function (e, t, n, i, r, s) {
            var a = new Qt(e._pt, t, n, 0, 1, s ? En : Sn);
            return e._pt = a, a.b = i, a.e = r, e._props.push(n), a
        }, jn = {deg: 1, rad: 1, turn: 1}, $n = function e(t, n, i, r) {
            var s, a, o, l, c = parseFloat(i) || 0, h = (i + "").trim().substr((c + "").length) || "px", u = cn.style,
                d = vn.test(n), p = "svg" === t.tagName.toLowerCase(),
                f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
            return r === h || !c || jn[r] || jn[h] ? c : ("px" !== h && !g && (c = e(t, n, i, "px")), l = t.getCTM && Gn(t), !v && "%" !== h || !dn[n] && !~n.indexOf("adius") ? (u[d ? "width" : "height"] = m + (g ? h : r), a = ~n.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode, l && (a = (t.ownerSVGElement || {}).parentNode), a && a !== an && a.appendChild || (a = an.body), (o = a._gsap) && v && o.width && d && o.time === pt.time ? re(c / o.width * m) : ((v || "%" === h) && (u.position = Nn(t, "position")), a === t && (u.position = "static"), a.appendChild(cn), s = cn[f], a.removeChild(cn), u.position = "absolute", d && v && ((o = te(a)).time = pt.time, o.width = a[f]), re(g ? s * c / m : s && c ? m / s * c : 0))) : (s = l ? t.getBBox()[d ? "width" : "height"] : t[f], re(v ? c / s * m : c / 100 * s)))
        }, Xn = function (e, t, n, i) {
            var r;
            return ln || Un(), t in yn && "transform" !== t && ~(t = yn[t]).indexOf(",") && (t = t.split(",")[0]), dn[t] && "transform" !== t ? (r = si(e, i), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : ai(Nn(e, On)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Zn[t] && Zn[t](e, t, n) || Nn(e, t) || ne(e, t) || ("opacity" === t ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? $n(e, t, r, n) + n : r
        }, qn = function (e, t, n, i) {
            if (!n || "none" === n) {
                var r = kn(t, e, 1), s = r && Nn(e, r, 1);
                s && s !== n ? (t = r, n = s) : "borderColor" === t && (n = Nn(e, "borderTopColor"))
            }
            var a, o, l, c, h, u, p, f, m, g, v, _ = new Qt(this._pt, e.style, t, 0, 1, Xt), y = 0, x = 0;
            if (_.b = n, _.e = i, n += "", "auto" === (i += "") && (e.style[t] = i, i = Nn(e, t) || i, e.style[t] = n), dt(a = [n, i]), i = a[1], l = (n = a[0]).match(D) || [], (i.match(D) || []).length) {
                for (; o = D.exec(i);) p = o[0], m = i.substring(y, o.index), h ? h = (h + 1) % 5 : "rgba(" !== m.substr(-5) && "hsla(" !== m.substr(-5) || (h = 1), p !== (u = l[x++] || "") && (c = parseFloat(u) || 0, v = u.substr((c + "").length), "=" === p.charAt(1) && (p = ae(c, p) + v), f = parseFloat(p), g = p.substr((f + "").length), y = D.lastIndex - g.length, g || (g = g || d.units[t] || v, y === i.length && (i += g, _.e += g)), v !== g && (c = $n(e, t, u, g) || 0), _._pt = {
                    _next: _._pt,
                    p: m || 1 === x ? m : ",",
                    s: c,
                    c: f - c,
                    m: h && h < 4 || "zIndex" === t ? Math.round : 0
                });
                _.c = y < i.length ? i.substring(y, i.length) : ""
            } else _.r = "display" === t && "none" === i ? En : Sn;
            return B.test(i) && (_.e = 0), this._pt = _, _
        }, Yn = {top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%"}, Kn = function (e) {
            var t = e.split(" "), n = t[0], i = t[1] || "50%";
            return "top" !== n && "bottom" !== n && "left" !== i && "right" !== i || (e = n, n = i, i = e), t[0] = Yn[n] || n, t[1] = Yn[i] || i, t.join(" ")
        }, Jn = function (e, t) {
            if (t.tween && t.tween._time === t.tween._dur) {
                var n, i, r, s = t.t, a = s.style, o = t.u, l = s._gsap;
                if ("all" === o || !0 === o) a.cssText = "", i = 1; else for (r = (o = o.split(",")).length; --r > -1;) n = o[r], dn[n] && (i = 1, n = "transformOrigin" === n ? On : In), Vn(s, n);
                i && (Vn(s, In), l && (l.svg && s.removeAttribute("transform"), si(s, 1), l.uncache = 1))
            }
        }, Zn = {
            clearProps: function (e, t, n, i, r) {
                if ("isFromStart" !== r.data) {
                    var s = e._pt = new Qt(e._pt, t, n, 0, 0, Jn);
                    return s.u = i, s.pr = -10, s.tween = r, e._props.push(n), 1
                }
            }
        }, Qn = [1, 0, 0, 1, 0, 0], ei = {}, ti = function (e) {
            return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
        }, ni = function (e) {
            var t = Nn(e, In);
            return ti(t) ? Qn : t.substr(7).match(O).map(re)
        }, ii = function (e, t) {
            var n, i, r, s, a = e._gsap || te(e), o = e.style, l = ni(e);
            return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Qn : l : (l !== Qn || e.offsetParent || e === on || a.svg || (r = o.display, o.display = "block", (n = e.parentNode) && e.offsetParent || (s = 1, i = e.nextSibling, on.appendChild(e)), l = ni(e), r ? o.display = r : Vn(e, "display"), s && (i ? n.insertBefore(e, i) : n ? n.appendChild(e) : on.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        }, ri = function (e, t, n, i, r, s) {
            var a, o, l, c = e._gsap, h = r || ii(e, !0), u = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0,
                f = c.yOffset || 0, m = h[0], g = h[1], v = h[2], _ = h[3], y = h[4], x = h[5], b = t.split(" "),
                w = parseFloat(b[0]) || 0, T = parseFloat(b[1]) || 0;
            n ? h !== Qn && (o = m * _ - g * v) && (l = w * (-g / o) + T * (m / o) - (m * x - g * y) / o, w = w * (_ / o) + T * (-v / o) + (v * x - _ * y) / o, T = l) : (w = (a = zn(e)).x + (~b[0].indexOf("%") ? w / 100 * a.width : w), T = a.y + (~(b[1] || b[0]).indexOf("%") ? T / 100 * a.height : T)), i || !1 !== i && c.smooth ? (y = w - u, x = T - d, c.xOffset = p + (y * m + x * v) - y, c.yOffset = f + (y * g + x * _) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = w, c.yOrigin = T, c.smooth = !!i, c.origin = t, c.originIsAbsolute = !!n, e.style[On] = "0px 0px", s && (Wn(s, c, "xOrigin", u, w), Wn(s, c, "yOrigin", d, T), Wn(s, c, "xOffset", p, c.xOffset), Wn(s, c, "yOffset", f, c.yOffset)), e.setAttribute("data-svg-origin", w + " " + T)
        }, si = function (e, t) {
            var n = e._gsap || new Mt(e);
            if ("x" in n && !t && !n.uncache) return n;
            var i, r, s, a, o, l, c, h, u, p, f, m, g, v, _, y, x, b, w, T, S, E, M, A, L, C, R, P, I, O, D, N, B = e.style,
                k = n.scaleX < 0, U = "px", F = "deg", H = Nn(e, On) || "0";
            return i = r = s = l = c = h = u = p = f = 0, a = o = 1, n.svg = !(!e.getCTM || !Gn(e)), v = ii(e, n.svg), n.svg && (A = (!n.uncache || "0px 0px" === H) && !t && e.getAttribute("data-svg-origin"), ri(e, A || H, !!A || n.originIsAbsolute, !1 !== n.smooth, v)), m = n.xOrigin || 0, g = n.yOrigin || 0, v !== Qn && (b = v[0], w = v[1], T = v[2], S = v[3], i = E = v[4], r = M = v[5], 6 === v.length ? (a = Math.sqrt(b * b + w * w), o = Math.sqrt(S * S + T * T), l = b || w ? mn(w, b) * pn : 0, (u = T || S ? mn(T, S) * pn + l : 0) && (o *= Math.abs(Math.cos(u * fn))), n.svg && (i -= m - (m * b + g * T), r -= g - (m * w + g * S))) : (N = v[6], O = v[7], R = v[8], P = v[9], I = v[10], D = v[11], i = v[12], r = v[13], s = v[14], c = (_ = mn(N, I)) * pn, _ && (A = E * (y = Math.cos(-_)) + R * (x = Math.sin(-_)), L = M * y + P * x, C = N * y + I * x, R = E * -x + R * y, P = M * -x + P * y, I = N * -x + I * y, D = O * -x + D * y, E = A, M = L, N = C), h = (_ = mn(-T, I)) * pn, _ && (y = Math.cos(-_), D = S * (x = Math.sin(-_)) + D * y, b = A = b * y - R * x, w = L = w * y - P * x, T = C = T * y - I * x), l = (_ = mn(w, b)) * pn, _ && (A = b * (y = Math.cos(_)) + w * (x = Math.sin(_)), L = E * y + M * x, w = w * y - b * x, M = M * y - E * x, b = A, E = L), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, h = 180 - h), a = re(Math.sqrt(b * b + w * w + T * T)), o = re(Math.sqrt(M * M + N * N)), _ = mn(E, M), u = Math.abs(_) > 2e-4 ? _ * pn : 0, f = D ? 1 / (D < 0 ? -D : D) : 0), n.svg && (A = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !ti(Nn(e, In)), A && e.setAttribute("transform", A))), Math.abs(u) > 90 && Math.abs(u) < 270 && (k ? (a *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, u += u <= 0 ? 180 : -180)), t = t || n.uncache, n.x = i - ((n.xPercent = i && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + U, n.y = r - ((n.yPercent = r && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + U, n.z = s + U, n.scaleX = re(a), n.scaleY = re(o), n.rotation = re(l) + F, n.rotationX = re(c) + F, n.rotationY = re(h) + F, n.skewX = u + F, n.skewY = p + F, n.transformPerspective = f + U, (n.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (B[On] = ai(H)), n.xOffset = n.yOffset = 0, n.force3D = d.force3D, n.renderTransform = n.svg ? pi : un ? di : li, n.uncache = 0, n
        }, ai = function (e) {
            return (e = e.split(" "))[0] + " " + e[1]
        }, oi = function (e, t, n) {
            var i = ze(t);
            return re(parseFloat(t) + parseFloat($n(e, "x", n + "px", i))) + i
        }, li = function (e, t) {
            t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, di(e, t)
        }, ci = "0deg", hi = "0px", ui = ") ", di = function (e, t) {
            var n = t || this, i = n.xPercent, r = n.yPercent, s = n.x, a = n.y, o = n.z, l = n.rotation, c = n.rotationY,
                h = n.rotationX, u = n.skewX, d = n.skewY, p = n.scaleX, f = n.scaleY, m = n.transformPerspective,
                g = n.force3D, v = n.target, _ = n.zOrigin, y = "", x = "auto" === g && e && 1 !== e || !0 === g;
            if (_ && (h !== ci || c !== ci)) {
                var b, w = parseFloat(c) * fn, T = Math.sin(w), S = Math.cos(w);
                w = parseFloat(h) * fn, b = Math.cos(w), s = oi(v, s, T * b * -_), a = oi(v, a, -Math.sin(w) * -_), o = oi(v, o, S * b * -_ + _)
            }
            m !== hi && (y += "perspective(" + m + ui), (i || r) && (y += "translate(" + i + "%, " + r + "%) "), (x || s !== hi || a !== hi || o !== hi) && (y += o !== hi || x ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + ui), l !== ci && (y += "rotate(" + l + ui), c !== ci && (y += "rotateY(" + c + ui), h !== ci && (y += "rotateX(" + h + ui), u === ci && d === ci || (y += "skew(" + u + ", " + d + ui), 1 === p && 1 === f || (y += "scale(" + p + ", " + f + ui), v.style[In] = y || "translate(0, 0)"
        }, pi = function (e, t) {
            var n, i, r, s, a, o = t || this, l = o.xPercent, c = o.yPercent, h = o.x, u = o.y, d = o.rotation, p = o.skewX,
                f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, _ = o.xOrigin, y = o.yOrigin, x = o.xOffset,
                b = o.yOffset, w = o.forceCSS, T = parseFloat(h), S = parseFloat(u);
            d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= fn, p *= fn, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -g, s = Math.cos(d - p) * g, p && (f *= fn, a = Math.tan(p - f), r *= a = Math.sqrt(1 + a * a), s *= a, f && (a = Math.tan(f), n *= a = Math.sqrt(1 + a * a), i *= a)), n = re(n), i = re(i), r = re(r), s = re(s)) : (n = m, s = g, i = r = 0), (T && !~(h + "").indexOf("px") || S && !~(u + "").indexOf("px")) && (T = $n(v, "x", h, "px"), S = $n(v, "y", u, "px")), (_ || y || x || b) && (T = re(T + _ - (_ * n + y * r) + x), S = re(S + y - (_ * i + y * s) + b)), (l || c) && (a = v.getBBox(), T = re(T + l / 100 * a.width), S = re(S + c / 100 * a.height)), a = "matrix(" + n + "," + i + "," + r + "," + s + "," + T + "," + S + ")", v.setAttribute("transform", a), w && (v.style[In] = a)
        }, fi = function (e, t, n, i, r) {
            var s, a, o = 360, l = w(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? pn : 1) - i, h = i + c + "deg";
            return l && ("short" === (s = r.split("_")[1]) && (c %= o) !== c % 180 && (c += c < 0 ? o : -360), "cw" === s && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === s && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)), e._pt = a = new Qt(e._pt, t, n, i, c, bn), a.e = h, a.u = "deg", e._props.push(n), a
        }, mi = function (e, t) {
            for (var n in t) e[n] = t[n];
            return e
        }, gi = function (e, t, n) {
            var i, r, s, a, o, l, c, h = mi({}, n._gsap), u = n.style;
            for (r in h.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), u[In] = t, i = si(n, 1), Vn(n, In), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[In], u[In] = t, i = si(n, 1), u[In] = s), dn) (s = h[r]) !== (a = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = ze(s) !== (c = ze(a)) ? $n(n, r, s, c) : parseFloat(s), l = parseFloat(a), e._pt = new Qt(e._pt, i, r, o, l - o, xn), e._pt.u = c || 0, e._props.push(r));
            mi(i, h)
        };
    ie("padding,margin,Width,Radius", (function (e, t) {
        var n = "Top", i = "Right", r = "Bottom", s = "Left",
            a = (t < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function (n) {
                return t < 2 ? e + n : "border" + n + e
            }));
        Zn[t > 1 ? "border" + e : e] = function (e, t, n, i, r) {
            var s, o;
            if (arguments.length < 4) return s = a.map((function (t) {
                return Xn(e, t, n)
            })), 5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
            s = (i + "").split(" "), o = {}, a.forEach((function (e, t) {
                return o[e] = s[t] = s[t] || s[(t - 1) / 2 | 0]
            })), e.init(t, o, r)
        }
    }));
    var vi, _i, yi, xi = {
        name: "css", register: Un, targetTest: function (e) {
            return e.style && e.nodeType
        }, init: function (e, t, n, i, r) {
            var s, a, o, l, c, h, u, p, f, m, g, v, _, y, x, b = this._props, T = e.style, S = n.vars.startAt;
            for (u in ln || Un(), t) if ("autoRound" !== u && (a = t[u], !Y[u] || !Ot(u, t, n, i, e, r))) if (c = typeof a, h = Zn[u], "function" === c && (c = typeof (a = a.call(n, i, e, r))), "string" === c && ~a.indexOf("random(") && (a = Ze(a)), h) h(this, e, u, a, n) && (x = 1); else if ("--" === u.substr(0, 2)) s = (getComputedStyle(e).getPropertyValue(u) + "").trim(), a += "", ht.lastIndex = 0, ht.test(s) || (p = ze(s), f = ze(a)), f ? p !== f && (s = $n(e, u, s, f) + f) : p && (a += p), this.add(T, "setProperty", s, a, i, r, 0, 0, u), b.push(u); else if ("undefined" !== c) {
                if (S && u in S ? (s = "function" == typeof S[u] ? S[u].call(n, i, e, r) : S[u], w(s) && ~s.indexOf("random(") && (s = Ze(s)), ze(s + "") || (s += d.units[u] || ze(Xn(e, u)) || ""), "=" === (s + "").charAt(1) && (s = Xn(e, u))) : s = Xn(e, u), l = parseFloat(s), (m = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)), o = parseFloat(a), u in yn && ("autoAlpha" === u && (1 === l && "hidden" === Xn(e, "visibility") && o && (l = 0), Wn(this, T, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== u && "transform" !== u && ~(u = yn[u]).indexOf(",") && (u = u.split(",")[0])), g = u in dn) if (v || ((_ = e._gsap).renderTransform && !t.parseTransform || si(e, t.parseTransform), y = !1 !== t.smoothOrigin && _.smooth, (v = this._pt = new Qt(this._pt, T, In, 0, 1, _.renderTransform, _, 0, -1)).dep = 1), "scale" === u) this._pt = new Qt(this._pt, _, "scaleY", _.scaleY, (m ? ae(_.scaleY, m + o) : o) - _.scaleY || 0), b.push("scaleY", u), u += "X"; else {
                    if ("transformOrigin" === u) {
                        a = Kn(a), _.svg ? ri(e, a, 0, y, 0, this) : ((f = parseFloat(a.split(" ")[2]) || 0) !== _.zOrigin && Wn(this, _, "zOrigin", _.zOrigin, f), Wn(this, T, u, ai(s), ai(a)));
                        continue
                    }
                    if ("svgOrigin" === u) {
                        ri(e, a, 1, y, 0, this);
                        continue
                    }
                    if (u in ei) {
                        fi(this, _, u, l, m ? ae(l, m + a) : a);
                        continue
                    }
                    if ("smoothOrigin" === u) {
                        Wn(this, _, "smooth", _.smooth, a);
                        continue
                    }
                    if ("force3D" === u) {
                        _[u] = a;
                        continue
                    }
                    if ("transform" === u) {
                        gi(this, a, e);
                        continue
                    }
                } else u in T || (u = kn(u) || u);
                if (g || (o || 0 === o) && (l || 0 === l) && !_n.test(a) && u in T) o || (o = 0), (p = (s + "").substr((l + "").length)) !== (f = ze(a) || (u in d.units ? d.units[u] : p)) && (l = $n(e, u, s, f)), this._pt = new Qt(this._pt, g ? _ : T, u, l, (m ? ae(l, m + o) : o) - l, g || "px" !== f && "zIndex" !== u || !1 === t.autoRound ? xn : Tn), this._pt.u = f || 0, p !== f && "%" !== f && (this._pt.b = s, this._pt.r = wn); else if (u in T) qn.call(this, e, u, s, m ? m + a : a); else {
                    if (!(u in e)) {
                        G(u, a);
                        continue
                    }
                    this.add(e, u, s || e[u], m ? m + a : a, i, r)
                }
                b.push(u)
            }
            x && Zt(this)
        }, get: Xn, aliases: yn, getSetter: function (e, t, n) {
            var i = yn[t];
            return i && i.indexOf(",") < 0 && (t = i), t in dn && t !== On && (e._gsap.x || Xn(e, "x")) ? n && hn === n ? "scale" === t ? Cn : Ln : (hn = n || {}) && ("scale" === t ? Rn : Pn) : e.style && !E(e.style[t]) ? Mn : ~t.indexOf("-") ? An : Wt(e, t)
        }, core: {_removeProperty: Vn, _getMatrix: ii}
    };
    rn.utils.checkPrefix = kn, yi = ie((vi = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (_i = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (e) {
        dn[e] = 1
    })), ie(_i, (function (e) {
        d.units[e] = "deg", ei[e] = 1
    })), yn[yi[13]] = vi + "," + _i, ie("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (e) {
        var t = e.split(":");
        yn[t[1]] = yi[t[0]]
    })), ie("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (e) {
        d.units[e] = "px"
    })), rn.registerPlugin(xi);
    var bi = rn.registerPlugin(xi) || rn;
    bi.core.Tween;
    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const wi = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
        Ti = Symbol(), Si = new Map;

    class Ei {
        constructor(e, t) {
            if (this._$cssResult$ = !0, t !== Ti) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
            this.cssText = e
        }

        get styleSheet() {
            let e = Si.get(this.cssText);
            return wi && void 0 === e && (Si.set(this.cssText, e = new CSSStyleSheet), e.replaceSync(this.cssText)), e
        }

        toString() {
            return this.cssText
        }
    }

    const Mi = (e, ...t) => {
            const n = 1 === e.length ? e[0] : t.reduce(((t, n, i) => t + (e => {
                if (!0 === e._$cssResult$) return e.cssText;
                if ("number" == typeof e) return e;
                throw Error("Value passed to 'css' function must be a 'css' function result: " + e + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
            })(n) + e[i + 1]), e[0]);
            return new Ei(n, Ti)
        }, Ai = wi ? e => e : e => e instanceof CSSStyleSheet ? (e => {
            let t = "";
            for (const n of e.cssRules) t += n.cssText;
            return (e => new Ei("string" == typeof e ? e : e + "", Ti))(t)
        })(e) : e
        /**
         * @license
         * Copyright 2017 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */;
    var Li;
    const Ci = window.trustedTypes, Ri = Ci ? Ci.emptyScript : "", Pi = window.reactiveElementPolyfillSupport, Ii = {
            toAttribute(e, t) {
                switch (t) {
                    case Boolean:
                        e = e ? Ri : null;
                        break;
                    case Object:
                    case Array:
                        e = null == e ? e : JSON.stringify(e)
                }
                return e
            }, fromAttribute(e, t) {
                let n = e;
                switch (t) {
                    case Boolean:
                        n = null !== e;
                        break;
                    case Number:
                        n = null === e ? null : Number(e);
                        break;
                    case Object:
                    case Array:
                        try {
                            n = JSON.parse(e)
                        } catch (e) {
                            n = null
                        }
                }
                return n
            }
        }, Oi = (e, t) => t !== e && (t == t || e == e),
        Di = {attribute: !0, type: String, converter: Ii, reflect: !1, hasChanged: Oi};

    class Ni extends HTMLElement {
        constructor() {
            super(), this._$Et = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Ei = null, this.o()
        }

        static addInitializer(e) {
            var t;
            null !== (t = this.l) && void 0 !== t || (this.l = []), this.l.push(e)
        }

        static get observedAttributes() {
            this.finalize();
            const e = [];
            return this.elementProperties.forEach(((t, n) => {
                const i = this._$Eh(n, t);
                void 0 !== i && (this._$Eu.set(i, n), e.push(i))
            })), e
        }

        static createProperty(e, t = Di) {
            if (t.state && (t.attribute = !1), this.finalize(), this.elementProperties.set(e, t), !t.noAccessor && !this.prototype.hasOwnProperty(e)) {
                const n = "symbol" == typeof e ? Symbol() : "__" + e, i = this.getPropertyDescriptor(e, n, t);
                void 0 !== i && Object.defineProperty(this.prototype, e, i)
            }
        }

        static getPropertyDescriptor(e, t, n) {
            return {
                get() {
                    return this[t]
                }, set(i) {
                    const r = this[e];
                    this[t] = i, this.requestUpdate(e, r, n)
                }, configurable: !0, enumerable: !0
            }
        }

        static getPropertyOptions(e) {
            return this.elementProperties.get(e) || Di
        }

        static finalize() {
            if (this.hasOwnProperty("finalized")) return !1;
            this.finalized = !0;
            const e = Object.getPrototypeOf(this);
            if (e.finalize(), this.elementProperties = new Map(e.elementProperties), this._$Eu = new Map, this.hasOwnProperty("properties")) {
                const e = this.properties, t = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
                for (const n of t) this.createProperty(n, e[n])
            }
            return this.elementStyles = this.finalizeStyles(this.styles), !0
        }

        static finalizeStyles(e) {
            const t = [];
            if (Array.isArray(e)) {
                const n = new Set(e.flat(1 / 0).reverse());
                for (const e of n) t.unshift(Ai(e))
            } else void 0 !== e && t.push(Ai(e));
            return t
        }

        static _$Eh(e, t) {
            const n = t.attribute;
            return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof e ? e.toLowerCase() : void 0
        }

        o() {
            var e;
            this._$Ep = new Promise((e => this.enableUpdating = e)), this._$AL = new Map, this._$Em(), this.requestUpdate(), null === (e = this.constructor.l) || void 0 === e || e.forEach((e => e(this)))
        }

        addController(e) {
            var t, n;
            (null !== (t = this._$Eg) && void 0 !== t ? t : this._$Eg = []).push(e), void 0 !== this.renderRoot && this.isConnected && (null === (n = e.hostConnected) || void 0 === n || n.call(e))
        }

        removeController(e) {
            var t;
            null === (t = this._$Eg) || void 0 === t || t.splice(this._$Eg.indexOf(e) >>> 0, 1)
        }

        _$Em() {
            this.constructor.elementProperties.forEach(((e, t) => {
                this.hasOwnProperty(t) && (this._$Et.set(t, this[t]), delete this[t])
            }))
        }

        createRenderRoot() {
            var e;
            const t = null !== (e = this.shadowRoot) && void 0 !== e ? e : this.attachShadow(this.constructor.shadowRootOptions);
            return ((e, t) => {
                wi ? e.adoptedStyleSheets = t.map((e => e instanceof CSSStyleSheet ? e : e.styleSheet)) : t.forEach((t => {
                    const n = document.createElement("style"), i = window.litNonce;
                    void 0 !== i && n.setAttribute("nonce", i), n.textContent = t.cssText, e.appendChild(n)
                }))
            })(t, this.constructor.elementStyles), t
        }

        connectedCallback() {
            var e;
            void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (e = this._$Eg) || void 0 === e || e.forEach((e => {
                var t;
                return null === (t = e.hostConnected) || void 0 === t ? void 0 : t.call(e)
            }))
        }

        enableUpdating(e) {
        }

        disconnectedCallback() {
            var e;
            null === (e = this._$Eg) || void 0 === e || e.forEach((e => {
                var t;
                return null === (t = e.hostDisconnected) || void 0 === t ? void 0 : t.call(e)
            }))
        }

        attributeChangedCallback(e, t, n) {
            this._$AK(e, n)
        }

        _$ES(e, t, n = Di) {
            var i, r;
            const s = this.constructor._$Eh(e, n);
            if (void 0 !== s && !0 === n.reflect) {
                const a = (null !== (r = null === (i = n.converter) || void 0 === i ? void 0 : i.toAttribute) && void 0 !== r ? r : Ii.toAttribute)(t, n.type);
                this._$Ei = e, null == a ? this.removeAttribute(s) : this.setAttribute(s, a), this._$Ei = null
            }
        }

        _$AK(e, t) {
            var n, i, r;
            const s = this.constructor, a = s._$Eu.get(e);
            if (void 0 !== a && this._$Ei !== a) {
                const e = s.getPropertyOptions(a), o = e.converter,
                    l = null !== (r = null !== (i = null === (n = o) || void 0 === n ? void 0 : n.fromAttribute) && void 0 !== i ? i : "function" == typeof o ? o : null) && void 0 !== r ? r : Ii.fromAttribute;
                this._$Ei = a, this[a] = l(t, e.type), this._$Ei = null
            }
        }

        requestUpdate(e, t, n) {
            let i = !0;
            void 0 !== e && (((n = n || this.constructor.getPropertyOptions(e)).hasChanged || Oi)(this[e], t) ? (this._$AL.has(e) || this._$AL.set(e, t), !0 === n.reflect && this._$Ei !== e && (void 0 === this._$E_ && (this._$E_ = new Map), this._$E_.set(e, n))) : i = !1), !this.isUpdatePending && i && (this._$Ep = this._$EC())
        }

        async _$EC() {
            this.isUpdatePending = !0;
            try {
                await this._$Ep
            } catch (e) {
                Promise.reject(e)
            }
            const e = this.scheduleUpdate();
            return null != e && await e, !this.isUpdatePending
        }

        scheduleUpdate() {
            return this.performUpdate()
        }

        performUpdate() {
            var e;
            if (!this.isUpdatePending) return;
            this.hasUpdated, this._$Et && (this._$Et.forEach(((e, t) => this[t] = e)), this._$Et = void 0);
            let t = !1;
            const n = this._$AL;
            try {
                t = this.shouldUpdate(n), t ? (this.willUpdate(n), null === (e = this._$Eg) || void 0 === e || e.forEach((e => {
                    var t;
                    return null === (t = e.hostUpdate) || void 0 === t ? void 0 : t.call(e)
                })), this.update(n)) : this._$EU()
            } catch (e) {
                throw t = !1, this._$EU(), e
            }
            t && this._$AE(n)
        }

        willUpdate(e) {
        }

        _$AE(e) {
            var t;
            null === (t = this._$Eg) || void 0 === t || t.forEach((e => {
                var t;
                return null === (t = e.hostUpdated) || void 0 === t ? void 0 : t.call(e)
            })), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e)
        }

        _$EU() {
            this._$AL = new Map, this.isUpdatePending = !1
        }

        get updateComplete() {
            return this.getUpdateComplete()
        }

        getUpdateComplete() {
            return this._$Ep
        }

        shouldUpdate(e) {
            return !0
        }

        update(e) {
            void 0 !== this._$E_ && (this._$E_.forEach(((e, t) => this._$ES(t, this[t], e))), this._$E_ = void 0), this._$EU()
        }

        updated(e) {
        }

        firstUpdated(e) {
        }
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var Bi;
    Ni.finalized = !0, Ni.elementProperties = new Map, Ni.elementStyles = [], Ni.shadowRootOptions = {mode: "open"}, null == Pi || Pi({ReactiveElement: Ni}), (null !== (Li = globalThis.reactiveElementVersions) && void 0 !== Li ? Li : globalThis.reactiveElementVersions = []).push("1.2.0");
    const ki = globalThis.trustedTypes, Ui = ki ? ki.createPolicy("lit-html", {createHTML: e => e}) : void 0,
        Fi = `lit$${(Math.random() + "").slice(9)}$`, Hi = "?" + Fi, zi = `<${Hi}>`, Gi = document,
        Vi = (e = "") => Gi.createComment(e), Wi = e => null === e || "object" != typeof e && "function" != typeof e,
        ji = Array.isArray, $i = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Xi = /-->/g, qi = />/g,
        Yi = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g, Ki = /'/g,
        Ji = /"/g, Zi = /^(?:script|style|textarea)$/i,
        Qi = (e => (t, ...n) => ({_$litType$: e, strings: t, values: n}))(1), er = Symbol.for("lit-noChange"),
        tr = Symbol.for("lit-nothing"), nr = new WeakMap, ir = Gi.createTreeWalker(Gi, 129, null, !1), rr = (e, t) => {
            const n = e.length - 1, i = [];
            let r, s = 2 === t ? "<svg>" : "", a = $i;
            for (let t = 0; t < n; t++) {
                const n = e[t];
                let o, l, c = -1, h = 0;
                for (; h < n.length && (a.lastIndex = h, l = a.exec(n), null !== l);) h = a.lastIndex, a === $i ? "!--" === l[1] ? a = Xi : void 0 !== l[1] ? a = qi : void 0 !== l[2] ? (Zi.test(l[2]) && (r = RegExp("</" + l[2], "g")), a = Yi) : void 0 !== l[3] && (a = Yi) : a === Yi ? ">" === l[0] ? (a = null != r ? r : $i, c = -1) : void 0 === l[1] ? c = -2 : (c = a.lastIndex - l[2].length, o = l[1], a = void 0 === l[3] ? Yi : '"' === l[3] ? Ji : Ki) : a === Ji || a === Ki ? a = Yi : a === Xi || a === qi ? a = $i : (a = Yi, r = void 0);
                const u = a === Yi && e[t + 1].startsWith("/>") ? " " : "";
                s += a === $i ? n + zi : c >= 0 ? (i.push(o), n.slice(0, c) + "$lit$" + n.slice(c) + Fi + u) : n + Fi + (-2 === c ? (i.push(void 0), t) : u)
            }
            const o = s + (e[n] || "<?>") + (2 === t ? "</svg>" : "");
            if (!Array.isArray(e) || !e.hasOwnProperty("raw")) throw Error("invalid template strings array");
            return [void 0 !== Ui ? Ui.createHTML(o) : o, i]
        };

    class sr {
        constructor({strings: e, _$litType$: t}, n) {
            let i;
            this.parts = [];
            let r = 0, s = 0;
            const a = e.length - 1, o = this.parts, [l, c] = rr(e, t);
            if (this.el = sr.createElement(l, n), ir.currentNode = this.el.content, 2 === t) {
                const e = this.el.content, t = e.firstChild;
                t.remove(), e.append(...t.childNodes)
            }
            for (; null !== (i = ir.nextNode()) && o.length < a;) {
                if (1 === i.nodeType) {
                    if (i.hasAttributes()) {
                        const e = [];
                        for (const t of i.getAttributeNames()) if (t.endsWith("$lit$") || t.startsWith(Fi)) {
                            const n = c[s++];
                            if (e.push(t), void 0 !== n) {
                                const e = i.getAttribute(n.toLowerCase() + "$lit$").split(Fi),
                                    t = /([.?@])?(.*)/.exec(n);
                                o.push({
                                    type: 1,
                                    index: r,
                                    name: t[2],
                                    strings: e,
                                    ctor: "." === t[1] ? hr : "?" === t[1] ? dr : "@" === t[1] ? pr : cr
                                })
                            } else o.push({type: 6, index: r})
                        }
                        for (const t of e) i.removeAttribute(t)
                    }
                    if (Zi.test(i.tagName)) {
                        const e = i.textContent.split(Fi), t = e.length - 1;
                        if (t > 0) {
                            i.textContent = ki ? ki.emptyScript : "";
                            for (let n = 0; n < t; n++) i.append(e[n], Vi()), ir.nextNode(), o.push({
                                type: 2,
                                index: ++r
                            });
                            i.append(e[t], Vi())
                        }
                    }
                } else if (8 === i.nodeType) if (i.data === Hi) o.push({type: 2, index: r}); else {
                    let e = -1;
                    for (; -1 !== (e = i.data.indexOf(Fi, e + 1));) o.push({type: 7, index: r}), e += Fi.length - 1
                }
                r++
            }
        }

        static createElement(e, t) {
            const n = Gi.createElement("template");
            return n.innerHTML = e, n
        }
    }

    function ar(e, t, n = e, i) {
        var r, s, a, o;
        if (t === er) return t;
        let l = void 0 !== i ? null === (r = n._$Cl) || void 0 === r ? void 0 : r[i] : n._$Cu;
        const c = Wi(t) ? void 0 : t._$litDirective$;
        return (null == l ? void 0 : l.constructor) !== c && (null === (s = null == l ? void 0 : l._$AO) || void 0 === s || s.call(l, !1), void 0 === c ? l = void 0 : (l = new c(e), l._$AT(e, n, i)), void 0 !== i ? (null !== (a = (o = n)._$Cl) && void 0 !== a ? a : o._$Cl = [])[i] = l : n._$Cu = l), void 0 !== l && (t = ar(e, l._$AS(e, t.values), l, i)), t
    }

    class or {
        constructor(e, t) {
            this.v = [], this._$AN = void 0, this._$AD = e, this._$AM = t
        }

        get parentNode() {
            return this._$AM.parentNode
        }

        get _$AU() {
            return this._$AM._$AU
        }

        p(e) {
            var t;
            const {el: {content: n}, parts: i} = this._$AD,
                r = (null !== (t = null == e ? void 0 : e.creationScope) && void 0 !== t ? t : Gi).importNode(n, !0);
            ir.currentNode = r;
            let s = ir.nextNode(), a = 0, o = 0, l = i[0];
            for (; void 0 !== l;) {
                if (a === l.index) {
                    let t;
                    2 === l.type ? t = new lr(s, s.nextSibling, this, e) : 1 === l.type ? t = new l.ctor(s, l.name, l.strings, this, e) : 6 === l.type && (t = new fr(s, this, e)), this.v.push(t), l = i[++o]
                }
                a !== (null == l ? void 0 : l.index) && (s = ir.nextNode(), a++)
            }
            return r
        }

        m(e) {
            let t = 0;
            for (const n of this.v) void 0 !== n && (void 0 !== n.strings ? (n._$AI(e, n, t), t += n.strings.length - 2) : n._$AI(e[t])), t++
        }
    }

    class lr {
        constructor(e, t, n, i) {
            var r;
            this.type = 2, this._$AH = tr, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = n, this.options = i, this._$Cg = null === (r = null == i ? void 0 : i.isConnected) || void 0 === r || r
        }

        get _$AU() {
            var e, t;
            return null !== (t = null === (e = this._$AM) || void 0 === e ? void 0 : e._$AU) && void 0 !== t ? t : this._$Cg
        }

        get parentNode() {
            let e = this._$AA.parentNode;
            const t = this._$AM;
            return void 0 !== t && 11 === e.nodeType && (e = t.parentNode), e
        }

        get startNode() {
            return this._$AA
        }

        get endNode() {
            return this._$AB
        }

        _$AI(e, t = this) {
            e = ar(this, e, t), Wi(e) ? e === tr || null == e || "" === e ? (this._$AH !== tr && this._$AR(), this._$AH = tr) : e !== this._$AH && e !== er && this.$(e) : void 0 !== e._$litType$ ? this.T(e) : void 0 !== e.nodeType ? this.S(e) : (e => {
                var t;
                return ji(e) || "function" == typeof (null === (t = e) || void 0 === t ? void 0 : t[Symbol.iterator])
            })(e) ? this.A(e) : this.$(e)
        }

        M(e, t = this._$AB) {
            return this._$AA.parentNode.insertBefore(e, t)
        }

        S(e) {
            this._$AH !== e && (this._$AR(), this._$AH = this.M(e))
        }

        $(e) {
            this._$AH !== tr && Wi(this._$AH) ? this._$AA.nextSibling.data = e : this.S(Gi.createTextNode(e)), this._$AH = e
        }

        T(e) {
            var t;
            const {values: n, _$litType$: i} = e,
                r = "number" == typeof i ? this._$AC(e) : (void 0 === i.el && (i.el = sr.createElement(i.h, this.options)), i);
            if ((null === (t = this._$AH) || void 0 === t ? void 0 : t._$AD) === r) this._$AH.m(n); else {
                const e = new or(r, this), t = e.p(this.options);
                e.m(n), this.S(t), this._$AH = e
            }
        }

        _$AC(e) {
            let t = nr.get(e.strings);
            return void 0 === t && nr.set(e.strings, t = new sr(e)), t
        }

        A(e) {
            ji(this._$AH) || (this._$AH = [], this._$AR());
            const t = this._$AH;
            let n, i = 0;
            for (const r of e) i === t.length ? t.push(n = new lr(this.M(Vi()), this.M(Vi()), this, this.options)) : n = t[i], n._$AI(r), i++;
            i < t.length && (this._$AR(n && n._$AB.nextSibling, i), t.length = i)
        }

        _$AR(e = this._$AA.nextSibling, t) {
            var n;
            for (null === (n = this._$AP) || void 0 === n || n.call(this, !1, !0, t); e && e !== this._$AB;) {
                const t = e.nextSibling;
                e.remove(), e = t
            }
        }

        setConnected(e) {
            var t;
            void 0 === this._$AM && (this._$Cg = e, null === (t = this._$AP) || void 0 === t || t.call(this, e))
        }
    }

    class cr {
        constructor(e, t, n, i, r) {
            this.type = 1, this._$AH = tr, this._$AN = void 0, this.element = e, this.name = t, this._$AM = i, this.options = r, n.length > 2 || "" !== n[0] || "" !== n[1] ? (this._$AH = Array(n.length - 1).fill(new String), this.strings = n) : this._$AH = tr
        }

        get tagName() {
            return this.element.tagName
        }

        get _$AU() {
            return this._$AM._$AU
        }

        _$AI(e, t = this, n, i) {
            const r = this.strings;
            let s = !1;
            if (void 0 === r) e = ar(this, e, t, 0), s = !Wi(e) || e !== this._$AH && e !== er, s && (this._$AH = e); else {
                const i = e;
                let a, o;
                for (e = r[0], a = 0; a < r.length - 1; a++) o = ar(this, i[n + a], t, a), o === er && (o = this._$AH[a]), s || (s = !Wi(o) || o !== this._$AH[a]), o === tr ? e = tr : e !== tr && (e += (null != o ? o : "") + r[a + 1]), this._$AH[a] = o
            }
            s && !i && this.k(e)
        }

        k(e) {
            e === tr ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != e ? e : "")
        }
    }

    class hr extends cr {
        constructor() {
            super(...arguments), this.type = 3
        }

        k(e) {
            this.element[this.name] = e === tr ? void 0 : e
        }
    }

    const ur = ki ? ki.emptyScript : "";

    class dr extends cr {
        constructor() {
            super(...arguments), this.type = 4
        }

        k(e) {
            e && e !== tr ? this.element.setAttribute(this.name, ur) : this.element.removeAttribute(this.name)
        }
    }

    class pr extends cr {
        constructor(e, t, n, i, r) {
            super(e, t, n, i, r), this.type = 5
        }

        _$AI(e, t = this) {
            var n;
            if ((e = null !== (n = ar(this, e, t, 0)) && void 0 !== n ? n : tr) === er) return;
            const i = this._$AH,
                r = e === tr && i !== tr || e.capture !== i.capture || e.once !== i.once || e.passive !== i.passive,
                s = e !== tr && (i === tr || r);
            r && this.element.removeEventListener(this.name, this, i), s && this.element.addEventListener(this.name, this, e), this._$AH = e
        }

        handleEvent(e) {
            var t, n;
            "function" == typeof this._$AH ? this._$AH.call(null !== (n = null === (t = this.options) || void 0 === t ? void 0 : t.host) && void 0 !== n ? n : this.element, e) : this._$AH.handleEvent(e)
        }
    }

    class fr {
        constructor(e, t, n) {
            this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = n
        }

        get _$AU() {
            return this._$AM._$AU
        }

        _$AI(e) {
            ar(this, e)
        }
    }

    const mr = window.litHtmlPolyfillSupport;
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var gr, vr;
    null == mr || mr(sr, lr), (null !== (Bi = globalThis.litHtmlVersions) && void 0 !== Bi ? Bi : globalThis.litHtmlVersions = []).push("2.1.1");

    class _r extends Ni {
        constructor() {
            super(...arguments), this.renderOptions = {host: this}, this._$Dt = void 0
        }

        createRenderRoot() {
            var e, t;
            const n = super.createRenderRoot();
            return null !== (e = (t = this.renderOptions).renderBefore) && void 0 !== e || (t.renderBefore = n.firstChild), n
        }

        update(e) {
            const t = this.render();
            this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Dt = ((e, t, n) => {
                var i, r;
                const s = null !== (i = null == n ? void 0 : n.renderBefore) && void 0 !== i ? i : t;
                let a = s._$litPart$;
                if (void 0 === a) {
                    const e = null !== (r = null == n ? void 0 : n.renderBefore) && void 0 !== r ? r : null;
                    s._$litPart$ = a = new lr(t.insertBefore(Vi(), e), e, void 0, null != n ? n : {})
                }
                return a._$AI(e), a
            })(t, this.renderRoot, this.renderOptions)
        }

        connectedCallback() {
            var e;
            super.connectedCallback(), null === (e = this._$Dt) || void 0 === e || e.setConnected(!0)
        }

        disconnectedCallback() {
            var e;
            super.disconnectedCallback(), null === (e = this._$Dt) || void 0 === e || e.setConnected(!1)
        }

        render() {
            return er
        }
    }

    _r.finalized = !0, _r._$litElement$ = !0, null === (gr = globalThis.litElementHydrateSupport) || void 0 === gr || gr.call(globalThis, {LitElement: _r});
    const yr = globalThis.litElementPolyfillSupport;
    null == yr || yr({LitElement: _r}), (null !== (vr = globalThis.litElementVersions) && void 0 !== vr ? vr : globalThis.litElementVersions = []).push("3.1.1");
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const xr = e => t => "function" == typeof t ? ((e, t) => (window.customElements.define(e, t), t))(e, t) : ((e, t) => {
            const {kind: n, elements: i} = t;
            return {
                kind: n, elements: i, finisher(t) {
                    window.customElements.define(e, t)
                }
            }
        })(e, t)
        /**
         * @license
         * Copyright 2017 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */, br = (e, t) => "method" === t.kind && t.descriptor && !("value" in t.descriptor) ? {
            ...t, finisher(n) {
                n.createProperty(t.key, e)
            }
        } : {
            kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: t.key, initializer() {
                "function" == typeof t.initializer && (this[t.key] = t.initializer.call(this))
            }, finisher(n) {
                n.createProperty(t.key, e)
            }
        };

    function wr(e) {
        return (t, n) => void 0 !== n ? ((e, t, n) => {
            t.constructor.createProperty(n, e)
        })(e, t, n) : br(e, t)
        /**
         * @license
         * Copyright 2017 Google LLC
         * SPDX-License-Identifier: BSD-3-Clause
         */
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    function Tr(e, t) {
        return (({finisher: e, descriptor: t}) => (n, i) => {
            var r;
            if (void 0 === i) {
                const i = null !== (r = n.originalKey) && void 0 !== r ? r : n.key,
                    s = null != t ? {kind: "method", placement: "prototype", key: i, descriptor: t(n.key)} : {
                        ...n,
                        key: i
                    };
                return null != e && (s.finisher = function (t) {
                    e(t, i)
                }), s
            }
            {
                const r = n.constructor;
                void 0 !== t && Object.defineProperty(n, i, t(i)), null == e || e(r, i)
            }
        })({
            descriptor: n => {
                const i = {
                    get() {
                        var t, n;
                        return null !== (n = null === (t = this.renderRoot) || void 0 === t ? void 0 : t.querySelector(e)) && void 0 !== n ? n : null
                    }, enumerable: !0, configurable: !0
                };
                if (t) {
                    const t = "symbol" == typeof n ? Symbol() : "__" + n;
                    i.get = function () {
                        var n, i;
                        return void 0 === this[t] && (this[t] = null !== (i = null === (n = this.renderRoot) || void 0 === n ? void 0 : n.querySelector(e)) && void 0 !== i ? i : null), this[t]
                    }
                }
                return i
            }
        })
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var Sr;
    null === (Sr = window.HTMLSlotElement) || void 0 === Sr || Sr.prototype.assignedElements;
    const Er = Mi`
  :host {
    display: block;
  }

  :host[hidden] {
    display: none;
  }
`;
    var Mr;
    !function (e) {
        e.PLAY_STATE_CHANGE = "playstatechange", e.VTT_UPDATE = "vttupdate", e.STOPPED = "stopped"
    }(Mr || (Mr = {}));
    let Ar = class extends _r {
        constructor() {
            super(...arguments), this.paused = !0, this.started = !1, this.audioPath = "", this.audioVttPath = ""
        }

        updated(e) {
            super.updated(e), void 0 !== e.get("paused") && this.dispatchEvent(new CustomEvent(Mr.PLAY_STATE_CHANGE)), void 0 !== e.get("started") && (this.started || (this.setProgress(0), this.dispatchEvent(new CustomEvent(Mr.STOPPED))))
        }

        onTimeUpdate(e) {
            const {currentTime: t, duration: n} = e.target;
            this.setProgress(t / n)
        }

        onPlay() {
            this.paused = !1, this.started = !0
        }

        onPause() {
            this.paused = !0
        }

        onEnded() {
            this.started = !1, this.paused = !0
        }

        async play() {
            await this.audio.play(), this.vttUpdate()
        }

        pause() {
            this.audio.pause()
        }

        async stop() {
            await this.pause(), this.audio.currentTime = 0, this.started = !1
        }

        setProgress(e) {
            bi.to(this.progressBar, {progress: e})
        }

        vttUpdate() {
            var e;
            const t = this.track.track;
            if (!(null === (e = t.activeCues) || void 0 === e ? void 0 : e.length)) return;
            const n = t.activeCues[0].text, i = new CustomEvent(Mr.VTT_UPDATE, {detail: {activeCue: n}});
            this.dispatchEvent(i)
        }

        render() {
            return Qi`
      <div class="toggle-button">
        <pk-progress-indicator-rounded id="progress">
        </pk-progress-indicator-rounded>
        <div>
          <slot name="play-button"></slot>
        </div>
      </div>

      <audio
        @play="${this.onPlay}"
        @pause="${this.onPause}"
        @ended="${this.onEnded}"
        @timeupdate="${this.onTimeUpdate}"
        preload="none"
        hidden
      >
        <source type="audio/mpeg" src="${this.audioPath}" />
        <track
          label="Transcript"
          kind="captions"
          srclang="en"
          src="${this.audioVttPath}"
          @cuechange="${this.vttUpdate}"
          default
        />
      </audio>
    `
        }

        get isPaused() {
            return this.audio.paused
        }
    };
    Ar.styles = [Er, Mi`
      :host {
        position: relative;
      }
      
      .toggle-button {
        display: grid;
        grid-template-areas: 'cell';
        align-items: center;
        justify-content: center;
      }
      
      .toggle-button > * {
        grid-area: cell;
      }

      pk-progress-indicator-rounded {
        width: 2.75rem;
        height: 2.75rem;
      }
    `], e([Tr("audio")], Ar.prototype, "audio", void 0), e([Tr("track")], Ar.prototype, "track", void 0), e([Tr("#progress")], Ar.prototype, "progressBar", void 0), e([wr({type: Boolean})], Ar.prototype, "paused", void 0), e([wr({type: Boolean})], Ar.prototype, "started", void 0), e([wr({type: String})], Ar.prototype, "audioPath", void 0), e([wr({type: String})], Ar.prototype, "audioVttPath", void 0), Ar = e([xr("pk-audio-player")], Ar);
    let Lr = class extends _r {
        constructor() {
            super(...arguments), this.progress = 0
        }

        render() {
            return Qi`
      <svg
        class="progress-indicator"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        stroke="currentColor"
        aria-hidden="true"
        fill="none"
        part="svg"
        style="--progress-bar-ratio: ${this.progress}"
      >
        <circle
          cx="12"
          cy="12"
          r="11"
          stroke-width="2"
          transform="rotate(-90 12 12)"
        />
      </svg>
    `
        }
    };
    Lr.styles = [Er, Mi`
      :host {
        /* Bezier length of the SVG Circle stroke. */
        --progress-bar-bezier-length: 69px;
        --progress-bar-ratio: 0;
        height: 100%;
        width: 100%;
      }

      .progress-indicator {
        --progress-modifier: calc(1 - var(--progress-bar-ratio));
        color: var(--color-sunset-orange);
        height: 100%;
        left: 0;
        position: absolute;
        stroke-dasharray: var(--progress-bar-bezier-length), var(--progress-bar-bezier-length);
        stroke-dashoffset: calc(var(--progress-bar-bezier-length) * var(--progress-modifier));
        top: 0;
        width: 100%;
      }
    `], e([wr({type: Number})], Lr.prototype, "progress", void 0), Lr = e([xr("pk-progress-indicator-rounded")], Lr);
    var Cr = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var i = t[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, n, i) {
            return n && e(t.prototype, n), i && e(t, i), t
        }
    }();

    function Rr(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    !function () {
        if ("undefined" != typeof window) {
            var e = Array.prototype.slice, t = Element.prototype.matches || Element.prototype.msMatchesSelector,
                n = ["a[href]", "area[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "details", "summary", "iframe", "object", "embed", "[contenteditable]"].join(","),
                i = function () {
                    function i(e, t) {
                        Rr(this, i), this._inertManager = t, this._rootElement = e, this._managedNodes = new Set, this._rootElement.hasAttribute("aria-hidden") ? this._savedAriaHidden = this._rootElement.getAttribute("aria-hidden") : this._savedAriaHidden = null, this._rootElement.setAttribute("aria-hidden", "true"), this._makeSubtreeUnfocusable(this._rootElement), this._observer = new MutationObserver(this._onMutation.bind(this)), this._observer.observe(this._rootElement, {
                            attributes: !0,
                            childList: !0,
                            subtree: !0
                        })
                    }

                    return Cr(i, [{
                        key: "destructor", value: function () {
                            this._observer.disconnect(), this._rootElement && (null !== this._savedAriaHidden ? this._rootElement.setAttribute("aria-hidden", this._savedAriaHidden) : this._rootElement.removeAttribute("aria-hidden")), this._managedNodes.forEach((function (e) {
                                this._unmanageNode(e.node)
                            }), this), this._observer = null, this._rootElement = null, this._managedNodes = null, this._inertManager = null
                        }
                    }, {
                        key: "_makeSubtreeUnfocusable", value: function (e) {
                            var t = this;
                            o(e, (function (e) {
                                return t._visitNode(e)
                            }));
                            var n = document.activeElement;
                            if (!document.body.contains(e)) {
                                for (var i = e, r = void 0; i;) {
                                    if (i.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                                        r = i;
                                        break
                                    }
                                    i = i.parentNode
                                }
                                r && (n = r.activeElement)
                            }
                            e.contains(n) && (n.blur(), n === document.activeElement && document.body.focus())
                        }
                    }, {
                        key: "_visitNode", value: function (e) {
                            if (e.nodeType === Node.ELEMENT_NODE) {
                                var i = e;
                                i !== this._rootElement && i.hasAttribute("inert") && this._adoptInertRoot(i), (t.call(i, n) || i.hasAttribute("tabindex")) && this._manageNode(i)
                            }
                        }
                    }, {
                        key: "_manageNode", value: function (e) {
                            var t = this._inertManager.register(e, this);
                            this._managedNodes.add(t)
                        }
                    }, {
                        key: "_unmanageNode", value: function (e) {
                            var t = this._inertManager.deregister(e, this);
                            t && this._managedNodes.delete(t)
                        }
                    }, {
                        key: "_unmanageSubtree", value: function (e) {
                            var t = this;
                            o(e, (function (e) {
                                return t._unmanageNode(e)
                            }))
                        }
                    }, {
                        key: "_adoptInertRoot", value: function (e) {
                            var t = this._inertManager.getInertRoot(e);
                            t || (this._inertManager.setInert(e, !0), t = this._inertManager.getInertRoot(e)), t.managedNodes.forEach((function (e) {
                                this._manageNode(e.node)
                            }), this)
                        }
                    }, {
                        key: "_onMutation", value: function (t, n) {
                            t.forEach((function (t) {
                                var n = t.target;
                                if ("childList" === t.type) e.call(t.addedNodes).forEach((function (e) {
                                    this._makeSubtreeUnfocusable(e)
                                }), this), e.call(t.removedNodes).forEach((function (e) {
                                    this._unmanageSubtree(e)
                                }), this); else if ("attributes" === t.type) if ("tabindex" === t.attributeName) this._manageNode(n); else if (n !== this._rootElement && "inert" === t.attributeName && n.hasAttribute("inert")) {
                                    this._adoptInertRoot(n);
                                    var i = this._inertManager.getInertRoot(n);
                                    this._managedNodes.forEach((function (e) {
                                        n.contains(e.node) && i._manageNode(e.node)
                                    }))
                                }
                            }), this)
                        }
                    }, {
                        key: "managedNodes", get: function () {
                            return new Set(this._managedNodes)
                        }
                    }, {
                        key: "hasSavedAriaHidden", get: function () {
                            return null !== this._savedAriaHidden
                        }
                    }, {
                        key: "savedAriaHidden", set: function (e) {
                            this._savedAriaHidden = e
                        }, get: function () {
                            return this._savedAriaHidden
                        }
                    }]), i
                }(), r = function () {
                    function e(t, n) {
                        Rr(this, e), this._node = t, this._overrodeFocusMethod = !1, this._inertRoots = new Set([n]), this._savedTabIndex = null, this._destroyed = !1, this.ensureUntabbable()
                    }

                    return Cr(e, [{
                        key: "destructor", value: function () {
                            if (this._throwIfDestroyed(), this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                                var e = this._node;
                                null !== this._savedTabIndex ? e.setAttribute("tabindex", this._savedTabIndex) : e.removeAttribute("tabindex"), this._overrodeFocusMethod && delete e.focus
                            }
                            this._node = null, this._inertRoots = null, this._destroyed = !0
                        }
                    }, {
                        key: "_throwIfDestroyed", value: function () {
                            if (this.destroyed) throw new Error("Trying to access destroyed InertNode")
                        }
                    }, {
                        key: "ensureUntabbable", value: function () {
                            if (this.node.nodeType === Node.ELEMENT_NODE) {
                                var e = this.node;
                                if (t.call(e, n)) {
                                    if (-1 === e.tabIndex && this.hasSavedTabIndex) return;
                                    e.hasAttribute("tabindex") && (this._savedTabIndex = e.tabIndex), e.setAttribute("tabindex", "-1"), e.nodeType === Node.ELEMENT_NODE && (e.focus = function () {
                                    }, this._overrodeFocusMethod = !0)
                                } else e.hasAttribute("tabindex") && (this._savedTabIndex = e.tabIndex, e.removeAttribute("tabindex"))
                            }
                        }
                    }, {
                        key: "addInertRoot", value: function (e) {
                            this._throwIfDestroyed(), this._inertRoots.add(e)
                        }
                    }, {
                        key: "removeInertRoot", value: function (e) {
                            this._throwIfDestroyed(), this._inertRoots.delete(e), 0 === this._inertRoots.size && this.destructor()
                        }
                    }, {
                        key: "destroyed", get: function () {
                            return this._destroyed
                        }
                    }, {
                        key: "hasSavedTabIndex", get: function () {
                            return null !== this._savedTabIndex
                        }
                    }, {
                        key: "node", get: function () {
                            return this._throwIfDestroyed(), this._node
                        }
                    }, {
                        key: "savedTabIndex", set: function (e) {
                            this._throwIfDestroyed(), this._savedTabIndex = e
                        }, get: function () {
                            return this._throwIfDestroyed(), this._savedTabIndex
                        }
                    }]), e
                }(), s = function () {
                    function n(e) {
                        if (Rr(this, n), !e) throw new Error("Missing required argument; InertManager needs to wrap a document.");
                        this._document = e, this._managedNodes = new Map, this._inertRoots = new Map, this._observer = new MutationObserver(this._watchForInert.bind(this)), l(e.head || e.body || e.documentElement), "loading" === e.readyState ? e.addEventListener("DOMContentLoaded", this._onDocumentLoaded.bind(this)) : this._onDocumentLoaded()
                    }

                    return Cr(n, [{
                        key: "setInert", value: function (e, t) {
                            if (t) {
                                if (this._inertRoots.has(e)) return;
                                var n = new i(e, this);
                                if (e.setAttribute("inert", ""), this._inertRoots.set(e, n), !this._document.body.contains(e)) for (var r = e.parentNode; r;) 11 === r.nodeType && l(r), r = r.parentNode
                            } else {
                                if (!this._inertRoots.has(e)) return;
                                this._inertRoots.get(e).destructor(), this._inertRoots.delete(e), e.removeAttribute("inert")
                            }
                        }
                    }, {
                        key: "getInertRoot", value: function (e) {
                            return this._inertRoots.get(e)
                        }
                    }, {
                        key: "register", value: function (e, t) {
                            var n = this._managedNodes.get(e);
                            return void 0 !== n ? n.addInertRoot(t) : n = new r(e, t), this._managedNodes.set(e, n), n
                        }
                    }, {
                        key: "deregister", value: function (e, t) {
                            var n = this._managedNodes.get(e);
                            return n ? (n.removeInertRoot(t), n.destroyed && this._managedNodes.delete(e), n) : null
                        }
                    }, {
                        key: "_onDocumentLoaded", value: function () {
                            e.call(this._document.querySelectorAll("[inert]")).forEach((function (e) {
                                this.setInert(e, !0)
                            }), this), this._observer.observe(this._document.body || this._document.documentElement, {
                                attributes: !0,
                                subtree: !0,
                                childList: !0
                            })
                        }
                    }, {
                        key: "_watchForInert", value: function (n, i) {
                            var r = this;
                            n.forEach((function (n) {
                                switch (n.type) {
                                    case"childList":
                                        e.call(n.addedNodes).forEach((function (n) {
                                            if (n.nodeType === Node.ELEMENT_NODE) {
                                                var i = e.call(n.querySelectorAll("[inert]"));
                                                t.call(n, "[inert]") && i.unshift(n), i.forEach((function (e) {
                                                    this.setInert(e, !0)
                                                }), r)
                                            }
                                        }), r);
                                        break;
                                    case"attributes":
                                        if ("inert" !== n.attributeName) return;
                                        var i = n.target, s = i.hasAttribute("inert");
                                        r.setInert(i, s)
                                }
                            }), this)
                        }
                    }]), n
                }();
            if (!Element.prototype.hasOwnProperty("inert")) {
                var a = new s(document);
                Object.defineProperty(Element.prototype, "inert", {
                    enumerable: !0, get: function () {
                        return this.hasAttribute("inert")
                    }, set: function (e) {
                        a.setInert(this, e)
                    }
                })
            }
        }

        function o(e, t, n) {
            if (e.nodeType == Node.ELEMENT_NODE) {
                var i = e;
                t && t(i);
                var r = i.shadowRoot;
                if (r) return void o(r, t);
                if ("content" == i.localName) {
                    for (var s = i, a = s.getDistributedNodes ? s.getDistributedNodes() : [], l = 0; l < a.length; l++) o(a[l], t);
                    return
                }
                if ("slot" == i.localName) {
                    for (var c = i, h = c.assignedNodes ? c.assignedNodes({flatten: !0}) : [], u = 0; u < h.length; u++) o(h[u], t);
                    return
                }
            }
            for (var d = e.firstChild; null != d;) o(d, t), d = d.nextSibling
        }

        function l(e) {
            if (!e.querySelector("style#inert-style, link#inert-style")) {
                var t = document.createElement("style");
                t.setAttribute("id", "inert-style"), t.textContent = "\n[inert] {\n  pointer-events: none;\n  cursor: default;\n}\n\n[inert], [inert] * {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n", e.appendChild(t)
            }
        }
    }(),
        /**
         * @license
         * Copyright 2016 Google Inc. All rights reserved.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        (() => {
            var e, t, n;
            const i = Symbol(), r = Symbol(), s = Symbol(), a = Symbol(), o = Symbol(), l = Symbol(), c = Symbol(),
                h = Symbol(), u = Symbol(), d = Symbol(), p = Symbol(), f = Symbol(), m = Symbol();

            class g {
                constructor() {
                    this[e] = [], this[t] = [], this[n] = new Set
                }

                destructor() {
                    this[u](this[s]);
                    const e = this;
                    e[i] = null, e[s] = null, e[r] = null
                }

                get top() {
                    const e = this[i];
                    return e[e.length - 1] || null
                }

                push(e) {
                    e && e !== this.top && (this.remove(e), this[l](e), this[i].push(e))
                }

                remove(e) {
                    const t = this[i].indexOf(e);
                    return -1 !== t && (this[i].splice(t, 1), t === this[i].length && this[l](this.top), !0)
                }

                pop() {
                    const e = this.top;
                    return e && this.remove(e), e
                }

                has(e) {
                    return -1 !== this[i].indexOf(e)
                }

                [(e = i, t = s, n = r, l)](e) {
                    const t = this[r], n = this[s];
                    if (!e) return this[u](n), t.clear(), void (this[s] = []);
                    const i = this[d](e);
                    if (i[i.length - 1].parentNode !== document.body) throw Error("Non-connected element cannot be a blocking element");
                    this[s] = i;
                    const a = this[p](e);
                    if (!n.length) return void this[h](i, a, t);
                    let o = n.length - 1, l = i.length - 1;
                    for (; o > 0 && l > 0 && n[o] === i[l];) o--, l--;
                    n[o] !== i[l] && this[c](n[o], i[l]), o > 0 && this[u](n.slice(0, o)), l > 0 && this[h](i.slice(0, l), a, null)
                }

                [c](e, t) {
                    const n = e[a];
                    this[f](e) && !e.inert && (e.inert = !0, n.add(e)), n.has(t) && (t.inert = !1, n.delete(t)), t[o] = e[o], t[a] = n, e[o] = void 0, e[a] = void 0
                }

                [u](e) {
                    for (const t of e) {
                        t[o].disconnect(), t[o] = void 0;
                        const e = t[a];
                        for (const t of e) t.inert = !1;
                        t[a] = void 0
                    }
                }

                [h](e, t, n) {
                    for (const i of e) {
                        const e = i.parentNode, r = e.children, s = new Set;
                        for (let e = 0; e < r.length; e++) {
                            const a = r[e];
                            a === i || !this[f](a) || t && t.has(a) || (n && a.inert ? n.add(a) : (a.inert = !0, s.add(a)))
                        }
                        i[a] = s;
                        const l = new MutationObserver(this[m].bind(this));
                        i[o] = l;
                        let c = e;
                        const h = c;
                        h.__shady && h.host && (c = h.host), l.observe(c, {childList: !0})
                    }
                }

                [m](e) {
                    const t = this[s], n = this[r];
                    for (const i of e) {
                        const e = i.target.host || i.target, r = e === document.body ? t.length : t.indexOf(e),
                            s = t[r - 1], o = s[a];
                        for (let e = 0; e < i.removedNodes.length; e++) {
                            const t = i.removedNodes[e];
                            if (t === s) return console.info("Detected removal of the top Blocking Element."), void this.pop();
                            o.has(t) && (t.inert = !1, o.delete(t))
                        }
                        for (let e = 0; e < i.addedNodes.length; e++) {
                            const t = i.addedNodes[e];
                            this[f](t) && (n && t.inert ? n.add(t) : (t.inert = !0, o.add(t)))
                        }
                    }
                }

                [f](e) {
                    return !1 === /^(style|template|script)$/.test(e.localName)
                }

                [d](e) {
                    const t = [];
                    let n = e;
                    for (; n && n !== document.body;) if (n.nodeType === Node.ELEMENT_NODE && t.push(n), n.assignedSlot) {
                        for (; n = n.assignedSlot;) t.push(n);
                        n = t.pop()
                    } else n = n.parentNode || n.host;
                    return t
                }

                [p](e) {
                    const t = e.shadowRoot;
                    if (!t) return null;
                    const n = new Set;
                    let i, r, s;
                    const a = t.querySelectorAll("slot");
                    if (a.length && a[0].assignedNodes) for (i = 0; i < a.length; i++) for (s = a[i].assignedNodes({flatten: !0}), r = 0; r < s.length; r++) s[r].nodeType === Node.ELEMENT_NODE && n.add(s[r]);
                    return n
                }
            }

            document.$blockingElements = new g
        })();
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const Pr = 1;
    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const Ir = (e => (...t) => ({_$litDirective$: e, values: t}))(class extends class {
        constructor(e) {
        }

        get _$AU() {
            return this._$AM._$AU
        }

        _$AT(e, t, n) {
            this._$Ct = e, this._$AM = t, this._$Ci = n
        }

        _$AS(e, t) {
            return this.update(e, t)
        }

        update(e, t) {
            return this.render(...t)
        }
    } {
        constructor(e) {
            var t;
            if (super(e), e.type !== Pr || "class" !== e.name || (null === (t = e.strings) || void 0 === t ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")
        }

        render(e) {
            return " " + Object.keys(e).filter((t => e[t])).join(" ") + " "
        }

        update(e, [t]) {
            var n, i;
            if (void 0 === this.st) {
                this.st = new Set, void 0 !== e.strings && (this.et = new Set(e.strings.join(" ").split(/\s/).filter((e => "" !== e))));
                for (const e in t) t[e] && !(null === (n = this.et) || void 0 === n ? void 0 : n.has(e)) && this.st.add(e);
                return this.render(t)
            }
            const r = e.element.classList;
            this.st.forEach((e => {
                e in t || (r.remove(e), this.st.delete(e))
            }));
            for (const e in t) {
                const n = !!t[e];
                n === this.st.has(e) || (null === (i = this.et) || void 0 === i ? void 0 : i.has(e)) || (n ? (r.add(e), this.st.add(e)) : (r.remove(e), this.st.delete(e)))
            }
            return er
        }
    });
    var Or, Dr;
    !function (e) {
        e.SHARING = "Sharing", e.INFORMATION_POINT = "Information point", e.PODCAST = "Podcast", e.SCROLLY_TELLING = "Scrolly telling", e.NAVIGATION = "Navigation", e.FOOTER = "Footer", e.XR = "XR", e.CAPABILITIES = "Capabilities"
    }(Or || (Or = {})), function (e) {
        e.CLOSE = "Close", e.OPEN = "Open", e.CLICK = "Click", e.ADVANCE = "Advance", e.ENABLE = "Enable", e.DISABLE = "Disable", e.SUPPORTED = "Supported", e.UNSUPPORTED = "Unsupported", e.PLAY = "Play", e.PAUSE = "Pause", e.ENDED = "Ended", e.JUMP_FORWARD = "Jump forward", e.JUMP_BACKWARD = "Jump backward", e.SKIP_CHAPTER_FORWARD = "Skip chapter forward", e.SKIP_CHAPTER_BACKWARD = "Skip chapter backward", e.REACHED_CHAPTER = "Reached chapter", e.REACHED_END = "Reached end"
    }(Dr || (Dr = {}));
    const Nr = ["Introduction", "The Kushite Kingdom", "The Nubian Pyramids", "The Kings and Queens", "The Meroitic Language"];

    function Br(e, t) {
        if (!window.dataLayer) return;
        const n = {event: "customEvent", eventCategory: e};
        t.action && (n.eventAction = t.action), t.label && (n.eventLabel = t.label), void 0 !== t.nonInteraction && (n.nonInteraction = t.nonInteraction), window.dataLayer.push(n)
    }

    var kr;
    !function (e) {
        e.OPEN = "open", e.CLOSE = "close", e.CLOSE_REQUESTED = "close-requested"
    }(kr || (kr = {}));
    const Ur = document.$blockingElements, Fr = "disable-scroll", Hr = Mi`
  :host,
  .root,
  .backdrop {
    height: 100%;
    left: 0;
    max-height: var(--vh);
    top: 0;
    width: 100%;
  }

  :host {
    display: block;
    pointer-events: none;
    position: fixed;
    z-index: 9;
  }

  .root,
  .backdrop {
    position: absolute;
  }

  .root.open > * {
    pointer-events: auto;
  }

  .backdrop {
    background-color: rgba(0, 0, 0, 0.2);
    pointer-events: auto;
    transition: var(--animation-duration) opacity;
  }

  .root:not(.open) .backdrop {
    opacity: 0;
    pointer-events: none;
  }

  .content {
    height: var(--vh);
    overflow: auto;
    position: absolute;
  }
`;
    let zr = class extends _r {
        constructor() {
            super(...arguments), this.open = !1, this.allowFocusOutsideTree = !1, this.inert = !this.allowFocusOutsideTree, this.onKeyDown = e => {
                "Escape" === e.key && this.requestClose()
            }
        }

        connectedCallback() {
            super.connectedCallback(), window.addEventListener("keydown", this.onKeyDown)
        }

        disconnectedCallback() {
            super.disconnectedCallback(), window.removeEventListener("keydown", this.onKeyDown)
        }

        requestClose() {
            this.dispatchEvent(new CustomEvent(kr.CLOSE_REQUESTED))
        }

        saveFocus() {
            this.previousFocus = this.getRootNode().activeElement
        }

        restoreFocus() {
            var e, t;
            null === (t = null === (e = this.previousFocus) || void 0 === e ? void 0 : e.focus) || void 0 === t || t.call(e)
        }

        trapFocus() {
            Ur.push(this)
        }

        releaseFocus() {
            Ur.remove(this)
        }

        onOpen() {
            this.saveFocus(), document.body.classList.add(Fr), this.allowFocusOutsideTree || this.trapFocus();
            const [e] = this.slottedChildren, t = e || this.root;
            t.tabIndex = -1, t.style.outline = "none", requestAnimationFrame((() => {
                requestAnimationFrame((() => {
                    t.focus()
                }))
            }))
        }

        onClose() {
            this.releaseFocus(), document.body.classList.remove(Fr), this.restoreFocus()
        }

        updated(e) {
            if (void 0 !== e.get("open")) {
                this.open ? this.removeAttribute("inert") : this.setAttribute("inert", ""), this.open ? this.onOpen() : this.onClose();
                const e = this.open ? kr.OPEN : kr.CLOSE;
                this.dispatchEvent(new CustomEvent(e)), Br(Or.INFORMATION_POINT, {
                    action: this.open ? Dr.OPEN : Dr.CLOSE,
                    label: this.dataset.overlay
                })
            }
        }

        get slottedChildren() {
            return this.shadowRoot.querySelector("slot").assignedElements({flatten: !0})
        }

        render() {
            const e = Ir({root: !0, open: this.open});
            return Qi`
      <div
        role="dialog"
        aria-modal="true"
        aria-describedby="content"
        tabindex="-1"
        id="root"
        class="${e}"
        part="root"
      >
        <div
          aria-hidden="true"
          class="backdrop"
          @click="${this.requestClose}"
          part="backdrop"
        ></div>
        <div id="content" class="content" part="content">
          <slot></slot>
          <slot name="close"></slot>
        </div>
      </div>
    `
        }
    };
    zr.styles = [Hr], e([Tr("#root")], zr.prototype, "root", void 0), e([wr({
        type: Boolean,
        reflect: !0
    })], zr.prototype, "open", void 0), e([wr({
        type: Boolean,
        reflect: !0
    })], zr.prototype, "allowFocusOutsideTree", void 0), zr = e([xr("pk-overlay")], zr);
    const Gr = Mi`
:host {
  display: block;
}
`;
    let Vr = class extends _r {
        constructor() {
            super(...arguments), this.open = !1
        }

        render() {
            return Qi`
      <div
        role="dialog"
        aria-modal="true"
        tabindex="-1"
        part="content">
        <slot></slot>
      </div>
    `
        }
    };
    Vr.styles = [Gr], e([wr({
        type: Boolean,
        reflect: !0
    })], Vr.prototype, "open", void 0), Vr = e([xr("pk-overlay-simplified")], Vr);
    /*!
     * ScrollToPlugin 3.10.1
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var Wr, jr, $r, Xr, qr, Yr, Kr, Jr = function () {
        return "undefined" != typeof window
    }, Zr = function () {
        return Wr || Jr() && (Wr = window.gsap) && Wr.registerPlugin && Wr
    }, Qr = function (e) {
        return "string" == typeof e
    }, es = function (e) {
        return "function" == typeof e
    }, ts = function (e, t) {
        var n = "x" === t ? "Width" : "Height", i = "scroll" + n, r = "client" + n;
        return e === $r || e === Xr || e === qr ? Math.max(Xr[i], qr[i]) - ($r["inner" + n] || Xr[r] || qr[r]) : e[i] - e["offset" + n]
    }, ns = function (e, t) {
        var n = "scroll" + ("x" === t ? "Left" : "Top");
        return e === $r && (null != e.pageXOffset ? n = "page" + t.toUpperCase() + "Offset" : e = null != Xr[n] ? Xr : qr), function () {
            return e[n]
        }
    }, is = function (e, t) {
        if (!(e = Yr(e)[0]) || !e.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
            x: 0,
            y: 0
        };
        var n = e.getBoundingClientRect(), i = !t || t === $r || t === qr, r = i ? {
            top: Xr.clientTop - ($r.pageYOffset || Xr.scrollTop || qr.scrollTop || 0),
            left: Xr.clientLeft - ($r.pageXOffset || Xr.scrollLeft || qr.scrollLeft || 0)
        } : t.getBoundingClientRect(), s = {x: n.left - r.left, y: n.top - r.top};
        return !i && t && (s.x += ns(t, "x")(), s.y += ns(t, "y")()), s
    }, rs = function (e, t, n, i, r) {
        return isNaN(e) || "object" == typeof e ? Qr(e) && "=" === e.charAt(1) ? parseFloat(e.substr(2)) * ("-" === e.charAt(0) ? -1 : 1) + i - r : "max" === e ? ts(t, n) - r : Math.min(ts(t, n), is(e, t)[n] - r) : parseFloat(e) - r
    }, ss = function () {
        Wr = Zr(), Jr() && Wr && document.body && ($r = window, qr = document.body, Xr = document.documentElement, Yr = Wr.utils.toArray, Wr.config({autoKillThreshold: 7}), Kr = Wr.config(), jr = 1)
    }, as = {
        version: "3.10.1", name: "scrollTo", rawVars: 1, register: function (e) {
            Wr = e, ss()
        }, init: function (e, t, n, i, r) {
            jr || ss();
            var s = this, a = Wr.getProperty(e, "scrollSnapType");
            s.isWin = e === $r, s.target = e, s.tween = n, t = function (e, t, n, i) {
                if (es(e) && (e = e(t, n, i)), "object" != typeof e) return Qr(e) && "max" !== e && "=" !== e.charAt(1) ? {
                    x: e,
                    y: e
                } : {y: e};
                if (e.nodeType) return {y: e, x: e};
                var r, s = {};
                for (r in e) s[r] = "onAutoKill" !== r && es(e[r]) ? e[r](t, n, i) : e[r];
                return s
            }(t, i, e, r), s.vars = t, s.autoKill = !!t.autoKill, s.getX = ns(e, "x"), s.getY = ns(e, "y"), s.x = s.xPrev = s.getX(), s.y = s.yPrev = s.getY(), a && "none" !== a && (s.snap = 1, s.snapInline = e.style.scrollSnapType, e.style.scrollSnapType = "none"), null != t.x ? (s.add(s, "x", s.x, rs(t.x, e, "x", s.x, t.offsetX || 0), i, r), s._props.push("scrollTo_x")) : s.skipX = 1, null != t.y ? (s.add(s, "y", s.y, rs(t.y, e, "y", s.y, t.offsetY || 0), i, r), s._props.push("scrollTo_y")) : s.skipY = 1
        }, render: function (e, t) {
            for (var n, i, r, s, a, o = t._pt, l = t.target, c = t.tween, h = t.autoKill, u = t.xPrev, d = t.yPrev, p = t.isWin, f = t.snap, m = t.snapInline; o;) o.r(e, o.d), o = o._next;
            n = p || !t.skipX ? t.getX() : u, r = (i = p || !t.skipY ? t.getY() : d) - d, s = n - u, a = Kr.autoKillThreshold, t.x < 0 && (t.x = 0), t.y < 0 && (t.y = 0), h && (!t.skipX && (s > a || s < -a) && n < ts(l, "x") && (t.skipX = 1), !t.skipY && (r > a || r < -a) && i < ts(l, "y") && (t.skipY = 1), t.skipX && t.skipY && (c.kill(), t.vars.onAutoKill && t.vars.onAutoKill.apply(c, t.vars.onAutoKillParams || []))), p ? $r.scrollTo(t.skipX ? n : t.x, t.skipY ? i : t.y) : (t.skipY || (l.scrollTop = t.y), t.skipX || (l.scrollLeft = t.x)), !f || 1 !== e && 0 !== e || (i = l.scrollTop, n = l.scrollLeft, m ? l.style.scrollSnapType = m : l.style.removeProperty("scroll-snap-type"), l.scrollTop = i + 1, l.scrollLeft = n + 1, l.scrollTop = i, l.scrollLeft = n), t.xPrev = t.x, t.yPrev = t.y
        }, kill: function (e) {
            var t = "scrollTo" === e;
            (t || "scrollTo_x" === e) && (this.skipX = 1), (t || "scrollTo_y" === e) && (this.skipY = 1)
        }
    };

    function os(e, t) {
        for (var n = 0; n < t.length; n++) {
            var i = t[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
    }

    as.max = ts, as.getOffset = is, as.buildGetter = ns, Zr() && Wr.registerPlugin(as);
    /*!
     * Observer 3.10.1
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var ls, cs, hs, us, ds, ps, fs, ms, gs, vs, _s, ys = function () {
        return ls || "undefined" != typeof window && (ls = window.gsap) && ls.registerPlugin && ls
    }, xs = 1, bs = [], ws = [], Ts = [], Ss = Date.now, Es = function (e, t) {
        return t
    }, Ms = function (e, t) {
        return ~Ts.indexOf(e) && Ts[Ts.indexOf(e) + 1][t]
    }, As = function (e) {
        return !!~vs.indexOf(e)
    }, Ls = function (e, t, n, i) {
        return e.addEventListener(t, n, {passive: !i})
    }, Cs = function (e, t, n) {
        return e.removeEventListener(t, n)
    }, Rs = "scrollLeft", Ps = "scrollTop", Is = function () {
        return _s && _s.isPressed || ws.cache++
    }, Os = function (e) {
        return function (t) {
            return t || 0 === t ? (xs && (hs.history.scrollRestoration = "manual"), e(t), e.v = t, e.c = ws.cache, _s && _s.isPressed && Es("ss", t)) : (ws.cache !== e.c || Es("ref")) && (e.c = ws.cache, e.v = e()), e.v
        }
    }, Ds = {
        s: Rs,
        p: "left",
        p2: "Left",
        os: "right",
        os2: "Right",
        d: "width",
        d2: "Width",
        a: "x",
        sc: Os((function (e) {
            return arguments.length ? hs.scrollTo(e, Ns.sc()) : hs.pageXOffset || us.scrollLeft || ds.scrollLeft || ps.scrollLeft || 0
        }))
    }, Ns = {
        s: Ps,
        p: "top",
        p2: "Top",
        os: "bottom",
        os2: "Bottom",
        d: "height",
        d2: "Height",
        a: "y",
        op: Ds,
        sc: Os((function (e) {
            return arguments.length ? hs.scrollTo(Ds.sc(), e) : hs.pageYOffset || us.scrollTop || ds.scrollTop || ps.scrollTop || 0
        }))
    }, Bs = function (e) {
        return ls.utils.toArray(e)[0] || ("string" == typeof e && !1 !== ls.config().nullTargetWarn ? console.warn("Element not found:", e) : null)
    }, ks = function (e, t) {
        var n = t.s, i = t.sc, r = ws.indexOf(e), s = i === Ns.sc ? 1 : 2;
        return !~r && (r = ws.push(e) - 1), ws[r + s] || (ws[r + s] = Ms(e, n) || (As(e) ? i : function (t) {
            return arguments.length ? e[n] = t : e[n]
        }))
    }, Us = function (e, t, n) {
        var i = e, r = e, s = Ss(), a = s, o = t || 50, l = Math.max(500, 3 * o), c = function (e, t) {
            var l = Ss();
            t || l - s > o ? (r = i, i = e, a = s, s = l) : n ? i += e : i = r + (e - r) / (l - a) * (s - a)
        };
        return {
            update: c, reset: function () {
                r = i = n ? 0 : i, a = s = 0
            }, getVelocity: function (e) {
                var t = a, o = r, h = Ss();
                return (e || 0 === e) && e !== i && c(e), s === a || h - a > l ? 0 : (i + (n ? o : -o)) / ((n ? h : s) - t) * 1e3
            }
        }
    }, Fs = function (e, t) {
        return t && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
    }, Hs = function (e) {
        var t = Math.max.apply(Math, e), n = Math.min.apply(Math, e);
        return Math.abs(t) >= Math.abs(n) ? t : n
    }, zs = function (e) {
        return (ls = e || ys()) && !cs && "undefined" != typeof document && (hs = window, us = document, ds = us.documentElement, ps = us.body, vs = [hs, us, ds, ps], ls.utils.clamp, ms = "onpointerenter" in ps ? "pointer" : "mouse", fs = Gs.isTouch = hs.matchMedia && hs.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in hs || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, setTimeout((function () {
            return xs = 0
        }), 500), cs = 1), cs
    };
    Ds.op = Ns, ws.cache = 0;
    var Gs = function () {
        function e(e) {
            this.init(e)
        }

        var t, n, i;
        return e.prototype.init = function (e) {
            var t, n, i, r;
            cs || zs(ls) || console.warn("Please gsap.registerPlugin(Observer)"), gs || (gs = ls.core.globals().ScrollTrigger) && gs.core && (t = gs.core, n = t.bridge || {}, i = t._scrollers, r = t._proxies, i.push.apply(i, ws), r.push.apply(r, Ts), ws = i, Ts = r, Es = function (e, t) {
                return n[e](t)
            });
            var s = e.tolerance, a = e.dragMinimum, o = e.type, l = e.target, c = e.lineHeight, h = e.debounce,
                u = e.preventDefault, d = e.onStop, p = e.onStopDelay, f = e.ignore, m = e.wheelSpeed, g = e.event,
                v = e.onDragStart, _ = e.onDragEnd, y = e.onDrag, x = e.onPress, b = e.onRelease, w = e.onRight,
                T = e.onLeft, S = e.onUp, E = e.onDown, M = e.onChangeX, A = e.onChangeY, L = e.onChange,
                C = e.onToggleX, R = e.onToggleY, P = e.onHover, I = e.onHoverEnd, O = e.onMove, D = e.ignoreCheck,
                N = e.isNormalizer, B = e.onGestureStart, k = e.onGestureEnd, U = e.onWheel, F = e.onEnable,
                H = e.onDisable, z = e.onClick, G = e.scrollSpeed;
            this.target = l = Bs(l) || ds, this.vars = e, f && (f = ls.utils.toArray(f)), s = s || 0, a = a || 0, m = m || 1, G = G || 1, o = o || "wheel,touch,pointer", h = !1 !== h, c || (c = parseFloat(hs.getComputedStyle(ps).lineHeight) || 22);
            var V, W, j, $, X, q = this, Y = 0, K = 0, J = ks(l, Ds), Z = ks(l, Ns), Q = J(), ee = Z(),
                te = ("ontouchstart" in ds ? "touchstart,touchmove,touchcancel,touchend" : o.indexOf("pointer") >= 0 && !("onpointerdown" in ds) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(","),
                ne = ~o.indexOf("touch") && !~o.indexOf("pointer") && "pointerdown" === te[0], ie = As(l),
                re = l.ownerDocument || us, se = [0, 0, 0], ae = [0, 0, 0], oe = function (e, t) {
                    return (q.event = e) && f && ~f.indexOf(e.target) || t && ne && "touch" !== e.pointerType || D && D(e)
                }, le = function () {
                    var e = q.deltaX = Hs(se), t = q.deltaY = Hs(ae), n = Math.abs(e) >= s, i = Math.abs(t) >= s;
                    L && (n || i) && L(q, e, t, se, ae), n && (w && q.deltaX > 0 && w(q), T && q.deltaX < 0 && T(q), M && M(q), C && q.deltaX < 0 != Y < 0 && C(q), Y = q.deltaX, se[0] = se[1] = se[2] = 0), i && (E && q.deltaY > 0 && E(q), S && q.deltaY < 0 && S(q), A && A(q), R && q.deltaY < 0 != K < 0 && R(q), K = q.deltaY, ae[0] = ae[1] = ae[2] = 0), $ && (O(q), $ = !1), j && (y(q), j = !1), X && (U(q), X = !1), V = 0
                }, ce = function (e, t, n) {
                    se[n] += e, ae[n] += t, q._vx.update(e, 2 === n), q._vy.update(t, 2 === n), h ? V || (V = requestAnimationFrame(le)) : le()
                }, he = function (e) {
                    if (!oe(e, 1)) {
                        var t = (e = Fs(e, u)).clientX, n = e.clientY, i = t - q.x, r = n - q.y, s = q.isDragging;
                        q.x = t, q.y = n, (s || Math.abs(q.startX - t) >= a || Math.abs(q.startY - n) >= a) && (y && (j = !0), s || (q.isDragging = !0), ce(i, r, 2), s || v && v(q))
                    }
                }, ue = q.onPress = function (e) {
                    oe(e, 1) || (W.pause(), q.isPressed = !0, e = Fs(e, u), Y = K = 0, q.startX = q.x = e.clientX, q.startY = q.y = e.clientY, q._vx.reset(), q._vy.reset(), Ls(N ? l : re, te[1], he, u), q.deltaX = q.deltaY = 0, x && x(q))
                }, de = function (e) {
                    if (!oe(e, 1)) {
                        Cs(N ? l : re, te[1], he);
                        var t = q.isDragging;
                        t || (q._vx.reset(), q._vy.reset()), q.isDragging = q.isGesturing = q.isPressed = !1, d && !N && W.restart(!0), _ && t && _(q), b && b(q, t)
                    }
                }, pe = function (e) {
                    return e.touches && e.touches.length > 1 && (q.isGesturing = !0) && B(e, q.isDragging)
                }, fe = function () {
                    return (q.isGesturing = !1) || k(q)
                }, me = function (e) {
                    if (!oe(e)) {
                        var t = J(), n = Z();
                        ce((t - Q) * G, (n - ee) * G, 1), Q = t, ee = n, d && W.restart(!0)
                    }
                }, ge = function (e) {
                    if (!oe(e)) {
                        e = Fs(e, u), U && (X = !0);
                        var t = (1 === e.deltaMode ? c : 2 === e.deltaMode ? hs.innerHeight : 1) * m;
                        ce(e.deltaX * t, e.deltaY * t, 0), d && !N && W.restart(!0)
                    }
                }, ve = function (e) {
                    if (!oe(e)) {
                        var t = e.clientX, n = e.clientY, i = t - q.x, r = n - q.y;
                        q.x = t, q.y = n, O && ($ = !0), (i || r) && ce(i, r, 2)
                    }
                }, _e = function (e) {
                    q.event = e, P(q)
                }, ye = function (e) {
                    q.event = e, I(q)
                }, xe = function (e) {
                    return oe(e) || Fs(e, u) && z(q)
                };
            W = q._dc = ls.delayedCall(p || .25, (function () {
                q._vx.reset(), q._vy.reset(), W.pause(), d && d(q)
            })).pause(), q.deltaX = q.deltaY = 0, q._vx = Us(0, 50, !0), q._vy = Us(0, 50, !0), q.scrollX = J, q.scrollY = Z, q.isDragging = q.isGesturing = q.isPressed = !1, q.enable = function (e) {
                return q.isEnabled || (Ls(ie ? re : l, "scroll", Is), o.indexOf("scroll") >= 0 && Ls(ie ? re : l, "scroll", me, u), o.indexOf("wheel") >= 0 && Ls(l, "wheel", ge, u), (o.indexOf("touch") >= 0 && fs || o.indexOf("pointer") >= 0) && (Ls(l, te[0], ue, u), Ls(re, te[2], de), Ls(re, te[3], de), z && Ls(l, "click", xe), B && Ls(re, "gesturestart", pe), k && Ls(re, "gestureend", fe), P && Ls(l, ms + "enter", _e), I && Ls(l, ms + "leave", ye), O && Ls(l, ms + "move", ve)), q.isEnabled = !0, e && e.type && ue(e), F && F(q)), q
            }, q.disable = function () {
                q.isEnabled && (bs.filter((function (e) {
                    return e !== q && As(e.target)
                })).length || Cs(ie ? re : l, "scroll", Is), Cs(ie ? re : l, "scroll", me), Cs(l, "wheel", ge), Cs(l, te[0], ue), Cs(re, te[2], de), Cs(re, te[3], de), Cs(l, "click", xe), Cs(re, "gesturestart", pe), Cs(re, "gestureend", fe), Cs(l, ms + "enter", _e), Cs(l, ms + "leave", ye), Cs(l, ms + "move", ve), q.isEnabled = !1, H && H(q))
            }, q.kill = function () {
                q.disable();
                var e = bs.indexOf(q);
                e >= 0 && bs.splice(e, 1), _s === q && (_s = 0)
            }, bs.push(q), N && (_s = q), q.enable(g)
        }, t = e, (n = [{
            key: "velocityX", get: function () {
                return this._vx.getVelocity()
            }
        }, {
            key: "velocityY", get: function () {
                return this._vy.getVelocity()
            }
        }]) && os(t.prototype, n), i && os(t, i), e
    }();
    Gs.version = "3.10.1", Gs.create = function (e) {
        return new Gs(e)
    }, Gs.register = zs, Gs.getAll = function () {
        return bs.slice()
    }, Gs.getById = function (e) {
        return bs.filter((function (t) {
            return t.vars.id === e
        }))[0]
    }, ys() && ls.registerPlugin(Gs);
    /*!
     * ScrollTrigger 3.10.1
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var Vs, Ws, js, $s, Xs, qs, Ys, Ks, Js, Zs, Qs, ea, ta, na, ia, ra, sa, aa, oa, la, ca, ha, ua, da, pa, fa, ma, ga,
        va, _a, ya, xa, ba = 1, wa = Date.now, Ta = wa(), Sa = 0, Ea = 0, Ma = function () {
            return na = 1
        }, Aa = function () {
            return na = 0
        }, La = function (e) {
            return e
        }, Ca = function (e) {
            return Math.round(1e5 * e) / 1e5 || 0
        }, Ra = function () {
            return "undefined" != typeof window
        }, Pa = function () {
            return Vs || Ra() && (Vs = window.gsap) && Vs.registerPlugin && Vs
        }, Ia = function (e) {
            return !!~Ys.indexOf(e)
        }, Oa = function (e) {
            return Ms(e, "getBoundingClientRect") || (Ia(e) ? function () {
                return Vo.width = js.innerWidth, Vo.height = js.innerHeight, Vo
            } : function () {
                return no(e)
            })
        }, Da = function (e, t) {
            var n = t.s, i = t.d2, r = t.d, s = t.a;
            return (n = "scroll" + i) && (s = Ms(e, n)) ? s() - Oa(e)()[r] : Ia(e) ? (Xs[n] || qs[n]) - (js["inner" + i] || Xs["client" + i] || qs["client" + i]) : e[n] - e["offset" + i]
        }, Na = function (e, t) {
            for (var n = 0; n < oa.length; n += 3) (!t || ~t.indexOf(oa[n + 1])) && e(oa[n], oa[n + 1], oa[n + 2])
        }, Ba = function (e) {
            return "string" == typeof e
        }, ka = function (e) {
            return "function" == typeof e
        }, Ua = function (e) {
            return "number" == typeof e
        }, Fa = function (e) {
            return "object" == typeof e
        }, Ha = function (e) {
            return ka(e) && e()
        }, za = function (e, t) {
            return function () {
                var n = Ha(e), i = Ha(t);
                return function () {
                    Ha(n), Ha(i)
                }
            }
        }, Ga = function (e, t, n) {
            return e && e.progress(t ? 0 : 1) && n && e.pause()
        }, Va = function (e, t) {
            if (e.enabled) {
                var n = t(e);
                n && n.totalTime && (e.callbackAnimation = n)
            }
        }, Wa = Math.abs, ja = "left", $a = "right", Xa = "bottom", qa = "width", Ya = "height", Ka = "padding",
        Ja = "margin", Za = "Width", Qa = "px", eo = function (e) {
            return js.getComputedStyle(e)
        }, to = function (e, t) {
            for (var n in t) n in e || (e[n] = t[n]);
            return e
        }, no = function (e, t) {
            var n = t && "matrix(1, 0, 0, 1, 0, 0)" !== eo(e)[ia] && Vs.to(e, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1), i = e.getBoundingClientRect();
            return n && n.progress(0).kill(), i
        }, io = function (e, t) {
            var n = t.d2;
            return e["offset" + n] || e["client" + n] || 0
        }, ro = function (e) {
            var t, n = [], i = e.labels, r = e.duration();
            for (t in i) n.push(i[t] / r);
            return n
        }, so = function (e) {
            var t = Vs.utils.snap(e), n = Array.isArray(e) && e.slice(0).sort((function (e, t) {
                return e - t
            }));
            return n ? function (e, i, r) {
                var s;
                if (void 0 === r && (r = .001), !i) return t(e);
                if (i > 0) {
                    for (e -= r, s = 0; s < n.length; s++) if (n[s] >= e) return n[s];
                    return n[s - 1]
                }
                for (s = n.length, e += r; s--;) if (n[s] <= e) return n[s];
                return n[0]
            } : function (n, i, r) {
                void 0 === r && (r = .001);
                var s = t(n);
                return !i || Math.abs(s - n) < r || s - n < 0 == i < 0 ? s : t(i < 0 ? n - e : n + e)
            }
        }, ao = function (e, t, n, i) {
            return n.split(",").forEach((function (n) {
                return e(t, n, i)
            }))
        }, oo = function (e, t, n, i) {
            return e.addEventListener(t, n, {passive: !i})
        }, lo = function (e, t, n) {
            return e.removeEventListener(t, n)
        }, co = function (e, t, n) {
            return n && n.wheelHandler && e(t, "wheel", n)
        }, ho = {startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal"},
        uo = {toggleActions: "play", anticipatePin: 0}, po = {top: 0, left: 0, center: .5, bottom: 1, right: 1},
        fo = function (e, t) {
            if (Ba(e)) {
                var n = e.indexOf("="), i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
                ~n && (e.indexOf("%") > n && (i *= t / 100), e = e.substr(0, n - 1)), e = i + (e in po ? po[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
            }
            return e
        }, mo = function (e, t, n, i, r, s, a, o) {
            var l = r.startColor, c = r.endColor, h = r.fontSize, u = r.indent, d = r.fontWeight,
                p = $s.createElement("div"), f = Ia(n) || "fixed" === Ms(n, "pinType"), m = -1 !== e.indexOf("scroller"),
                g = f ? qs : n, v = -1 !== e.indexOf("start"), _ = v ? l : c,
                y = "border-color:" + _ + ";font-size:" + h + ";color:" + _ + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return y += "position:" + ((m || o) && f ? "fixed;" : "absolute;"), (m || o || !f) && (y += (i === Ns ? $a : Xa) + ":" + (s + parseFloat(u)) + "px;"), a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), p._isStart = v, p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), p.style.cssText = y, p.innerText = t || 0 === t ? e + "-" + t : e, g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p), p._offset = p["offset" + i.op.d2], go(p, 0, i, v), p
        }, go = function (e, t, n, i) {
            var r = {display: "block"}, s = n[i ? "os2" : "p2"], a = n[i ? "p2" : "os2"];
            e._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + s + Za] = 1, r["border" + a + Za] = 0, r[n.p] = t + "px", Vs.set(e, r)
        }, vo = [], _o = {}, yo = function () {
            return wa() - Sa > 34 && Bo()
        }, xo = function () {
            ua && ua.isPressed || (ws.cache++, ga || (ga = requestAnimationFrame(Bo)), Sa || Ao("scrollStart"), Sa = wa())
        }, bo = function () {
            ws.cache++, !ta && !ha && !$s.fullscreenElement && (!da || fa !== js.innerWidth || Math.abs(js.innerHeight - pa) > .25 * js.innerHeight) && Ks.restart(!0)
        }, wo = {}, To = [], So = [], Eo = function (e) {
            var t, n = Vs.ticker.frame, i = [], r = 0;
            if (_a !== n || ba) {
                for (Ro(); r < So.length; r += 4) (t = js.matchMedia(So[r]).matches) !== So[r + 3] && (So[r + 3] = t, t ? i.push(r) : Ro(1, So[r]) || ka(So[r + 2]) && So[r + 2]());
                for (Co(), r = 0; r < i.length; r++) t = i[r], va = So[t], So[t + 2] = So[t + 1](e);
                va = 0, Ws && Oo(0, 1), _a = n, Ao("matchMedia")
            }
        }, Mo = function e() {
            return lo(qo, "scrollEnd", e) || Oo(!0)
        }, Ao = function (e) {
            return wo[e] && wo[e].map((function (e) {
                return e()
            })) || To
        }, Lo = [], Co = function (e) {
            for (var t = 0; t < Lo.length; t += 5) e && Lo[t + 4] !== e || (Lo[t].style.cssText = Lo[t + 1], Lo[t].getBBox && Lo[t].setAttribute("transform", Lo[t + 2] || ""), Lo[t + 3].uncache = 1)
        }, Ro = function (e, t) {
            var n;
            for (ra = 0; ra < vo.length; ra++) n = vo[ra], t && n.media !== t || (e ? n.kill(1) : n.revert());
            t && Co(t), t || Ao("revert")
        }, Po = function () {
            return ws.cache++ && ws.forEach((function (e) {
                return "function" == typeof e && (e.rec = 0)
            }))
        }, Io = 0, Oo = function (e, t) {
            if (!Sa || e) {
                ya = !0;
                var n = Ao("refreshInit");
                la && qo.sort(), t || Ro(), vo.slice(0).forEach((function (e) {
                    return e.refresh()
                })), vo.forEach((function (e) {
                    return "max" === e.vars.end && e.setPositions(e.start, Da(e.scroller, e._dir))
                })), n.forEach((function (e) {
                    return e && e.render && e.render(-1)
                })), Po(), Ks.pause(), Io++, ya = !1, Ao("refresh")
            } else oo(qo, "scrollEnd", Mo)
        }, Do = 0, No = 1, Bo = function () {
            if (!ya) {
                xa && xa.update(0), qo.isUpdating = !0;
                var e = vo.length, t = wa(), n = t - Ta >= 50, i = e && vo[0].scroll();
                if (No = Do > i ? -1 : 1, Do = i, n && (Sa && !na && t - Sa > 200 && (Sa = 0, Ao("scrollEnd")), Qs = Ta, Ta = t), No < 0) {
                    for (ra = e; ra-- > 0;) vo[ra] && vo[ra].update(0, n);
                    No = 1
                } else for (ra = 0; ra < e; ra++) vo[ra] && vo[ra].update(0, n);
                qo.isUpdating = !1
            }
            ga = 0
        },
        ko = [ja, "top", Xa, $a, "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
        Uo = ko.concat([qa, Ya, "boxSizing", "maxWidth", "maxHeight", "position", Ja, Ka, "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]),
        Fo = function (e, t, n, i) {
            if (e.parentNode !== t) {
                for (var r, s = ko.length, a = t.style, o = e.style; s--;) a[r = ko[s]] = n[r];
                a.position = "absolute" === n.position ? "absolute" : "relative", "inline" === n.display && (a.display = "inline-block"), o.bottom = o.right = a.flexBasis = "auto", a.overflow = "visible", a.boxSizing = "border-box", a.width = io(e, Ds) + Qa, a.height = io(e, Ns) + Qa, a.padding = o.margin = o.top = o.left = "0", zo(i), o.width = o.maxWidth = n.width, o.height = o.maxHeight = n.height, o.padding = n.padding, e.parentNode.insertBefore(t, e), t.appendChild(e)
            }
        }, Ho = /([A-Z])/g, zo = function (e) {
            if (e) {
                var t, n, i = e.t.style, r = e.length, s = 0;
                for ((e.t._gsap || Vs.core.getCache(e.t)).uncache = 1; s < r; s += 2) n = e[s + 1], t = e[s], n ? i[t] = n : i[t] && i.removeProperty(t.replace(Ho, "-$1").toLowerCase())
            }
        }, Go = function (e) {
            for (var t = Uo.length, n = e.style, i = [], r = 0; r < t; r++) i.push(Uo[r], n[Uo[r]]);
            return i.t = e, i
        }, Vo = {left: 0, top: 0}, Wo = function (e, t, n, i, r, s, a, o, l, c, h, u, d) {
            ka(e) && (e = e(o)), Ba(e) && "max" === e.substr(0, 3) && (e = u + ("=" === e.charAt(4) ? fo("0" + e.substr(3), n) : 0));
            var p, f, m, g = d ? d.time() : 0;
            if (d && d.seek(0), Ua(e)) a && go(a, n, i, !0); else {
                ka(t) && (t = t(o));
                var v, _, y, x, b = e.split(" ");
                m = Bs(t) || qs, (v = no(m) || {}) && (v.left || v.top) || "none" !== eo(m).display || (x = m.style.display, m.style.display = "block", v = no(m), x ? m.style.display = x : m.style.removeProperty("display")), _ = fo(b[0], v[i.d]), y = fo(b[1] || "0", n), e = v[i.p] - l[i.p] - c + _ + r - y, a && go(a, y, i, n - y < 20 || a._isStart && y > 20), n -= n - y
            }
            if (s) {
                var w = e + n, T = s._isStart;
                p = "scroll" + i.d2, go(s, w, i, T && w > 20 || !T && (h ? Math.max(qs[p], Xs[p]) : s.parentNode[p]) <= w + 1), h && (l = no(a), h && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + Qa))
            }
            return d && m && (p = no(m), d.seek(u), f = no(m), d._caScrollDist = p[i.p] - f[i.p], e = e / d._caScrollDist * u), d && d.seek(g), d ? e : Math.round(e)
        }, jo = /(webkit|moz|length|cssText|inset)/i, $o = function (e, t, n, i) {
            if (e.parentNode !== t) {
                var r, s, a = e.style;
                if (t === qs) {
                    for (r in e._stOrig = a.cssText, s = eo(e)) +r || jo.test(r) || !s[r] || "string" != typeof a[r] || "0" === r || (a[r] = s[r]);
                    a.top = n, a.left = i
                } else a.cssText = e._stOrig;
                Vs.core.getCache(e).uncache = 1, t.appendChild(e)
            }
        }, Xo = function (e, t) {
            var n, i, r = ks(e, t), s = "_scroll" + t.p2, a = function t(a, o, l, c, h) {
                var u = t.tween, d = o.onComplete, p = {};
                return l = l || r(), h = c && h || 0, c = c || a - l, u && u.kill(), n = Math.round(l), o[s] = a, o.modifiers = p, p[s] = function (e) {
                    return (e = Ca(r())) !== n && e !== i && Math.abs(e - n) > 2 && Math.abs(e - i) > 2 ? (u.kill(), t.tween = 0) : e = l + c * u.ratio + h * u.ratio * u.ratio, i = n, n = Ca(e)
                }, o.onComplete = function () {
                    t.tween = 0, d && d.call(u)
                }, u = t.tween = Vs.to(e, o)
            };
            return e[s] = r, r.wheelHandler = function () {
                return a.tween && a.tween.kill() && (a.tween = 0)
            }, oo(e, "wheel", r.wheelHandler), a
        }, qo = function () {
            function e(t, n) {
                Ws || e.register(Vs) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(t, n)
            }

            return e.prototype.init = function (t, n) {
                if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), Ea) {
                    var i, r, s, a, o, l, c, h, u, d, p, f, m, g, v, _, y, x, b, w, T, S, E, M, A, L, C, R, P, I, O, D, N,
                        B, k, U, F, H, z, G, V, W = t = to(Ba(t) || Ua(t) || t.nodeType ? {trigger: t} : t, uo),
                        j = W.onUpdate, $ = W.toggleClass, X = W.id, q = W.onToggle, Y = W.onRefresh, K = W.scrub,
                        J = W.trigger, Z = W.pin, Q = W.pinSpacing, ee = W.invalidateOnRefresh, te = W.anticipatePin,
                        ne = W.onScrubComplete, ie = W.onSnapComplete, re = W.once, se = W.snap, ae = W.pinReparent,
                        oe = W.pinSpacer, le = W.containerAnimation, ce = W.fastScrollEnd, he = W.preventOverlaps,
                        ue = t.horizontal || t.containerAnimation && !1 !== t.horizontal ? Ds : Ns, de = !K && 0 !== K,
                        pe = Bs(t.scroller || js), fe = Vs.core.getCache(pe), me = Ia(pe),
                        ge = "fixed" === ("pinType" in t ? t.pinType : Ms(pe, "pinType") || me && "fixed"),
                        ve = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack], _e = de && t.toggleActions.split(" "),
                        ye = "markers" in t ? t.markers : uo.markers,
                        xe = me ? 0 : parseFloat(eo(pe)["border" + ue.p2 + Za]) || 0, be = this,
                        we = t.onRefreshInit && function () {
                            return t.onRefreshInit(be)
                        }, Te = function (e, t, n) {
                            var i = n.d, r = n.d2, s = n.a;
                            return (s = Ms(e, "getBoundingClientRect")) ? function () {
                                return s()[i]
                            } : function () {
                                return (t ? js["inner" + r] : e["client" + r]) || 0
                            }
                        }(pe, me, ue), Se = function (e, t) {
                            return !t || ~Ts.indexOf(e) ? Oa(e) : function () {
                                return Vo
                            }
                        }(pe, me), Ee = 0, Me = ks(pe, ue);
                    if (be.media = va, be._dir = ue, te *= 45, be.scroller = pe, be.scroll = le ? le.time.bind(le) : Me, a = Me(), be.vars = t, n = n || t.animation, "refreshPriority" in t && (la = 1, -9999 === t.refreshPriority && (xa = be)), fe.tweenScroll = fe.tweenScroll || {
                        top: Xo(pe, Ns),
                        left: Xo(pe, Ds)
                    }, be.tweenTo = i = fe.tweenScroll[ue.p], be.scrubDuration = function (e) {
                        (O = Ua(e) && e) ? I ? I.duration(e) : I = Vs.to(n, {
                            ease: "expo",
                            totalProgress: "+=0.001",
                            duration: O,
                            paused: !0,
                            onComplete: function () {
                                return ne && ne(be)
                            }
                        }) : (I && I.progress(1).kill(), I = 0)
                    }, n && (n.vars.lazy = !1, n._initted || !1 !== n.vars.immediateRender && !1 !== t.immediateRender && n.render(0, !0, !0), be.animation = n.pause(), n.scrollTrigger = be, be.scrubDuration(K), R = 0, X || (X = n.vars.id)), vo.push(be), se && (Fa(se) && !se.push || (se = {snapTo: se}), "scrollBehavior" in qs.style && Vs.set(me ? [qs, Xs] : pe, {scrollBehavior: "auto"}), s = ka(se.snapTo) ? se.snapTo : "labels" === se.snapTo ? function (e) {
                        return function (t) {
                            return Vs.utils.snap(ro(e), t)
                        }
                    }(n) : "labelsDirectional" === se.snapTo ? (z = n, function (e, t) {
                        return so(ro(z))(e, t.direction)
                    }) : !1 !== se.directional ? function (e, t) {
                        return so(se.snapTo)(e, ta ? 0 : t.direction)
                    } : Vs.utils.snap(se.snapTo), D = se.duration || {
                        min: .1,
                        max: 2
                    }, D = Fa(D) ? Zs(D.min, D.max) : Zs(D, D), N = Vs.delayedCall(se.delay || O / 2 || .1, (function () {
                        if (Math.abs(be.getVelocity()) < 10 && !na && Ee !== Me()) {
                            var e = n && !de ? n.totalProgress() : be.progress, t = (e - P) / (wa() - Qs) * 1e3 || 0,
                                r = Vs.utils.clamp(-be.progress, 1 - be.progress, Wa(t / 2) * t / .185),
                                a = be.progress + (!1 === se.inertia ? 0 : r), o = Zs(0, 1, s(a, be)), h = Me(),
                                u = Math.round(l + o * m), d = se, p = d.onStart, f = d.onInterrupt, g = d.onComplete,
                                v = i.tween;
                            if (h <= c && h >= l && u !== h) {
                                if (v && !v._initted && v.data <= Wa(u - h)) return;
                                !1 === se.inertia && (r = o - be.progress), i(u, {
                                    duration: D(Wa(.185 * Math.max(Wa(a - e), Wa(o - e)) / t / .05 || 0)),
                                    ease: se.ease || "power3",
                                    data: Wa(u - h),
                                    onInterrupt: function () {
                                        return N.restart(!0) && f && f(be)
                                    },
                                    onComplete: function () {
                                        be.update(), Ee = Me(), R = P = n && !de ? n.totalProgress() : be.progress, ie && ie(be), g && g(be)
                                    }
                                }, h, r * m, u - h - r * m), p && p(be, i.tween)
                            }
                        } else be.isActive && N.restart(!0)
                    })).pause()), X && (_o[X] = be), (H = (J = be.trigger = Bs(J || Z)) && J._gsap && J._gsap.stRevert) && (H = H(be)), Z = !0 === Z ? J : Bs(Z), Ba($) && ($ = {
                        targets: J,
                        className: $
                    }), Z && (!1 === Q || Q === Ja || (Q = !(!Q && "flex" === eo(Z.parentNode).display) && Ka), be.pin = Z, !1 !== t.force3D && Vs.set(Z, {force3D: !0}), (r = Vs.core.getCache(Z)).spacer ? g = r.pinState : (oe && ((oe = Bs(oe)) && !oe.nodeType && (oe = oe.current || oe.nativeElement), r.spacerIsNative = !!oe, oe && (r.spacerState = Go(oe))), r.spacer = y = oe || $s.createElement("div"), y.classList.add("pin-spacer"), X && y.classList.add("pin-spacer-" + X), r.pinState = g = Go(Z)), be.spacer = y = r.spacer, C = eo(Z), E = C[Q + ue.os2], b = Vs.getProperty(Z), w = Vs.quickSetter(Z, ue.a, Qa), Fo(Z, y, C), _ = Go(Z)), ye) {
                        f = Fa(ye) ? to(ye, ho) : ho, d = mo("scroller-start", X, pe, ue, f, 0), p = mo("scroller-end", X, pe, ue, f, 0, d), x = d["offset" + ue.op.d2];
                        var Ae = Bs(Ms(pe, "content") || pe);
                        h = this.markerStart = mo("start", X, Ae, ue, f, x, 0, le), u = this.markerEnd = mo("end", X, Ae, ue, f, x, 0, le), le && (F = Vs.quickSetter([h, u], ue.a, Qa)), ge || Ts.length && !0 === Ms(pe, "fixedMarkers") || (V = eo(G = me ? qs : pe).position, G.style.position = "absolute" === V || "fixed" === V ? V : "relative", Vs.set([d, p], {force3D: !0}), A = Vs.quickSetter(d, ue.a, Qa), L = Vs.quickSetter(p, ue.a, Qa))
                    }
                    if (le) {
                        var Le = le.vars.onUpdate, Ce = le.vars.onUpdateParams;
                        le.eventCallback("onUpdate", (function () {
                            be.update(0, 0, 1), Le && Le.apply(Ce || [])
                        }))
                    }
                    be.previous = function () {
                        return vo[vo.indexOf(be) - 1]
                    }, be.next = function () {
                        return vo[vo.indexOf(be) + 1]
                    }, be.revert = function (e) {
                        var t = !1 !== e || !be.enabled, i = ta;
                        t !== be.isReverted && (t && (be.scroll.rec || !ta || !ya || (be.scroll.rec = Me()), k = Math.max(Me(), be.scroll.rec || 0), B = be.progress, U = n && n.progress()), h && [h, u, d, p].forEach((function (e) {
                            return e.style.display = t ? "none" : "block"
                        })), t && (ta = 1), be.update(t), ta = i, Z && (t ? function (e, t, n) {
                            zo(n);
                            var i = e._gsap;
                            if (i.spacerIsNative) zo(i.spacerState); else if (e.parentNode === t) {
                                var r = t.parentNode;
                                r && (r.insertBefore(e, t), r.removeChild(t))
                            }
                        }(Z, y, g) : (!ae || !be.isActive) && Fo(Z, y, eo(Z), M)), be.isReverted = t)
                    }, be.refresh = function (i, r) {
                        if (!ta && be.enabled || r) if (Z && i && Sa) oo(e, "scrollEnd", Mo); else {
                            !ya && we && we(be), ta = 1, I && I.pause(), ee && n && n.time(-.01, !0).invalidate(), be.isReverted || be.revert();
                            for (var s, f, x, w, E, A, L, C, R, P, O = Te(), D = Se(), F = le ? le.duration() : Da(pe, ue), H = 0, z = 0, G = t.end, V = t.endTrigger || J, W = t.start || (0 !== t.start && J ? Z ? "0 0" : "0 100%" : 0), j = be.pinnedContainer = t.pinnedContainer && Bs(t.pinnedContainer), $ = J && Math.max(0, vo.indexOf(be)) || 0, X = $; X--;) (A = vo[X]).end || A.refresh(0, 1) || (ta = 1), !(L = A.pin) || L !== J && L !== Z || A.isReverted || (P || (P = []), P.unshift(A), A.revert()), A !== vo[X] && ($--, X--);
                            for (ka(W) && (W = W(be)), l = Wo(W, J, O, ue, Me(), h, d, be, D, xe, ge, F, le) || (Z ? -.001 : 0), ka(G) && (G = G(be)), Ba(G) && !G.indexOf("+=") && (~G.indexOf(" ") ? G = (Ba(W) ? W.split(" ")[0] : "") + G : (H = fo(G.substr(2), O), G = Ba(W) ? W : l + H, V = J)), c = Math.max(l, Wo(G || (V ? "100% 0" : F), V, O, ue, Me() + H, u, p, be, D, xe, ge, F, le)) || -.001, m = c - l || (l -= .01) && .001, H = 0, X = $; X--;) (L = (A = vo[X]).pin) && A.start - A._pinPush < l && !le && A.end > 0 && (s = A.end - A.start, L !== J && L !== j || Ua(W) || (H += s * (1 - A.progress)), L === Z && (z += s));
                            if (l += H, c += H, be._pinPush = z, h && H && ((s = {})[ue.a] = "+=" + H, j && (s[ue.p] = "-=" + Me()), Vs.set([h, u], s)), Z) s = eo(Z), w = ue === Ns, x = Me(), T = parseFloat(b(ue.a)) + z, !F && c > 1 && ((me ? qs : pe).style["overflow-" + ue.a] = "scroll"), Fo(Z, y, s), _ = Go(Z), f = no(Z, !0), C = ge && ks(pe, w ? Ds : Ns)(), Q && ((M = [Q + ue.os2, m + z + Qa]).t = y, (X = Q === Ka ? io(Z, ue) + m + z : 0) && M.push(ue.d, X + Qa), zo(M), ge && Me(k)), ge && ((E = {
                                top: f.top + (w ? x - l : C) + Qa,
                                left: f.left + (w ? C : x - l) + Qa,
                                boxSizing: "border-box",
                                position: "fixed"
                            }).width = E.maxWidth = Math.ceil(f.width) + Qa, E.height = E.maxHeight = Math.ceil(f.height) + Qa, E.margin = E.marginTop = E.marginRight = E.marginBottom = E.marginLeft = "0", E.padding = s.padding, E.paddingTop = s.paddingTop, E.paddingRight = s.paddingRight, E.paddingBottom = s.paddingBottom, E.paddingLeft = s.paddingLeft, v = function (e, t, n) {
                                for (var i, r = [], s = e.length, a = n ? 8 : 0; a < s; a += 2) i = e[a], r.push(i, i in t ? t[i] : e[a + 1]);
                                return r.t = e.t, r
                            }(g, E, ae)), n ? (R = n._initted, ca(1), n.render(n.duration(), !0, !0), S = b(ue.a) - T + m + z, m !== S && v.splice(v.length - 2, 2), n.render(0, !0, !0), R || n.invalidate(), ca(0)) : S = m; else if (J && Me() && !le) for (f = J.parentNode; f && f !== qs;) f._pinOffset && (l -= f._pinOffset, c -= f._pinOffset), f = f.parentNode;
                            P && P.forEach((function (e) {
                                return e.revert(!1)
                            })), be.start = l, be.end = c, a = o = Me(), le || (a < k && Me(k), be.scroll.rec = 0), be.revert(!1), N && be.isActive && Me(l + m * B), ta = 0, n && de && (n._initted || U) && n.progress() !== U && n.progress(U, !0).render(n.time(), !0, !0), (B !== be.progress || le) && (n && !de && n.totalProgress(B, !0), be.progress = B, be.update(0, 0, 1)), Z && Q && (y._pinOffset = Math.round(be.progress * S)), Y && Y(be)
                        }
                    }, be.getVelocity = function () {
                        return (Me() - o) / (wa() - Qs) * 1e3 || 0
                    }, be.endAnimation = function () {
                        Ga(be.callbackAnimation), n && (I ? I.progress(1) : n.paused() ? de || Ga(n, be.direction < 0, 1) : Ga(n, n.reversed()))
                    }, be.labelToScroll = function (e) {
                        return n && n.labels && (l || be.refresh() || l) + n.labels[e] / n.duration() * m || 0
                    }, be.getTrailing = function (e) {
                        var t = vo.indexOf(be), n = be.direction > 0 ? vo.slice(0, t).reverse() : vo.slice(t + 1);
                        return (Ba(e) ? n.filter((function (t) {
                            return t.vars.preventOverlaps === e
                        })) : n).filter((function (e) {
                            return be.direction > 0 ? e.end <= l : e.start >= c
                        }))
                    }, be.update = function (e, t, r) {
                        if (!le || r || e) {
                            var s, h, u, p, f, g, x, b = be.scroll(), M = e ? 0 : (b - l) / m,
                                C = M < 0 ? 0 : M > 1 ? 1 : M || 0, O = be.progress;
                            if (t && (o = a, a = le ? Me() : b, se && (P = R, R = n && !de ? n.totalProgress() : C)), te && !C && Z && !ta && !ba && Sa && l < b + (b - o) / (wa() - Qs) * te && (C = 1e-4), C !== O && be.enabled) {
                                if (p = (f = (s = be.isActive = !!C && C < 1) !== (!!O && O < 1)) || !!C != !!O, be.direction = C > O ? 1 : -1, be.progress = C, p && !ta && (h = C && !O ? 0 : 1 === C ? 1 : 1 === O ? 2 : 3, de && (u = !f && "none" !== _e[h + 1] && _e[h + 1] || _e[h], x = n && ("complete" === u || "reset" === u || u in n))), he && (f || x) && (x || K || !n) && (ka(he) ? he(be) : be.getTrailing(he).forEach((function (e) {
                                    return e.endAnimation()
                                }))), de || (!I || ta || ba ? n && n.totalProgress(C, !!ta) : ((le || xa && xa !== be) && I.render(I._dp._time - I._start), I.resetTo ? I.resetTo("totalProgress", C, n._tTime / n._tDur) : (I.vars.totalProgress = C, I.invalidate().restart()))), Z) if (e && Q && (y.style[Q + ue.os2] = E), ge) {
                                    if (p) {
                                        if (g = !e && C > O && c + 1 > b && b + 1 >= Da(pe, ue), ae) if (e || !s && !g) $o(Z, y); else {
                                            var D = no(Z, !0), B = b - l;
                                            $o(Z, qs, D.top + (ue === Ns ? B : 0) + Qa, D.left + (ue === Ns ? 0 : B) + Qa)
                                        }
                                        zo(s || g ? v : _), S !== m && C < 1 && s || w(T + (1 !== C || g ? 0 : S))
                                    }
                                } else w(Ca(T + S * C));
                                se && !i.tween && !ta && !ba && N.restart(!0), $ && (f || re && C && (C < 1 || !ma)) && Js($.targets).forEach((function (e) {
                                    return e.classList[s || re ? "add" : "remove"]($.className)
                                })), j && !de && !e && j(be), p && !ta ? (de && (x && ("complete" === u ? n.pause().totalProgress(1) : "reset" === u ? n.restart(!0).pause() : "restart" === u ? n.restart(!0) : n[u]()), j && j(be)), !f && ma || (q && f && Va(be, q), ve[h] && Va(be, ve[h]), re && (1 === C ? be.kill(!1, 1) : ve[h] = 0), f || ve[h = 1 === C ? 1 : 3] && Va(be, ve[h])), ce && !s && Math.abs(be.getVelocity()) > (Ua(ce) ? ce : 2500) && (Ga(be.callbackAnimation), I ? I.progress(1) : Ga(n, !C, 1))) : de && j && !ta && j(be)
                            }
                            if (L) {
                                var k = le ? b / le.duration() * (le._caScrollDist || 0) : b;
                                A(k + (d._isFlipped ? 1 : 0)), L(k)
                            }
                            F && F(-b / le.duration() * (le._caScrollDist || 0))
                        }
                    }, be.enable = function (t, n) {
                        be.enabled || (be.enabled = !0, oo(pe, "resize", bo), oo(me ? $s : pe, "scroll", xo), we && oo(e, "refreshInit", we), !1 !== t && (be.progress = B = 0, a = o = Ee = Me()), !1 !== n && be.refresh())
                    }, be.getTween = function (e) {
                        return e && i ? i.tween : I
                    }, be.setPositions = function (e, t) {
                        Z && (T += e - l, S += t - e - m), be.start = l = e, be.end = c = t, m = t - e, be.update()
                    }, be.disable = function (t, n) {
                        if (be.enabled && (!1 !== t && be.revert(), be.enabled = be.isActive = !1, n || I && I.pause(), k = 0, r && (r.uncache = 1), we && lo(e, "refreshInit", we), N && (N.pause(), i.tween && i.tween.kill() && (i.tween = 0)), !me)) {
                            for (var s = vo.length; s--;) if (vo[s].scroller === pe && vo[s] !== be) return;
                            lo(pe, "resize", bo), lo(pe, "scroll", xo)
                        }
                    }, be.kill = function (e, i) {
                        be.disable(e, i), I && !i && I.kill(), X && delete _o[X];
                        var s = vo.indexOf(be);
                        s >= 0 && vo.splice(s, 1), s === ra && No > 0 && ra--, s = 0, vo.forEach((function (e) {
                            return e.scroller === be.scroller && (s = 1)
                        })), s || (be.scroll.rec = 0), n && (n.scrollTrigger = null, e && n.render(-1), i || n.kill()), h && [h, u, d, p].forEach((function (e) {
                            return e.parentNode && e.parentNode.removeChild(e)
                        })), Z && (r && (r.uncache = 1), s = 0, vo.forEach((function (e) {
                            return e.pin === Z && s++
                        })), s || (r.spacer = 0)), t.onKill && t.onKill(be)
                    }, be.enable(!1, !1), H && H(be), n && n.add && !m ? Vs.delayedCall(.01, (function () {
                        return l || c || be.refresh()
                    })) && (m = .01) && (l = c = 0) : be.refresh()
                } else this.update = this.refresh = this.kill = La
            }, e.register = function (t) {
                return Ws || (Vs = t || Pa(), Ra() && window.document && e.enable(), Ws = Ea), Ws
            }, e.defaults = function (e) {
                if (e) for (var t in e) uo[t] = e[t];
                return uo
            }, e.disable = function (e, t) {
                Ea = 0, vo.forEach((function (n) {
                    return n[t ? "kill" : "disable"](e)
                })), lo(js, "wheel", xo), lo($s, "scroll", xo), clearInterval(ea), lo($s, "touchcancel", La), lo(qs, "touchstart", La), ao(lo, $s, "pointerdown,touchstart,mousedown", Ma), ao(lo, $s, "pointerup,touchend,mouseup", Aa), Ks.kill(), Na(lo);
                for (var n = 0; n < ws.length; n += 3) co(lo, ws[n], ws[n + 1]), co(lo, ws[n], ws[n + 2])
            }, e.enable = function () {
                if (js = window, $s = document, Xs = $s.documentElement, qs = $s.body, Vs && (Js = Vs.utils.toArray, Zs = Vs.utils.clamp, ca = Vs.core.suppressOverwrites || La, Vs.core.globals("ScrollTrigger", e), qs)) {
                    Ea = 1, e.isTouch = js.matchMedia && js.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in js || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Ys = [js, $s, Xs, qs], pa = js.innerHeight, fa = js.innerWidth, Gs.register(Vs), oo($s, "scroll", xo);
                    var t, n, i = qs.style, r = i.borderTopStyle;
                    for (i.borderTopStyle = "solid", t = no(qs), Ns.m = Math.round(t.top + Ns.sc()) || 0, Ds.m = Math.round(t.left + Ds.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), ea = setInterval(yo, 250), Vs.delayedCall(.5, (function () {
                        return ba = 0
                    })), oo($s, "touchcancel", La), oo(qs, "touchstart", La), ao(oo, $s, "pointerdown,touchstart,mousedown", Ma), ao(oo, $s, "pointerup,touchend,mouseup", Aa), ia = Vs.utils.checkPrefix("transform"), Uo.push(ia), Ws = wa(), Ks = Vs.delayedCall(.2, Oo).pause(), oa = [$s, "visibilitychange", function () {
                        var e = js.innerWidth, t = js.innerHeight;
                        $s.hidden ? (sa = e, aa = t) : sa === e && aa === t || bo()
                    }, $s, "DOMContentLoaded", Oo, js, "load", Oo, js, "resize", bo], Na(oo), vo.forEach((function (e) {
                        return e.enable(0, 1)
                    })), n = 0; n < ws.length; n += 3) co(lo, ws[n], ws[n + 1]), co(lo, ws[n], ws[n + 2])
                }
            }, e.config = function (t) {
                "limitCallbacks" in t && (ma = !!t.limitCallbacks);
                var n = t.syncInterval;
                n && clearInterval(ea) || (ea = n) && setInterval(yo, n), "ignoreMobileResize" in t && (da = 1 === e.isTouch && t.ignoreMobileResize), "autoRefreshEvents" in t && (Na(lo) || Na(oo, t.autoRefreshEvents || "none"), ha = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
            }, e.scrollerProxy = function (e, t) {
                var n = Bs(e), i = ws.indexOf(n), r = Ia(n);
                ~i && ws.splice(i, r ? 6 : 2), t && (r ? Ts.unshift(js, t, qs, t, Xs, t) : Ts.unshift(n, t))
            }, e.matchMedia = function (e) {
                var t, n, i, r, s;
                for (n in e) i = So.indexOf(n), r = e[n], va = n, "all" === n ? r() : (t = js.matchMedia(n)) && (t.matches && (s = r()), ~i ? (So[i + 1] = za(So[i + 1], r), So[i + 2] = za(So[i + 2], s)) : (i = So.length, So.push(n, r, s), t.addListener ? t.addListener(Eo) : t.addEventListener("change", Eo)), So[i + 3] = t.matches), va = 0;
                return So
            }, e.clearMatchMedia = function (e) {
                e || (So.length = 0), (e = So.indexOf(e)) >= 0 && So.splice(e, 4)
            }, e.isInViewport = function (e, t, n) {
                var i = (Ba(e) ? Bs(e) : e).getBoundingClientRect(), r = i[n ? qa : Ya] * t || 0;
                return n ? i.right - r > 0 && i.left + r < js.innerWidth : i.bottom - r > 0 && i.top + r < js.innerHeight
            }, e.positionInViewport = function (e, t, n) {
                Ba(e) && (e = Bs(e));
                var i = e.getBoundingClientRect(), r = i[n ? qa : Ya],
                    s = null == t ? r / 2 : t in po ? po[t] * r : ~t.indexOf("%") ? parseFloat(t) * r / 100 : parseFloat(t) || 0;
                return n ? (i.left + s) / js.innerWidth : (i.top + s) / js.innerHeight
            }, e
        }();
    qo.version = "3.10.1", qo.saveStyles = function (e) {
        return e ? Js(e).forEach((function (e) {
            if (e && e.style) {
                var t = Lo.indexOf(e);
                t >= 0 && Lo.splice(t, 5), Lo.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Vs.core.getCache(e), va)
            }
        })) : Lo
    }, qo.revert = function (e, t) {
        return Ro(!e, t)
    }, qo.create = function (e, t) {
        return new qo(e, t)
    }, qo.refresh = function (e) {
        return e ? bo() : (Ws || qo.register()) && Oo(!0)
    }, qo.update = Bo, qo.clearScrollMemory = Po, qo.maxScroll = function (e, t) {
        return Da(e, t ? Ds : Ns)
    }, qo.getScrollFunc = function (e, t) {
        return ks(Bs(e), t ? Ds : Ns)
    }, qo.getById = function (e) {
        return _o[e]
    }, qo.getAll = function () {
        return vo.filter((function (e) {
            return "ScrollSmoother" !== e.vars.id
        }))
    }, qo.isScrolling = function () {
        return !!Sa
    }, qo.snapDirectional = so, qo.addEventListener = function (e, t) {
        var n = wo[e] || (wo[e] = []);
        ~n.indexOf(t) || n.push(t)
    }, qo.removeEventListener = function (e, t) {
        var n = wo[e], i = n && n.indexOf(t);
        i >= 0 && n.splice(i, 1)
    }, qo.batch = function (e, t) {
        var n, i = [], r = {}, s = t.interval || .016, a = t.batchMax || 1e9, o = function (e, t) {
            var n = [], i = [], r = Vs.delayedCall(s, (function () {
                t(n, i), n = [], i = []
            })).pause();
            return function (e) {
                n.length || r.restart(!0), n.push(e.trigger), i.push(e), a <= n.length && r.progress(1)
            }
        };
        for (n in t) r[n] = "on" === n.substr(0, 2) && ka(t[n]) && "onRefreshInit" !== n ? o(0, t[n]) : t[n];
        return ka(a) && (a = a(), oo(qo, "refresh", (function () {
            return a = t.batchMax()
        }))), Js(e).forEach((function (e) {
            var t = {};
            for (n in r) t[n] = r[n];
            t.trigger = e, i.push(qo.create(t))
        })), i
    };
    var Yo = function (e, t, n, i) {
        return t > i ? e(i) : t < 0 && e(0), n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1
    }, Ko = function (e) {
        !0 === e ? (qs.style.removeProperty("touch-action"), Xs.style.removeProperty("touch-action")) : qs.style.touchAction = Xs.style.touchAction = e ? "pan-" + e : "none"
    }, Jo = function (e) {
        Fa(e) || (e = {}), e.preventDefault = e.isNormalizer = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
        var t, n, i, r, s, a, o, l, c, h = e, u = h.normalizeScrollX, d = h.momentum, p = 0, f = ks(Xs, Ns),
            m = ks(Xs, Ds), g = 1, v = ka(d) ? function () {
                return d(t)
            } : function () {
                return d || 2.8
            }, _ = function () {
                return p = wa()
            }, y = function () {
                return i = !1
            }, x = La, b = La, w = function () {
                n = Da(Xs, Ns), b = Zs(0, n), u && (x = Zs(0, Da(Xs, Ds))), r = Io
            }, T = qo.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), S = function () {
                w(), s.isActive() && s.vars.scrollY > n && s.resetTo("scrollY", Da(Xs, Ns))
            };
        return e.ignoreCheck = function (e) {
            return T && "touchmove" === e.type && function () {
                if (i) return requestAnimationFrame(y), !0;
                i = !0
            }() || g > 1 || t.isGesturing || e.touches && e.touches.length > 1
        }, e.onPress = function () {
            var e = g;
            g = js.visualViewport && js.visualViewport.scale || 1, s.pause(), e !== g && Ko(g > 1 || !u && "x"), i = !1, a = m(), o = f(), w(), r = Io
        }, e.onRelease = e.onGestureStart = function (e, t) {
            var n = e.event, i = n.changedTouches ? n.changedTouches[0] : n;
            if (!t || Math.abs(e.x - e.startX) <= 3 && Math.abs(e.y - e.startY) <= 3) Vs.delayedCall(.05, (function () {
                if (wa() - p > 300 && !n.defaultPrevented) if (n.target.click) n.target.click(); else if (l.createEvent) {
                    var e = l.createEvent("MouseEvents");
                    e.initMouseEvent("click", !0, !0, js, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(e)
                }
            })), c.restart(!0); else {
                var r, a, o = v();
                u && (a = (r = m()) + .05 * o * -e.velocityX / .227 / g, o *= Yo(m, r, a, Da(Xs, Ds)), s.vars.scrollX = x(a)), a = (r = f()) + .05 * o * -e.velocityY / .227 / g, o *= Yo(f, r, a, Da(Xs, Ns)), s.vars.scrollY = b(a), s.invalidate().duration(o).play(.01)
            }
        }, e.onWheel = function () {
            return s._ts && s.pause()
        }, e.onChange = function (e, t, n, i, s) {
            Io !== r && w(), t && u && m(x(i[2] === t ? a + (e.startX - e.x) / g : m() + t - i[1])), n && f(b(s[2] === n ? o + (e.startY - e.y) / g : f() + n - s[1])), Bo()
        }, e.onEnable = function (e) {
            Ko(!u && "x"), oo(js, "resize", S), e.target.addEventListener("click", _, {capture: !0})
        }, e.onDisable = function (e) {
            Ko(!0), lo(js, "resize", S), lo(e.target, "click", _)
        }, t = new Gs(e), l = t.target.ownerDocument || $s, c = t._dc, s = Vs.to(t, {
            ease: "power4",
            paused: !0,
            scrollX: u ? "+=0.1" : "+=0",
            scrollY: "+=0.1",
            onComplete: c.vars.onComplete
        }), t
    };

    function Zo(e) {
        return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
    }

    function Qo(e = {}, t = {}) {
        Object.keys(t).forEach((n => {
            void 0 === e[n] ? e[n] = t[n] : Zo(t[n]) && Zo(e[n]) && Object.keys(t[n]).length > 0 && Qo(e[n], t[n])
        }))
    }

    qo.sort = function (e) {
        return vo.sort(e || function (e, t) {
            return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0))
        })
    }, qo.observe = function (e) {
        return new Gs(e)
    }, qo.normalizeScroll = function (e) {
        if (void 0 === e) return ua;
        if (!0 === e && ua) return ua.enable();
        var t = e instanceof Gs;
        return ua && (!1 === e || t && e !== ua) && ua.kill(), e && !t && (e = Jo(e)), ua = e && e.enable()
    }, qo.core = {
        _getVelocityProp: Us, _scrollers: ws, _proxies: Ts, bridge: {
            ss: function () {
                Sa || Ao("scrollStart"), Sa = wa()
            }, ref: function () {
                return ta
            }
        }
    }, Pa() && Vs.registerPlugin(qo);
    const el = {
        body: {},
        addEventListener() {
        },
        removeEventListener() {
        },
        activeElement: {
            blur() {
            }, nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {
            }
        }),
        createElement: () => ({
            children: [], childNodes: [], style: {}, setAttribute() {
            }, getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: ""}
    };

    function tl() {
        const e = "undefined" != typeof document ? document : {};
        return Qo(e, el), e
    }

    const nl = {
        document: el,
        navigator: {userAgent: ""},
        location: {hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: ""},
        history: {
            replaceState() {
            }, pushState() {
            }, go() {
            }, back() {
            }
        },
        CustomEvent: function () {
            return this
        },
        addEventListener() {
        },
        removeEventListener() {
        },
        getComputedStyle: () => ({getPropertyValue: () => ""}),
        Image() {
        },
        Date() {
        },
        screen: {},
        setTimeout() {
        },
        clearTimeout() {
        },
        matchMedia: () => ({}),
        requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
            "undefined" != typeof setTimeout && clearTimeout(e)
        }
    };

    function il() {
        const e = "undefined" != typeof window ? window : {};
        return Qo(e, nl), e
    }

    class rl extends Array {
        constructor(e) {
            super(...e || []), function (e) {
                const t = e.__proto__;
                Object.defineProperty(e, "__proto__", {
                    get: () => t, set(e) {
                        t.__proto__ = e
                    }
                })
            }(this)
        }
    }

    function sl(e = []) {
        const t = [];
        return e.forEach((e => {
            Array.isArray(e) ? t.push(...sl(e)) : t.push(e)
        })), t
    }

    function al(e, t) {
        return Array.prototype.filter.call(e, t)
    }

    function ol(e, t) {
        const n = il(), i = tl();
        let r = [];
        if (!t && e instanceof rl) return e;
        if (!e) return new rl(r);
        if ("string" == typeof e) {
            const n = e.trim();
            if (n.indexOf("<") >= 0 && n.indexOf(">") >= 0) {
                let e = "div";
                0 === n.indexOf("<li") && (e = "ul"), 0 === n.indexOf("<tr") && (e = "tbody"), 0 !== n.indexOf("<td") && 0 !== n.indexOf("<th") || (e = "tr"), 0 === n.indexOf("<tbody") && (e = "table"), 0 === n.indexOf("<option") && (e = "select");
                const t = i.createElement(e);
                t.innerHTML = n;
                for (let e = 0; e < t.childNodes.length; e += 1) r.push(t.childNodes[e])
            } else r = function (e, t) {
                if ("string" != typeof e) return [e];
                const n = [], i = t.querySelectorAll(e);
                for (let e = 0; e < i.length; e += 1) n.push(i[e]);
                return n
            }(e.trim(), t || i)
        } else if (e.nodeType || e === n || e === i) r.push(e); else if (Array.isArray(e)) {
            if (e instanceof rl) return e;
            r = e
        }
        return new rl(function (e) {
            const t = [];
            for (let n = 0; n < e.length; n += 1) -1 === t.indexOf(e[n]) && t.push(e[n]);
            return t
        }(r))
    }

    ol.fn = rl.prototype;
    const ll = {
        addClass: function (...e) {
            const t = sl(e.map((e => e.split(" "))));
            return this.forEach((e => {
                e.classList.add(...t)
            })), this
        }, removeClass: function (...e) {
            const t = sl(e.map((e => e.split(" "))));
            return this.forEach((e => {
                e.classList.remove(...t)
            })), this
        }, hasClass: function (...e) {
            const t = sl(e.map((e => e.split(" "))));
            return al(this, (e => t.filter((t => e.classList.contains(t))).length > 0)).length > 0
        }, toggleClass: function (...e) {
            const t = sl(e.map((e => e.split(" "))));
            this.forEach((e => {
                t.forEach((t => {
                    e.classList.toggle(t)
                }))
            }))
        }, attr: function (e, t) {
            if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;
            for (let n = 0; n < this.length; n += 1) if (2 === arguments.length) this[n].setAttribute(e, t); else for (const t in e) this[n][t] = e[t], this[n].setAttribute(t, e[t]);
            return this
        }, removeAttr: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
            return this
        }, transform: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].style.transform = e;
            return this
        }, transition: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e;
            return this
        }, on: function (...e) {
            let [t, n, i, r] = e;

            function s(e) {
                const t = e.target;
                if (!t) return;
                const r = e.target.dom7EventData || [];
                if (r.indexOf(e) < 0 && r.unshift(e), ol(t).is(n)) i.apply(t, r); else {
                    const e = ol(t).parents();
                    for (let t = 0; t < e.length; t += 1) ol(e[t]).is(n) && i.apply(e[t], r)
                }
            }

            function a(e) {
                const t = e && e.target && e.target.dom7EventData || [];
                t.indexOf(e) < 0 && t.unshift(e), i.apply(this, t)
            }

            "function" == typeof e[1] && ([t, i, r] = e, n = void 0), r || (r = !1);
            const o = t.split(" ");
            let l;
            for (let e = 0; e < this.length; e += 1) {
                const t = this[e];
                if (n) for (l = 0; l < o.length; l += 1) {
                    const e = o[l];
                    t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({
                        listener: i,
                        proxyListener: s
                    }), t.addEventListener(e, s, r)
                } else for (l = 0; l < o.length; l += 1) {
                    const e = o[l];
                    t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({
                        listener: i,
                        proxyListener: a
                    }), t.addEventListener(e, a, r)
                }
            }
            return this
        }, off: function (...e) {
            let [t, n, i, r] = e;
            "function" == typeof e[1] && ([t, i, r] = e, n = void 0), r || (r = !1);
            const s = t.split(" ");
            for (let e = 0; e < s.length; e += 1) {
                const t = s[e];
                for (let e = 0; e < this.length; e += 1) {
                    const s = this[e];
                    let a;
                    if (!n && s.dom7Listeners ? a = s.dom7Listeners[t] : n && s.dom7LiveListeners && (a = s.dom7LiveListeners[t]), a && a.length) for (let e = a.length - 1; e >= 0; e -= 1) {
                        const n = a[e];
                        i && n.listener === i || i && n.listener && n.listener.dom7proxy && n.listener.dom7proxy === i ? (s.removeEventListener(t, n.proxyListener, r), a.splice(e, 1)) : i || (s.removeEventListener(t, n.proxyListener, r), a.splice(e, 1))
                    }
                }
            }
            return this
        }, trigger: function (...e) {
            const t = il(), n = e[0].split(" "), i = e[1];
            for (let r = 0; r < n.length; r += 1) {
                const s = n[r];
                for (let n = 0; n < this.length; n += 1) {
                    const r = this[n];
                    if (t.CustomEvent) {
                        const n = new t.CustomEvent(s, {detail: i, bubbles: !0, cancelable: !0});
                        r.dom7EventData = e.filter(((e, t) => t > 0)), r.dispatchEvent(n), r.dom7EventData = [], delete r.dom7EventData
                    }
                }
            }
            return this
        }, transitionEnd: function (e) {
            const t = this;
            return e && t.on("transitionend", (function n(i) {
                i.target === this && (e.call(this, i), t.off("transitionend", n))
            })), this
        }, outerWidth: function (e) {
            if (this.length > 0) {
                if (e) {
                    const e = this.styles();
                    return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
                }
                return this[0].offsetWidth
            }
            return null
        }, outerHeight: function (e) {
            if (this.length > 0) {
                if (e) {
                    const e = this.styles();
                    return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
                }
                return this[0].offsetHeight
            }
            return null
        }, styles: function () {
            const e = il();
            return this[0] ? e.getComputedStyle(this[0], null) : {}
        }, offset: function () {
            if (this.length > 0) {
                const e = il(), t = tl(), n = this[0], i = n.getBoundingClientRect(), r = t.body,
                    s = n.clientTop || r.clientTop || 0, a = n.clientLeft || r.clientLeft || 0,
                    o = n === e ? e.scrollY : n.scrollTop, l = n === e ? e.scrollX : n.scrollLeft;
                return {top: i.top + o - s, left: i.left + l - a}
            }
            return null
        }, css: function (e, t) {
            const n = il();
            let i;
            if (1 === arguments.length) {
                if ("string" != typeof e) {
                    for (i = 0; i < this.length; i += 1) for (const t in e) this[i].style[t] = e[t];
                    return this
                }
                if (this[0]) return n.getComputedStyle(this[0], null).getPropertyValue(e)
            }
            if (2 === arguments.length && "string" == typeof e) {
                for (i = 0; i < this.length; i += 1) this[i].style[e] = t;
                return this
            }
            return this
        }, each: function (e) {
            return e ? (this.forEach(((t, n) => {
                e.apply(t, [t, n])
            })), this) : this
        }, html: function (e) {
            if (void 0 === e) return this[0] ? this[0].innerHTML : null;
            for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;
            return this
        }, text: function (e) {
            if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
            for (let t = 0; t < this.length; t += 1) this[t].textContent = e;
            return this
        }, is: function (e) {
            const t = il(), n = tl(), i = this[0];
            let r, s;
            if (!i || void 0 === e) return !1;
            if ("string" == typeof e) {
                if (i.matches) return i.matches(e);
                if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e);
                if (i.msMatchesSelector) return i.msMatchesSelector(e);
                for (r = ol(e), s = 0; s < r.length; s += 1) if (r[s] === i) return !0;
                return !1
            }
            if (e === n) return i === n;
            if (e === t) return i === t;
            if (e.nodeType || e instanceof rl) {
                for (r = e.nodeType ? [e] : e, s = 0; s < r.length; s += 1) if (r[s] === i) return !0;
                return !1
            }
            return !1
        }, index: function () {
            let e, t = this[0];
            if (t) {
                for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1);
                return e
            }
        }, eq: function (e) {
            if (void 0 === e) return this;
            const t = this.length;
            if (e > t - 1) return ol([]);
            if (e < 0) {
                const n = t + e;
                return ol(n < 0 ? [] : [this[n]])
            }
            return ol([this[e]])
        }, append: function (...e) {
            let t;
            const n = tl();
            for (let i = 0; i < e.length; i += 1) {
                t = e[i];
                for (let e = 0; e < this.length; e += 1) if ("string" == typeof t) {
                    const i = n.createElement("div");
                    for (i.innerHTML = t; i.firstChild;) this[e].appendChild(i.firstChild)
                } else if (t instanceof rl) for (let n = 0; n < t.length; n += 1) this[e].appendChild(t[n]); else this[e].appendChild(t)
            }
            return this
        }, prepend: function (e) {
            const t = tl();
            let n, i;
            for (n = 0; n < this.length; n += 1) if ("string" == typeof e) {
                const r = t.createElement("div");
                for (r.innerHTML = e, i = r.childNodes.length - 1; i >= 0; i -= 1) this[n].insertBefore(r.childNodes[i], this[n].childNodes[0])
            } else if (e instanceof rl) for (i = 0; i < e.length; i += 1) this[n].insertBefore(e[i], this[n].childNodes[0]); else this[n].insertBefore(e, this[n].childNodes[0]);
            return this
        }, next: function (e) {
            return this.length > 0 ? e ? this[0].nextElementSibling && ol(this[0].nextElementSibling).is(e) ? ol([this[0].nextElementSibling]) : ol([]) : this[0].nextElementSibling ? ol([this[0].nextElementSibling]) : ol([]) : ol([])
        }, nextAll: function (e) {
            const t = [];
            let n = this[0];
            if (!n) return ol([]);
            for (; n.nextElementSibling;) {
                const i = n.nextElementSibling;
                e ? ol(i).is(e) && t.push(i) : t.push(i), n = i
            }
            return ol(t)
        }, prev: function (e) {
            if (this.length > 0) {
                const t = this[0];
                return e ? t.previousElementSibling && ol(t.previousElementSibling).is(e) ? ol([t.previousElementSibling]) : ol([]) : t.previousElementSibling ? ol([t.previousElementSibling]) : ol([])
            }
            return ol([])
        }, prevAll: function (e) {
            const t = [];
            let n = this[0];
            if (!n) return ol([]);
            for (; n.previousElementSibling;) {
                const i = n.previousElementSibling;
                e ? ol(i).is(e) && t.push(i) : t.push(i), n = i
            }
            return ol(t)
        }, parent: function (e) {
            const t = [];
            for (let n = 0; n < this.length; n += 1) null !== this[n].parentNode && (e ? ol(this[n].parentNode).is(e) && t.push(this[n].parentNode) : t.push(this[n].parentNode));
            return ol(t)
        }, parents: function (e) {
            const t = [];
            for (let n = 0; n < this.length; n += 1) {
                let i = this[n].parentNode;
                for (; i;) e ? ol(i).is(e) && t.push(i) : t.push(i), i = i.parentNode
            }
            return ol(t)
        }, closest: function (e) {
            let t = this;
            return void 0 === e ? ol([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
        }, find: function (e) {
            const t = [];
            for (let n = 0; n < this.length; n += 1) {
                const i = this[n].querySelectorAll(e);
                for (let e = 0; e < i.length; e += 1) t.push(i[e])
            }
            return ol(t)
        }, children: function (e) {
            const t = [];
            for (let n = 0; n < this.length; n += 1) {
                const i = this[n].children;
                for (let n = 0; n < i.length; n += 1) e && !ol(i[n]).is(e) || t.push(i[n])
            }
            return ol(t)
        }, filter: function (e) {
            return ol(al(this, e))
        }, remove: function () {
            for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);
            return this
        }
    };

    function cl(e, t = 0) {
        return setTimeout(e, t)
    }

    function hl() {
        return Date.now()
    }

    function ul(e, t = "x") {
        const n = il();
        let i, r, s;
        const a = function (e) {
            const t = il();
            let n;
            return t.getComputedStyle && (n = t.getComputedStyle(e, null)), !n && e.currentStyle && (n = e.currentStyle), n || (n = e.style), n
        }(e);
        return n.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map((e => e.replace(",", "."))).join(", ")), s = new n.WebKitCSSMatrix("none" === r ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = s.toString().split(",")), "x" === t && (r = n.WebKitCSSMatrix ? s.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (r = n.WebKitCSSMatrix ? s.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), r || 0
    }

    function dl(e) {
        return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
    }

    function pl(...e) {
        const t = Object(e[0]), n = ["__proto__", "constructor", "prototype"];
        for (let r = 1; r < e.length; r += 1) {
            const s = e[r];
            if (null != s && (i = s, !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) {
                const e = Object.keys(Object(s)).filter((e => n.indexOf(e) < 0));
                for (let n = 0, i = e.length; n < i; n += 1) {
                    const i = e[n], r = Object.getOwnPropertyDescriptor(s, i);
                    void 0 !== r && r.enumerable && (dl(t[i]) && dl(s[i]) ? s[i].__swiper__ ? t[i] = s[i] : pl(t[i], s[i]) : !dl(t[i]) && dl(s[i]) ? (t[i] = {}, s[i].__swiper__ ? t[i] = s[i] : pl(t[i], s[i])) : t[i] = s[i])
                }
            }
        }
        var i;
        return t
    }

    function fl(e, t, n) {
        e.style.setProperty(t, n)
    }

    function ml({swiper: e, targetPosition: t, side: n}) {
        const i = il(), r = -e.translate;
        let s, a = null;
        const o = e.params.speed;
        e.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(e.cssModeFrameID);
        const l = t > r ? "next" : "prev", c = (e, t) => "next" === l && e >= t || "prev" === l && e <= t, h = () => {
            s = (new Date).getTime(), null === a && (a = s);
            const l = Math.max(Math.min((s - a) / o, 1), 0), u = .5 - Math.cos(l * Math.PI) / 2;
            let d = r + u * (t - r);
            if (c(d, t) && (d = t), e.wrapperEl.scrollTo({[n]: d}), c(d, t)) return e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
                e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({[n]: d})
            })), void i.cancelAnimationFrame(e.cssModeFrameID);
            e.cssModeFrameID = i.requestAnimationFrame(h)
        };
        h()
    }

    let gl, vl, _l;

    function yl() {
        return gl || (gl = function () {
            const e = il(), t = tl();
            return {
                smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style,
                touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch),
                passiveListener: function () {
                    let t = !1;
                    try {
                        const n = Object.defineProperty({}, "passive", {
                            get() {
                                t = !0
                            }
                        });
                        e.addEventListener("testPassiveListener", null, n)
                    } catch (e) {
                    }
                    return t
                }(),
                gestures: "ongesturestart" in e
            }
        }()), gl
    }

    function xl(e = {}) {
        return vl || (vl = function ({userAgent: e} = {}) {
            const t = yl(), n = il(), i = n.navigator.platform, r = e || n.navigator.userAgent,
                s = {ios: !1, android: !1}, a = n.screen.width, o = n.screen.height,
                l = r.match(/(Android);?[\s\/]+([\d.]+)?/);
            let c = r.match(/(iPad).*OS\s([\d_]+)/);
            const h = r.match(/(iPod)(.*OS\s([\d_]+))?/), u = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                d = "Win32" === i;
            let p = "MacIntel" === i;
            return !c && p && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${a}x${o}`) >= 0 && (c = r.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), p = !1), l && !d && (s.os = "android", s.android = !0), (c || u || h) && (s.os = "ios", s.ios = !0), s
        }(e)), vl
    }

    function bl() {
        return _l || (_l = function () {
            const e = il();
            return {
                isSafari: function () {
                    const t = e.navigator.userAgent.toLowerCase();
                    return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
                }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
            }
        }()), _l
    }

    Object.keys(ll).forEach((e => {
        Object.defineProperty(ol.fn, e, {value: ll[e], writable: !0})
    }));
    var wl = {
        on(e, t, n) {
            const i = this;
            if ("function" != typeof t) return i;
            const r = n ? "unshift" : "push";
            return e.split(" ").forEach((e => {
                i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][r](t)
            })), i
        }, once(e, t, n) {
            const i = this;
            if ("function" != typeof t) return i;

            function r(...n) {
                i.off(e, r), r.__emitterProxy && delete r.__emitterProxy, t.apply(i, n)
            }

            return r.__emitterProxy = t, i.on(e, r, n)
        }, onAny(e, t) {
            const n = this;
            if ("function" != typeof e) return n;
            const i = t ? "unshift" : "push";
            return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[i](e), n
        }, offAny(e) {
            const t = this;
            if (!t.eventsAnyListeners) return t;
            const n = t.eventsAnyListeners.indexOf(e);
            return n >= 0 && t.eventsAnyListeners.splice(n, 1), t
        }, off(e, t) {
            const n = this;
            return n.eventsListeners ? (e.split(" ").forEach((e => {
                void 0 === t ? n.eventsListeners[e] = [] : n.eventsListeners[e] && n.eventsListeners[e].forEach(((i, r) => {
                    (i === t || i.__emitterProxy && i.__emitterProxy === t) && n.eventsListeners[e].splice(r, 1)
                }))
            })), n) : n
        }, emit(...e) {
            const t = this;
            if (!t.eventsListeners) return t;
            let n, i, r;
            "string" == typeof e[0] || Array.isArray(e[0]) ? (n = e[0], i = e.slice(1, e.length), r = t) : (n = e[0].events, i = e[0].data, r = e[0].context || t), i.unshift(r);
            return (Array.isArray(n) ? n : n.split(" ")).forEach((e => {
                t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((t => {
                    t.apply(r, [e, ...i])
                })), t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach((e => {
                    e.apply(r, i)
                }))
            })), t
        }
    };
    var Tl = {
        updateSize: function () {
            const e = this;
            let t, n;
            const i = e.$el;
            t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : i[0].clientWidth, n = void 0 !== e.params.height && null !== e.params.height ? e.params.height : i[0].clientHeight, 0 === t && e.isHorizontal() || 0 === n && e.isVertical() || (t = t - parseInt(i.css("padding-left") || 0, 10) - parseInt(i.css("padding-right") || 0, 10), n = n - parseInt(i.css("padding-top") || 0, 10) - parseInt(i.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(n) && (n = 0), Object.assign(e, {
                width: t,
                height: n,
                size: e.isHorizontal() ? t : n
            }))
        }, updateSlides: function () {
            const e = this;

            function t(t) {
                return e.isHorizontal() ? t : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[t]
            }

            function n(e, n) {
                return parseFloat(e.getPropertyValue(t(n)) || 0)
            }

            const i = e.params, {$wrapperEl: r, size: s, rtlTranslate: a, wrongRTL: o} = e,
                l = e.virtual && i.virtual.enabled, c = l ? e.virtual.slides.length : e.slides.length,
                h = r.children(`.${e.params.slideClass}`), u = l ? e.virtual.slides.length : h.length;
            let d = [];
            const p = [], f = [];
            let m = i.slidesOffsetBefore;
            "function" == typeof m && (m = i.slidesOffsetBefore.call(e));
            let g = i.slidesOffsetAfter;
            "function" == typeof g && (g = i.slidesOffsetAfter.call(e));
            const v = e.snapGrid.length, _ = e.slidesGrid.length;
            let y = i.spaceBetween, x = -m, b = 0, w = 0;
            if (void 0 === s) return;
            "string" == typeof y && y.indexOf("%") >= 0 && (y = parseFloat(y.replace("%", "")) / 100 * s), e.virtualSize = -y, a ? h.css({
                marginLeft: "",
                marginBottom: "",
                marginTop: ""
            }) : h.css({
                marginRight: "",
                marginBottom: "",
                marginTop: ""
            }), i.centeredSlides && i.cssMode && (fl(e.wrapperEl, "--swiper-centered-offset-before", ""), fl(e.wrapperEl, "--swiper-centered-offset-after", ""));
            const T = i.grid && i.grid.rows > 1 && e.grid;
            let S;
            T && e.grid.initSlides(u);
            const E = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e => void 0 !== i.breakpoints[e].slidesPerView)).length > 0;
            for (let r = 0; r < u; r += 1) {
                S = 0;
                const a = h.eq(r);
                if (T && e.grid.updateSlide(r, a, u, t), "none" !== a.css("display")) {
                    if ("auto" === i.slidesPerView) {
                        E && (h[r].style[t("width")] = "");
                        const s = getComputedStyle(a[0]), o = a[0].style.transform, l = a[0].style.webkitTransform;
                        if (o && (a[0].style.transform = "none"), l && (a[0].style.webkitTransform = "none"), i.roundLengths) S = e.isHorizontal() ? a.outerWidth(!0) : a.outerHeight(!0); else {
                            const e = n(s, "width"), t = n(s, "padding-left"), i = n(s, "padding-right"),
                                r = n(s, "margin-left"), o = n(s, "margin-right"), l = s.getPropertyValue("box-sizing");
                            if (l && "border-box" === l) S = e + r + o; else {
                                const {clientWidth: n, offsetWidth: s} = a[0];
                                S = e + t + i + r + o + (s - n)
                            }
                        }
                        o && (a[0].style.transform = o), l && (a[0].style.webkitTransform = l), i.roundLengths && (S = Math.floor(S))
                    } else S = (s - (i.slidesPerView - 1) * y) / i.slidesPerView, i.roundLengths && (S = Math.floor(S)), h[r] && (h[r].style[t("width")] = `${S}px`);
                    h[r] && (h[r].swiperSlideSize = S), f.push(S), i.centeredSlides ? (x = x + S / 2 + b / 2 + y, 0 === b && 0 !== r && (x = x - s / 2 - y), 0 === r && (x = x - s / 2 - y), Math.abs(x) < .001 && (x = 0), i.roundLengths && (x = Math.floor(x)), w % i.slidesPerGroup == 0 && d.push(x), p.push(x)) : (i.roundLengths && (x = Math.floor(x)), (w - Math.min(e.params.slidesPerGroupSkip, w)) % e.params.slidesPerGroup == 0 && d.push(x), p.push(x), x = x + S + y), e.virtualSize += S + y, b = S, w += 1
                }
            }
            if (e.virtualSize = Math.max(e.virtualSize, s) + g, a && o && ("slide" === i.effect || "coverflow" === i.effect) && r.css({width: `${e.virtualSize + i.spaceBetween}px`}), i.setWrapperSize && r.css({[t("width")]: `${e.virtualSize + i.spaceBetween}px`}), T && e.grid.updateWrapperSize(S, d, t), !i.centeredSlides) {
                const t = [];
                for (let n = 0; n < d.length; n += 1) {
                    let r = d[n];
                    i.roundLengths && (r = Math.floor(r)), d[n] <= e.virtualSize - s && t.push(r)
                }
                d = t, Math.floor(e.virtualSize - s) - Math.floor(d[d.length - 1]) > 1 && d.push(e.virtualSize - s)
            }
            if (0 === d.length && (d = [0]), 0 !== i.spaceBetween) {
                const n = e.isHorizontal() && a ? "marginLeft" : t("marginRight");
                h.filter(((e, t) => !i.cssMode || t !== h.length - 1)).css({[n]: `${y}px`})
            }
            if (i.centeredSlides && i.centeredSlidesBounds) {
                let e = 0;
                f.forEach((t => {
                    e += t + (i.spaceBetween ? i.spaceBetween : 0)
                })), e -= i.spaceBetween;
                const t = e - s;
                d = d.map((e => e < 0 ? -m : e > t ? t + g : e))
            }
            if (i.centerInsufficientSlides) {
                let e = 0;
                if (f.forEach((t => {
                    e += t + (i.spaceBetween ? i.spaceBetween : 0)
                })), e -= i.spaceBetween, e < s) {
                    const t = (s - e) / 2;
                    d.forEach(((e, n) => {
                        d[n] = e - t
                    })), p.forEach(((e, n) => {
                        p[n] = e + t
                    }))
                }
            }
            if (Object.assign(e, {
                slides: h,
                snapGrid: d,
                slidesGrid: p,
                slidesSizesGrid: f
            }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
                fl(e.wrapperEl, "--swiper-centered-offset-before", -d[0] + "px"), fl(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px");
                const t = -e.snapGrid[0], n = -e.slidesGrid[0];
                e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + n))
            }
            u !== c && e.emit("slidesLengthChange"), d.length !== v && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), p.length !== _ && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset()
        }, updateAutoHeight: function (e) {
            const t = this, n = [], i = t.virtual && t.params.virtual.enabled;
            let r, s = 0;
            "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
            const a = e => i ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0];
            if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) t.visibleSlides.each((e => {
                n.push(e)
            })); else for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) {
                const e = t.activeIndex + r;
                if (e > t.slides.length && !i) break;
                n.push(a(e))
            } else n.push(a(t.activeIndex));
            for (r = 0; r < n.length; r += 1) if (void 0 !== n[r]) {
                const e = n[r].offsetHeight;
                s = e > s ? e : s
            }
            s && t.$wrapperEl.css("height", `${s}px`)
        }, updateSlidesOffset: function () {
            const e = this, t = e.slides;
            for (let n = 0; n < t.length; n += 1) t[n].swiperSlideOffset = e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop
        }, updateSlidesProgress: function (e = this && this.translate || 0) {
            const t = this, n = t.params, {slides: i, rtlTranslate: r, snapGrid: s} = t;
            if (0 === i.length) return;
            void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset();
            let a = -e;
            r && (a = e), i.removeClass(n.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];
            for (let e = 0; e < i.length; e += 1) {
                const o = i[e];
                let l = o.swiperSlideOffset;
                n.cssMode && n.centeredSlides && (l -= i[0].swiperSlideOffset);
                const c = (a + (n.centeredSlides ? t.minTranslate() : 0) - l) / (o.swiperSlideSize + n.spaceBetween),
                    h = (a - s[0] + (n.centeredSlides ? t.minTranslate() : 0) - l) / (o.swiperSlideSize + n.spaceBetween),
                    u = -(a - l), d = u + t.slidesSizesGrid[e];
                (u >= 0 && u < t.size - 1 || d > 1 && d <= t.size || u <= 0 && d >= t.size) && (t.visibleSlides.push(o), t.visibleSlidesIndexes.push(e), i.eq(e).addClass(n.slideVisibleClass)), o.progress = r ? -c : c, o.originalProgress = r ? -h : h
            }
            t.visibleSlides = ol(t.visibleSlides)
        }, updateProgress: function (e) {
            const t = this;
            if (void 0 === e) {
                const n = t.rtlTranslate ? -1 : 1;
                e = t && t.translate && t.translate * n || 0
            }
            const n = t.params, i = t.maxTranslate() - t.minTranslate();
            let {progress: r, isBeginning: s, isEnd: a} = t;
            const o = s, l = a;
            0 === i ? (r = 0, s = !0, a = !0) : (r = (e - t.minTranslate()) / i, s = r <= 0, a = r >= 1), Object.assign(t, {
                progress: r,
                isBeginning: s,
                isEnd: a
            }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e), s && !o && t.emit("reachBeginning toEdge"), a && !l && t.emit("reachEnd toEdge"), (o && !s || l && !a) && t.emit("fromEdge"), t.emit("progress", r)
        }, updateSlidesClasses: function () {
            const e = this, {slides: t, params: n, $wrapperEl: i, activeIndex: r, realIndex: s} = e,
                a = e.virtual && n.virtual.enabled;
            let o;
            t.removeClass(`${n.slideActiveClass} ${n.slideNextClass} ${n.slidePrevClass} ${n.slideDuplicateActiveClass} ${n.slideDuplicateNextClass} ${n.slideDuplicatePrevClass}`), o = a ? e.$wrapperEl.find(`.${n.slideClass}[data-swiper-slide-index="${r}"]`) : t.eq(r), o.addClass(n.slideActiveClass), n.loop && (o.hasClass(n.slideDuplicateClass) ? i.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${s}"]`).addClass(n.slideDuplicateActiveClass) : i.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${s}"]`).addClass(n.slideDuplicateActiveClass));
            let l = o.nextAll(`.${n.slideClass}`).eq(0).addClass(n.slideNextClass);
            n.loop && 0 === l.length && (l = t.eq(0), l.addClass(n.slideNextClass));
            let c = o.prevAll(`.${n.slideClass}`).eq(0).addClass(n.slidePrevClass);
            n.loop && 0 === c.length && (c = t.eq(-1), c.addClass(n.slidePrevClass)), n.loop && (l.hasClass(n.slideDuplicateClass) ? i.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass) : i.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass), c.hasClass(n.slideDuplicateClass) ? i.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass) : i.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass)), e.emitSlidesClasses()
        }, updateActiveIndex: function (e) {
            const t = this, n = t.rtlTranslate ? t.translate : -t.translate, {
                slidesGrid: i,
                snapGrid: r,
                params: s,
                activeIndex: a,
                realIndex: o,
                snapIndex: l
            } = t;
            let c, h = e;
            if (void 0 === h) {
                for (let e = 0; e < i.length; e += 1) void 0 !== i[e + 1] ? n >= i[e] && n < i[e + 1] - (i[e + 1] - i[e]) / 2 ? h = e : n >= i[e] && n < i[e + 1] && (h = e + 1) : n >= i[e] && (h = e);
                s.normalizeSlideIndex && (h < 0 || void 0 === h) && (h = 0)
            }
            if (r.indexOf(n) >= 0) c = r.indexOf(n); else {
                const e = Math.min(s.slidesPerGroupSkip, h);
                c = e + Math.floor((h - e) / s.slidesPerGroup)
            }
            if (c >= r.length && (c = r.length - 1), h === a) return void (c !== l && (t.snapIndex = c, t.emit("snapIndexChange")));
            const u = parseInt(t.slides.eq(h).attr("data-swiper-slide-index") || h, 10);
            Object.assign(t, {
                snapIndex: c,
                realIndex: u,
                previousIndex: a,
                activeIndex: h
            }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), o !== u && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
        }, updateClickedSlide: function (e) {
            const t = this, n = t.params, i = ol(e.target).closest(`.${n.slideClass}`)[0];
            let r, s = !1;
            if (i) for (let e = 0; e < t.slides.length; e += 1) if (t.slides[e] === i) {
                s = !0, r = e;
                break
            }
            if (!i || !s) return t.clickedSlide = void 0, void (t.clickedIndex = void 0);
            t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(ol(i).attr("data-swiper-slide-index"), 10) : t.clickedIndex = r, n.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
        }
    };
    var Sl = {
        getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) {
            const {params: t, rtlTranslate: n, translate: i, $wrapperEl: r} = this;
            if (t.virtualTranslate) return n ? -i : i;
            if (t.cssMode) return i;
            let s = ul(r[0], e);
            return n && (s = -s), s || 0
        }, setTranslate: function (e, t) {
            const n = this, {rtlTranslate: i, params: r, $wrapperEl: s, wrapperEl: a, progress: o} = n;
            let l, c = 0, h = 0;
            n.isHorizontal() ? c = i ? -e : e : h = e, r.roundLengths && (c = Math.floor(c), h = Math.floor(h)), r.cssMode ? a[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -c : -h : r.virtualTranslate || s.transform(`translate3d(${c}px, ${h}px, 0px)`), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? c : h;
            const u = n.maxTranslate() - n.minTranslate();
            l = 0 === u ? 0 : (e - n.minTranslate()) / u, l !== o && n.updateProgress(e), n.emit("setTranslate", n.translate, t)
        }, minTranslate: function () {
            return -this.snapGrid[0]
        }, maxTranslate: function () {
            return -this.snapGrid[this.snapGrid.length - 1]
        }, translateTo: function (e = 0, t = this.params.speed, n = !0, i = !0, r) {
            const s = this, {params: a, wrapperEl: o} = s;
            if (s.animating && a.preventInteractionOnTransition) return !1;
            const l = s.minTranslate(), c = s.maxTranslate();
            let h;
            if (h = i && e > l ? l : i && e < c ? c : e, s.updateProgress(h), a.cssMode) {
                const e = s.isHorizontal();
                if (0 === t) o[e ? "scrollLeft" : "scrollTop"] = -h; else {
                    if (!s.support.smoothScroll) return ml({
                        swiper: s,
                        targetPosition: -h,
                        side: e ? "left" : "top"
                    }), !0;
                    o.scrollTo({[e ? "left" : "top"]: -h, behavior: "smooth"})
                }
                return !0
            }
            return 0 === t ? (s.setTransition(0), s.setTranslate(h), n && (s.emit("beforeTransitionStart", t, r), s.emit("transitionEnd"))) : (s.setTransition(t), s.setTranslate(h), n && (s.emit("beforeTransitionStart", t, r), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (e) {
                s && !s.destroyed && e.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, n && s.emit("transitionEnd"))
            }), s.$wrapperEl[0].addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd))), !0
        }
    };

    function El({swiper: e, runCallbacks: t, direction: n, step: i}) {
        const {activeIndex: r, previousIndex: s} = e;
        let a = n;
        if (a || (a = r > s ? "next" : r < s ? "prev" : "reset"), e.emit(`transition${i}`), t && r !== s) {
            if ("reset" === a) return void e.emit(`slideResetTransition${i}`);
            e.emit(`slideChangeTransition${i}`), "next" === a ? e.emit(`slideNextTransition${i}`) : e.emit(`slidePrevTransition${i}`)
        }
    }

    var Ml = {
        slideTo: function (e = 0, t = this.params.speed, n = !0, i, r) {
            if ("number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);
            if ("string" == typeof e) {
                const t = parseInt(e, 10);
                if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                e = t
            }
            const s = this;
            let a = e;
            a < 0 && (a = 0);
            const {
                params: o,
                snapGrid: l,
                slidesGrid: c,
                previousIndex: h,
                activeIndex: u,
                rtlTranslate: d,
                wrapperEl: p,
                enabled: f
            } = s;
            if (s.animating && o.preventInteractionOnTransition || !f && !i && !r) return !1;
            const m = Math.min(s.params.slidesPerGroupSkip, a);
            let g = m + Math.floor((a - m) / s.params.slidesPerGroup);
            g >= l.length && (g = l.length - 1), (u || o.initialSlide || 0) === (h || 0) && n && s.emit("beforeSlideChangeStart");
            const v = -l[g];
            if (s.updateProgress(v), o.normalizeSlideIndex) for (let e = 0; e < c.length; e += 1) {
                const t = -Math.floor(100 * v), n = Math.floor(100 * c[e]), i = Math.floor(100 * c[e + 1]);
                void 0 !== c[e + 1] ? t >= n && t < i - (i - n) / 2 ? a = e : t >= n && t < i && (a = e + 1) : t >= n && (a = e)
            }
            if (s.initialized && a !== u) {
                if (!s.allowSlideNext && v < s.translate && v < s.minTranslate()) return !1;
                if (!s.allowSlidePrev && v > s.translate && v > s.maxTranslate() && (u || 0) !== a) return !1
            }
            let _;
            if (_ = a > u ? "next" : a < u ? "prev" : "reset", d && -v === s.translate || !d && v === s.translate) return s.updateActiveIndex(a), o.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), "slide" !== o.effect && s.setTranslate(v), "reset" !== _ && (s.transitionStart(n, _), s.transitionEnd(n, _)), !1;
            if (o.cssMode) {
                const e = s.isHorizontal(), n = d ? v : -v;
                if (0 === t) {
                    const t = s.virtual && s.params.virtual.enabled;
                    t && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), p[e ? "scrollLeft" : "scrollTop"] = n, t && requestAnimationFrame((() => {
                        s.wrapperEl.style.scrollSnapType = "", s._swiperImmediateVirtual = !1
                    }))
                } else {
                    if (!s.support.smoothScroll) return ml({
                        swiper: s,
                        targetPosition: n,
                        side: e ? "left" : "top"
                    }), !0;
                    p.scrollTo({[e ? "left" : "top"]: n, behavior: "smooth"})
                }
                return !0
            }
            return 0 === t ? (s.setTransition(0), s.setTranslate(v), s.updateActiveIndex(a), s.updateSlidesClasses(), s.emit("beforeTransitionStart", t, i), s.transitionStart(n, _), s.transitionEnd(n, _)) : (s.setTransition(t), s.setTranslate(v), s.updateActiveIndex(a), s.updateSlidesClasses(), s.emit("beforeTransitionStart", t, i), s.transitionStart(n, _), s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (e) {
                s && !s.destroyed && e.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(n, _))
            }), s.$wrapperEl[0].addEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd))), !0
        }, slideToLoop: function (e = 0, t = this.params.speed, n = !0, i) {
            const r = this;
            let s = e;
            return r.params.loop && (s += r.loopedSlides), r.slideTo(s, t, n, i)
        }, slideNext: function (e = this.params.speed, t = !0, n) {
            const i = this, {animating: r, enabled: s, params: a} = i;
            if (!s) return i;
            let o = a.slidesPerGroup;
            "auto" === a.slidesPerView && 1 === a.slidesPerGroup && a.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1));
            const l = i.activeIndex < a.slidesPerGroupSkip ? 1 : o;
            if (a.loop) {
                if (r && a.loopPreventsSlide) return !1;
                i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft
            }
            return i.slideTo(i.activeIndex + l, e, t, n)
        }, slidePrev: function (e = this.params.speed, t = !0, n) {
            const i = this, {params: r, animating: s, snapGrid: a, slidesGrid: o, rtlTranslate: l, enabled: c} = i;
            if (!c) return i;
            if (r.loop) {
                if (s && r.loopPreventsSlide) return !1;
                i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft
            }

            function h(e) {
                return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
            }

            const u = h(l ? i.translate : -i.translate), d = a.map((e => h(e)));
            let p = a[d.indexOf(u) - 1];
            if (void 0 === p && r.cssMode) {
                let e;
                a.forEach(((t, n) => {
                    u >= t && (e = n)
                })), void 0 !== e && (p = a[e > 0 ? e - 1 : e])
            }
            let f = 0;
            return void 0 !== p && (f = o.indexOf(p), f < 0 && (f = i.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (f = f - i.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), i.slideTo(f, e, t, n)
        }, slideReset: function (e = this.params.speed, t = !0, n) {
            return this.slideTo(this.activeIndex, e, t, n)
        }, slideToClosest: function (e = this.params.speed, t = !0, n, i = .5) {
            const r = this;
            let s = r.activeIndex;
            const a = Math.min(r.params.slidesPerGroupSkip, s), o = a + Math.floor((s - a) / r.params.slidesPerGroup),
                l = r.rtlTranslate ? r.translate : -r.translate;
            if (l >= r.snapGrid[o]) {
                const e = r.snapGrid[o];
                l - e > (r.snapGrid[o + 1] - e) * i && (s += r.params.slidesPerGroup)
            } else {
                const e = r.snapGrid[o - 1];
                l - e <= (r.snapGrid[o] - e) * i && (s -= r.params.slidesPerGroup)
            }
            return s = Math.max(s, 0), s = Math.min(s, r.slidesGrid.length - 1), r.slideTo(s, e, t, n)
        }, slideToClickedSlide: function () {
            const e = this, {params: t, $wrapperEl: n} = e,
                i = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
            let r, s = e.clickedIndex;
            if (t.loop) {
                if (e.animating) return;
                r = parseInt(ol(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? s < e.loopedSlides - i / 2 || s > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), s = n.children(`.${t.slideClass}[data-swiper-slide-index="${r}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), cl((() => {
                    e.slideTo(s)
                }))) : e.slideTo(s) : s > e.slides.length - i ? (e.loopFix(), s = n.children(`.${t.slideClass}[data-swiper-slide-index="${r}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), cl((() => {
                    e.slideTo(s)
                }))) : e.slideTo(s)
            } else e.slideTo(s)
        }
    };
    var Al = {
        loopCreate: function () {
            const e = this, t = tl(), {params: n, $wrapperEl: i} = e, r = ol(i.children()[0].parentNode);
            r.children(`.${n.slideClass}.${n.slideDuplicateClass}`).remove();
            let s = r.children(`.${n.slideClass}`);
            if (n.loopFillGroupWithBlank) {
                const e = n.slidesPerGroup - s.length % n.slidesPerGroup;
                if (e !== n.slidesPerGroup) {
                    for (let i = 0; i < e; i += 1) {
                        const e = ol(t.createElement("div")).addClass(`${n.slideClass} ${n.slideBlankClass}`);
                        r.append(e)
                    }
                    s = r.children(`.${n.slideClass}`)
                }
            }
            "auto" !== n.slidesPerView || n.loopedSlides || (n.loopedSlides = s.length), e.loopedSlides = Math.ceil(parseFloat(n.loopedSlides || n.slidesPerView, 10)), e.loopedSlides += n.loopAdditionalSlides, e.loopedSlides > s.length && (e.loopedSlides = s.length);
            const a = [], o = [];
            s.each(((t, n) => {
                const i = ol(t);
                n < e.loopedSlides && o.push(t), n < s.length && n >= s.length - e.loopedSlides && a.push(t), i.attr("data-swiper-slide-index", n)
            }));
            for (let e = 0; e < o.length; e += 1) r.append(ol(o[e].cloneNode(!0)).addClass(n.slideDuplicateClass));
            for (let e = a.length - 1; e >= 0; e -= 1) r.prepend(ol(a[e].cloneNode(!0)).addClass(n.slideDuplicateClass))
        }, loopFix: function () {
            const e = this;
            e.emit("beforeLoopFix");
            const {
                activeIndex: t,
                slides: n,
                loopedSlides: i,
                allowSlidePrev: r,
                allowSlideNext: s,
                snapGrid: a,
                rtlTranslate: o
            } = e;
            let l;
            e.allowSlidePrev = !0, e.allowSlideNext = !0;
            const c = -a[t] - e.getTranslate();
            if (t < i) {
                l = n.length - 3 * i + t, l += i;
                e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((o ? -e.translate : e.translate) - c)
            } else if (t >= n.length - i) {
                l = -n.length + t + i, l += i;
                e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((o ? -e.translate : e.translate) - c)
            }
            e.allowSlidePrev = r, e.allowSlideNext = s, e.emit("loopFix")
        }, loopDestroy: function () {
            const {$wrapperEl: e, params: t, slides: n} = this;
            e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), n.removeAttr("data-swiper-slide-index")
        }
    };

    function Ll(e) {
        const t = this, n = tl(), i = il(), r = t.touchEventsData, {params: s, touches: a, enabled: o} = t;
        if (!o) return;
        if (t.animating && s.preventInteractionOnTransition) return;
        !t.animating && s.cssMode && s.loop && t.loopFix();
        let l = e;
        l.originalEvent && (l = l.originalEvent);
        let c = ol(l.target);
        if ("wrapper" === s.touchEventsTarget && !c.closest(t.wrapperEl).length) return;
        if (r.isTouchEvent = "touchstart" === l.type, !r.isTouchEvent && "which" in l && 3 === l.which) return;
        if (!r.isTouchEvent && "button" in l && l.button > 0) return;
        if (r.isTouched && r.isMoved) return;
        !!s.noSwipingClass && "" !== s.noSwipingClass && l.target && l.target.shadowRoot && e.path && e.path[0] && (c = ol(e.path[0]));
        const h = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`,
            u = !(!l.target || !l.target.shadowRoot);
        if (s.noSwiping && (u ? function (e, t = this) {
            return function t(n) {
                return n && n !== tl() && n !== il() ? (n.assignedSlot && (n = n.assignedSlot), n.closest(e) || t(n.getRootNode().host)) : null
            }(t)
        }(h, l.target) : c.closest(h)[0])) return void (t.allowClick = !0);
        if (s.swipeHandler && !c.closest(s.swipeHandler)[0]) return;
        a.currentX = "touchstart" === l.type ? l.targetTouches[0].pageX : l.pageX, a.currentY = "touchstart" === l.type ? l.targetTouches[0].pageY : l.pageY;
        const d = a.currentX, p = a.currentY, f = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection,
            m = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
        if (f && (d <= m || d >= i.innerWidth - m)) {
            if ("prevent" !== f) return;
            e.preventDefault()
        }
        if (Object.assign(r, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), a.startX = d, a.startY = p, r.touchStartTime = hl(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, s.threshold > 0 && (r.allowThresholdMove = !1), "touchstart" !== l.type) {
            let e = !0;
            c.is(r.focusableElements) && (e = !1), n.activeElement && ol(n.activeElement).is(r.focusableElements) && n.activeElement !== c[0] && n.activeElement.blur();
            const i = e && t.allowTouchMove && s.touchStartPreventDefault;
            !s.touchStartForcePreventDefault && !i || c[0].isContentEditable || l.preventDefault()
        }
        t.emit("touchStart", l)
    }

    function Cl(e) {
        const t = tl(), n = this, i = n.touchEventsData, {params: r, touches: s, rtlTranslate: a, enabled: o} = n;
        if (!o) return;
        let l = e;
        if (l.originalEvent && (l = l.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && n.emit("touchMoveOpposite", l));
        if (i.isTouchEvent && "touchmove" !== l.type) return;
        const c = "touchmove" === l.type && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]),
            h = "touchmove" === l.type ? c.pageX : l.pageX, u = "touchmove" === l.type ? c.pageY : l.pageY;
        if (l.preventedByNestedSwiper) return s.startX = h, void (s.startY = u);
        if (!n.allowTouchMove) return n.allowClick = !1, void (i.isTouched && (Object.assign(s, {
            startX: h,
            startY: u,
            currentX: h,
            currentY: u
        }), i.touchStartTime = hl()));
        if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop) if (n.isVertical()) {
            if (u < s.startY && n.translate <= n.maxTranslate() || u > s.startY && n.translate >= n.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1)
        } else if (h < s.startX && n.translate <= n.maxTranslate() || h > s.startX && n.translate >= n.minTranslate()) return;
        if (i.isTouchEvent && t.activeElement && l.target === t.activeElement && ol(l.target).is(i.focusableElements)) return i.isMoved = !0, void (n.allowClick = !1);
        if (i.allowTouchCallbacks && n.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return;
        s.currentX = h, s.currentY = u;
        const d = s.currentX - s.startX, p = s.currentY - s.startY;
        if (n.params.threshold && Math.sqrt(d ** 2 + p ** 2) < n.params.threshold) return;
        if (void 0 === i.isScrolling) {
            let e;
            n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? i.isScrolling = !1 : d * d + p * p >= 25 && (e = 180 * Math.atan2(Math.abs(p), Math.abs(d)) / Math.PI, i.isScrolling = n.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
        }
        if (i.isScrolling && n.emit("touchMoveOpposite", l), void 0 === i.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (i.startMoving = !0)), i.isScrolling) return void (i.isTouched = !1);
        if (!i.startMoving) return;
        n.allowClick = !1, !r.cssMode && l.cancelable && l.preventDefault(), r.touchMoveStopPropagation && !r.nested && l.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && n.loopFix(), i.startTranslate = n.getTranslate(), n.setTransition(0), n.animating && n.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0), n.emit("sliderFirstMove", l)), n.emit("sliderMove", l), i.isMoved = !0;
        let f = n.isHorizontal() ? d : p;
        s.diff = f, f *= r.touchRatio, a && (f = -f), n.swipeDirection = f > 0 ? "prev" : "next", i.currentTranslate = f + i.startTranslate;
        let m = !0, g = r.resistanceRatio;
        if (r.touchReleaseOnEdges && (g = 0), f > 0 && i.currentTranslate > n.minTranslate() ? (m = !1, r.resistance && (i.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + i.startTranslate + f) ** g)) : f < 0 && i.currentTranslate < n.maxTranslate() && (m = !1, r.resistance && (i.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - i.startTranslate - f) ** g)), m && (l.preventedByNestedSwiper = !0), !n.allowSlideNext && "next" === n.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !n.allowSlidePrev && "prev" === n.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), n.allowSlidePrev || n.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {
            if (!(Math.abs(f) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate);
            if (!i.allowThresholdMove) return i.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, i.currentTranslate = i.startTranslate, void (s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY)
        }
        r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && n.freeMode || r.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), n.params.freeMode && r.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(i.currentTranslate), n.setTranslate(i.currentTranslate))
    }

    function Rl(e) {
        const t = this, n = t.touchEventsData, {params: i, touches: r, rtlTranslate: s, slidesGrid: a, enabled: o} = t;
        if (!o) return;
        let l = e;
        if (l.originalEvent && (l = l.originalEvent), n.allowTouchCallbacks && t.emit("touchEnd", l), n.allowTouchCallbacks = !1, !n.isTouched) return n.isMoved && i.grabCursor && t.setGrabCursor(!1), n.isMoved = !1, void (n.startMoving = !1);
        i.grabCursor && n.isMoved && n.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
        const c = hl(), h = c - n.touchStartTime;
        if (t.allowClick && (t.updateClickedSlide(l), t.emit("tap click", l), h < 300 && c - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", l)), n.lastClickTime = hl(), cl((() => {
            t.destroyed || (t.allowClick = !0)
        })), !n.isTouched || !n.isMoved || !t.swipeDirection || 0 === r.diff || n.currentTranslate === n.startTranslate) return n.isTouched = !1, n.isMoved = !1, void (n.startMoving = !1);
        let u;
        if (n.isTouched = !1, n.isMoved = !1, n.startMoving = !1, u = i.followFinger ? s ? t.translate : -t.translate : -n.currentTranslate, i.cssMode) return;
        if (t.params.freeMode && i.freeMode.enabled) return void t.freeMode.onTouchEnd({currentPos: u});
        let d = 0, p = t.slidesSizesGrid[0];
        for (let e = 0; e < a.length; e += e < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup) {
            const t = e < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
            void 0 !== a[e + t] ? u >= a[e] && u < a[e + t] && (d = e, p = a[e + t] - a[e]) : u >= a[e] && (d = e, p = a[a.length - 1] - a[a.length - 2])
        }
        const f = (u - a[d]) / p, m = d < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
        if (h > i.longSwipesMs) {
            if (!i.longSwipes) return void t.slideTo(t.activeIndex);
            "next" === t.swipeDirection && (f >= i.longSwipesRatio ? t.slideTo(d + m) : t.slideTo(d)), "prev" === t.swipeDirection && (f > 1 - i.longSwipesRatio ? t.slideTo(d + m) : t.slideTo(d))
        } else {
            if (!i.shortSwipes) return void t.slideTo(t.activeIndex);
            t.navigation && (l.target === t.navigation.nextEl || l.target === t.navigation.prevEl) ? l.target === t.navigation.nextEl ? t.slideTo(d + m) : t.slideTo(d) : ("next" === t.swipeDirection && t.slideTo(d + m), "prev" === t.swipeDirection && t.slideTo(d))
        }
    }

    function Pl() {
        const e = this, {params: t, el: n} = e;
        if (n && 0 === n.offsetWidth) return;
        t.breakpoints && e.setBreakpoint();
        const {allowSlideNext: i, allowSlidePrev: r, snapGrid: s} = e;
        e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = r, e.allowSlideNext = i, e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow()
    }

    function Il(e) {
        const t = this;
        t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
    }

    function Ol() {
        const e = this, {wrapperEl: t, rtlTranslate: n, enabled: i} = e;
        if (!i) return;
        let r;
        e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, -0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
        const s = e.maxTranslate() - e.minTranslate();
        r = 0 === s ? 0 : (e.translate - e.minTranslate()) / s, r !== e.progress && e.updateProgress(n ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
    }

    let Dl = !1;

    function Nl() {
    }

    const Bl = (e, t) => {
        const n = tl(), {params: i, touchEvents: r, el: s, wrapperEl: a, device: o, support: l} = e, c = !!i.nested,
            h = "on" === t ? "addEventListener" : "removeEventListener", u = t;
        if (l.touch) {
            const t = !("touchstart" !== r.start || !l.passiveListener || !i.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            s[h](r.start, e.onTouchStart, t), s[h](r.move, e.onTouchMove, l.passiveListener ? {
                passive: !1,
                capture: c
            } : c), s[h](r.end, e.onTouchEnd, t), r.cancel && s[h](r.cancel, e.onTouchEnd, t)
        } else s[h](r.start, e.onTouchStart, !1), n[h](r.move, e.onTouchMove, c), n[h](r.end, e.onTouchEnd, !1);
        (i.preventClicks || i.preventClicksPropagation) && s[h]("click", e.onClick, !0), i.cssMode && a[h]("scroll", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Pl, !0) : e[u]("observerUpdate", Pl, !0)
    };
    var kl = {
        attachEvents: function () {
            const e = this, t = tl(), {params: n, support: i} = e;
            e.onTouchStart = Ll.bind(e), e.onTouchMove = Cl.bind(e), e.onTouchEnd = Rl.bind(e), n.cssMode && (e.onScroll = Ol.bind(e)), e.onClick = Il.bind(e), i.touch && !Dl && (t.addEventListener("touchstart", Nl), Dl = !0), Bl(e, "on")
        }, detachEvents: function () {
            Bl(this, "off")
        }
    };
    const Ul = (e, t) => e.grid && t.grid && t.grid.rows > 1;
    var Fl = {
        setBreakpoint: function () {
            const e = this, {activeIndex: t, initialized: n, loopedSlides: i = 0, params: r, $el: s} = e,
                a = r.breakpoints;
            if (!a || a && 0 === Object.keys(a).length) return;
            const o = e.getBreakpoint(a, e.params.breakpointsBase, e.el);
            if (!o || e.currentBreakpoint === o) return;
            const l = (o in a ? a[o] : void 0) || e.originalParams, c = Ul(e, r), h = Ul(e, l), u = r.enabled;
            c && !h ? (s.removeClass(`${r.containerModifierClass}grid ${r.containerModifierClass}grid-column`), e.emitContainerClasses()) : !c && h && (s.addClass(`${r.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === r.grid.fill) && s.addClass(`${r.containerModifierClass}grid-column`), e.emitContainerClasses());
            const d = l.direction && l.direction !== r.direction,
                p = r.loop && (l.slidesPerView !== r.slidesPerView || d);
            d && n && e.changeDirection(), pl(e.params, l);
            const f = e.params.enabled;
            Object.assign(e, {
                allowTouchMove: e.params.allowTouchMove,
                allowSlideNext: e.params.allowSlideNext,
                allowSlidePrev: e.params.allowSlidePrev
            }), u && !f ? e.disable() : !u && f && e.enable(), e.currentBreakpoint = o, e.emit("_beforeBreakpoint", l), p && n && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - i + e.loopedSlides, 0, !1)), e.emit("breakpoint", l)
        }, getBreakpoint: function (e, t = "window", n) {
            if (!e || "container" === t && !n) return;
            let i = !1;
            const r = il(), s = "window" === t ? r.innerHeight : n.clientHeight, a = Object.keys(e).map((e => {
                if ("string" == typeof e && 0 === e.indexOf("@")) {
                    const t = parseFloat(e.substr(1));
                    return {value: s * t, point: e}
                }
                return {value: e, point: e}
            }));
            a.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
            for (let e = 0; e < a.length; e += 1) {
                const {point: s, value: o} = a[e];
                "window" === t ? r.matchMedia(`(min-width: ${o}px)`).matches && (i = s) : o <= n.clientWidth && (i = s)
            }
            return i || "max"
        }
    };
    var Hl = {
        addClasses: function () {
            const e = this, {classNames: t, params: n, rtl: i, $el: r, device: s, support: a} = e, o = function (e, t) {
                const n = [];
                return e.forEach((e => {
                    "object" == typeof e ? Object.keys(e).forEach((i => {
                        e[i] && n.push(t + i)
                    })) : "string" == typeof e && n.push(t + e)
                })), n
            }(["initialized", n.direction, {"pointer-events": !a.touch}, {"free-mode": e.params.freeMode && n.freeMode.enabled}, {autoheight: n.autoHeight}, {rtl: i}, {grid: n.grid && n.grid.rows > 1}, {"grid-column": n.grid && n.grid.rows > 1 && "column" === n.grid.fill}, {android: s.android}, {ios: s.ios}, {"css-mode": n.cssMode}, {centered: n.cssMode && n.centeredSlides}], n.containerModifierClass);
            t.push(...o), r.addClass([...t].join(" ")), e.emitContainerClasses()
        }, removeClasses: function () {
            const {$el: e, classNames: t} = this;
            e.removeClass(t.join(" ")), this.emitContainerClasses()
        }
    };
    var zl = {
        loadImage: function (e, t, n, i, r, s) {
            const a = il();
            let o;

            function l() {
                s && s()
            }

            ol(e).parent("picture")[0] || e.complete && r ? l() : t ? (o = new a.Image, o.onload = l, o.onerror = l, i && (o.sizes = i), n && (o.srcset = n), t && (o.src = t)) : l()
        }, preloadImages: function () {
            const e = this;

            function t() {
                null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
            }

            e.imagesToLoad = e.$el.find("img");
            for (let n = 0; n < e.imagesToLoad.length; n += 1) {
                const i = e.imagesToLoad[n];
                e.loadImage(i, i.currentSrc || i.getAttribute("src"), i.srcset || i.getAttribute("srcset"), i.sizes || i.getAttribute("sizes"), !0, t)
            }
        }
    };
    var Gl = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

    function Vl(e, t) {
        return function (n = {}) {
            const i = Object.keys(n)[0], r = n[i];
            "object" == typeof r && null !== r ? (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && !0 === e[i] && (e[i] = {auto: !0}), i in e && "enabled" in r ? (!0 === e[i] && (e[i] = {enabled: !0}), "object" != typeof e[i] || "enabled" in e[i] || (e[i].enabled = !0), e[i] || (e[i] = {enabled: !1}), pl(t, n)) : pl(t, n)) : pl(t, n)
        }
    }

    const Wl = {
        eventsEmitter: wl, update: Tl, translate: Sl, transition: {
            setTransition: function (e, t) {
                const n = this;
                n.params.cssMode || n.$wrapperEl.transition(e), n.emit("setTransition", e, t)
            }, transitionStart: function (e = !0, t) {
                const n = this, {params: i} = n;
                i.cssMode || (i.autoHeight && n.updateAutoHeight(), El({
                    swiper: n,
                    runCallbacks: e,
                    direction: t,
                    step: "Start"
                }))
            }, transitionEnd: function (e = !0, t) {
                const n = this, {params: i} = n;
                n.animating = !1, i.cssMode || (n.setTransition(0), El({
                    swiper: n,
                    runCallbacks: e,
                    direction: t,
                    step: "End"
                }))
            }
        }, slide: Ml, loop: Al, grabCursor: {
            setGrabCursor: function (e) {
                const t = this;
                if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
                const n = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                n.style.cursor = "move", n.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", n.style.cursor = e ? "-moz-grabbin" : "-moz-grab", n.style.cursor = e ? "grabbing" : "grab"
            }, unsetGrabCursor: function () {
                const e = this;
                e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
            }
        }, events: kl, breakpoints: Fl, checkOverflow: {
            checkOverflow: function () {
                const e = this, {isLocked: t, params: n} = e, {slidesOffsetBefore: i} = n;
                if (i) {
                    const t = e.slides.length - 1, n = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * i;
                    e.isLocked = e.size > n
                } else e.isLocked = 1 === e.snapGrid.length;
                !0 === n.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === n.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
            }
        }, classes: Hl, images: zl
    }, jl = {};

    class $l {
        constructor(...e) {
            let t, n;
            if (1 === e.length && e[0].constructor && "Object" === Object.prototype.toString.call(e[0]).slice(8, -1) ? n = e[0] : [t, n] = e, n || (n = {}), n = pl({}, n), t && !n.el && (n.el = t), n.el && ol(n.el).length > 1) {
                const e = [];
                return ol(n.el).each((t => {
                    const i = pl({}, n, {el: t});
                    e.push(new $l(i))
                })), e
            }
            const i = this;
            i.__swiper__ = !0, i.support = yl(), i.device = xl({userAgent: n.userAgent}), i.browser = bl(), i.eventsListeners = {}, i.eventsAnyListeners = [], i.modules = [...i.__modules__], n.modules && Array.isArray(n.modules) && i.modules.push(...n.modules);
            const r = {};
            i.modules.forEach((e => {
                e({
                    swiper: i,
                    extendParams: Vl(n, r),
                    on: i.on.bind(i),
                    once: i.once.bind(i),
                    off: i.off.bind(i),
                    emit: i.emit.bind(i)
                })
            }));
            const s = pl({}, Gl, r);
            return i.params = pl({}, s, jl, n), i.originalParams = pl({}, i.params), i.passedParams = pl({}, n), i.params && i.params.on && Object.keys(i.params.on).forEach((e => {
                i.on(e, i.params.on[e])
            })), i.params && i.params.onAny && i.onAny(i.params.onAny), i.$ = ol, Object.assign(i, {
                enabled: i.params.enabled,
                el: t,
                classNames: [],
                slides: ol(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === i.params.direction,
                isVertical: () => "vertical" === i.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                allowSlideNext: i.params.allowSlideNext,
                allowSlidePrev: i.params.allowSlidePrev,
                touchEvents: function () {
                    const e = ["touchstart", "touchmove", "touchend", "touchcancel"],
                        t = ["pointerdown", "pointermove", "pointerup"];
                    return i.touchEventsTouch = {
                        start: e[0],
                        move: e[1],
                        end: e[2],
                        cancel: e[3]
                    }, i.touchEventsDesktop = {
                        start: t[0],
                        move: t[1],
                        end: t[2]
                    }, i.support.touch || !i.params.simulateTouch ? i.touchEventsTouch : i.touchEventsDesktop
                }(),
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: i.params.focusableElements,
                    lastClickTime: hl(),
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    isTouchEvent: void 0,
                    startMoving: void 0
                },
                allowClick: !0,
                allowTouchMove: i.params.allowTouchMove,
                touches: {startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0},
                imagesToLoad: [],
                imagesLoaded: 0
            }), i.emit("_swiper"), i.params.init && i.init(), i
        }

        enable() {
            const e = this;
            e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
        }

        disable() {
            const e = this;
            e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
        }

        setProgress(e, t) {
            const n = this;
            e = Math.min(Math.max(e, 0), 1);
            const i = n.minTranslate(), r = (n.maxTranslate() - i) * e + i;
            n.translateTo(r, void 0 === t ? 0 : t), n.updateActiveIndex(), n.updateSlidesClasses()
        }

        emitContainerClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
            e.emit("_containerClasses", t.join(" "))
        }

        getSlideClasses(e) {
            const t = this;
            return e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
        }

        emitSlidesClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = [];
            e.slides.each((n => {
                const i = e.getSlideClasses(n);
                t.push({slideEl: n, classNames: i}), e.emit("_slideClass", n, i)
            })), e.emit("_slideClasses", t)
        }

        slidesPerViewDynamic(e = "current", t = !1) {
            const {params: n, slides: i, slidesGrid: r, slidesSizesGrid: s, size: a, activeIndex: o} = this;
            let l = 1;
            if (n.centeredSlides) {
                let e, t = i[o].swiperSlideSize;
                for (let n = o + 1; n < i.length; n += 1) i[n] && !e && (t += i[n].swiperSlideSize, l += 1, t > a && (e = !0));
                for (let n = o - 1; n >= 0; n -= 1) i[n] && !e && (t += i[n].swiperSlideSize, l += 1, t > a && (e = !0))
            } else if ("current" === e) for (let e = o + 1; e < i.length; e += 1) {
                (t ? r[e] + s[e] - r[o] < a : r[e] - r[o] < a) && (l += 1)
            } else for (let e = o - 1; e >= 0; e -= 1) {
                r[o] - r[e] < a && (l += 1)
            }
            return l
        }

        update() {
            const e = this;
            if (!e || e.destroyed) return;
            const {snapGrid: t, params: n} = e;

            function i() {
                const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                    n = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                e.setTranslate(n), e.updateActiveIndex(), e.updateSlidesClasses()
            }

            let r;
            n.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (i(), e.params.autoHeight && e.updateAutoHeight()) : (r = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), r || i()), n.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
        }

        changeDirection(e, t = !0) {
            const n = this, i = n.params.direction;
            return e || (e = "horizontal" === i ? "vertical" : "horizontal"), e === i || "horizontal" !== e && "vertical" !== e || (n.$el.removeClass(`${n.params.containerModifierClass}${i}`).addClass(`${n.params.containerModifierClass}${e}`), n.emitContainerClasses(), n.params.direction = e, n.slides.each((t => {
                "vertical" === e ? t.style.width = "" : t.style.height = ""
            })), n.emit("changeDirection"), t && n.update()), n
        }

        mount(e) {
            const t = this;
            if (t.mounted) return !0;
            const n = ol(e || t.params.el);
            if (!(e = n[0])) return !1;
            e.swiper = t;
            const i = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
            let r = (() => {
                if (e && e.shadowRoot && e.shadowRoot.querySelector) {
                    const t = ol(e.shadowRoot.querySelector(i()));
                    return t.children = e => n.children(e), t
                }
                return n.children(i())
            })();
            if (0 === r.length && t.params.createElements) {
                const e = tl().createElement("div");
                r = ol(e), e.className = t.params.wrapperClass, n.append(e), n.children(`.${t.params.slideClass}`).each((e => {
                    r.append(e)
                }))
            }
            return Object.assign(t, {
                $el: n,
                el: e,
                $wrapperEl: r,
                wrapperEl: r[0],
                mounted: !0,
                rtl: "rtl" === e.dir.toLowerCase() || "rtl" === n.css("direction"),
                rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === n.css("direction")),
                wrongRTL: "-webkit-box" === r.css("display")
            }), !0
        }

        init(e) {
            const t = this;
            if (t.initialized) return t;
            return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t
        }

        destroy(e = !0, t = !0) {
            const n = this, {params: i, $el: r, $wrapperEl: s, slides: a} = n;
            return void 0 === n.params || n.destroyed || (n.emit("beforeDestroy"), n.initialized = !1, n.detachEvents(), i.loop && n.loopDestroy(), t && (n.removeClasses(), r.removeAttr("style"), s.removeAttr("style"), a && a.length && a.removeClass([i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), n.emit("destroy"), Object.keys(n.eventsListeners).forEach((e => {
                n.off(e)
            })), !1 !== e && (n.$el[0].swiper = null, function (e) {
                const t = e;
                Object.keys(t).forEach((e => {
                    try {
                        t[e] = null
                    } catch (e) {
                    }
                    try {
                        delete t[e]
                    } catch (e) {
                    }
                }))
            }(n)), n.destroyed = !0), null
        }

        static extendDefaults(e) {
            pl(jl, e)
        }

        static get extendedDefaults() {
            return jl
        }

        static get defaults() {
            return Gl
        }

        static installModule(e) {
            $l.prototype.__modules__ || ($l.prototype.__modules__ = []);
            const t = $l.prototype.__modules__;
            "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
        }

        static use(e) {
            return Array.isArray(e) ? (e.forEach((e => $l.installModule(e))), $l) : ($l.installModule(e), $l)
        }
    }

    function Xl(e, t, n, i) {
        const r = tl();
        return e.params.createElements && Object.keys(i).forEach((s => {
            if (!n[s] && !0 === n.auto) {
                let a = e.$el.children(`.${i[s]}`)[0];
                a || (a = r.createElement("div"), a.className = i[s], e.$el.append(a)), n[s] = a, t[s] = a
            }
        })), n
    }

    function ql({swiper: e, extendParams: t, on: n, emit: i}) {
        function r(t) {
            let n;
            return t && (n = ol(t), e.params.uniqueNavElements && "string" == typeof t && n.length > 1 && 1 === e.$el.find(t).length && (n = e.$el.find(t))), n
        }

        function s(t, n) {
            const i = e.params.navigation;
            t && t.length > 0 && (t[n ? "addClass" : "removeClass"](i.disabledClass), t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = n), e.params.watchOverflow && e.enabled && t[e.isLocked ? "addClass" : "removeClass"](i.lockClass))
        }

        function a() {
            if (e.params.loop) return;
            const {$nextEl: t, $prevEl: n} = e.navigation;
            s(n, e.isBeginning), s(t, e.isEnd)
        }

        function o(t) {
            t.preventDefault(), e.isBeginning && !e.params.loop || e.slidePrev()
        }

        function l(t) {
            t.preventDefault(), e.isEnd && !e.params.loop || e.slideNext()
        }

        function c() {
            const t = e.params.navigation;
            if (e.params.navigation = Xl(e, e.originalParams.navigation, e.params.navigation, {
                nextEl: "swiper-button-next",
                prevEl: "swiper-button-prev"
            }), !t.nextEl && !t.prevEl) return;
            const n = r(t.nextEl), i = r(t.prevEl);
            n && n.length > 0 && n.on("click", l), i && i.length > 0 && i.on("click", o), Object.assign(e.navigation, {
                $nextEl: n,
                nextEl: n && n[0],
                $prevEl: i,
                prevEl: i && i[0]
            }), e.enabled || (n && n.addClass(t.lockClass), i && i.addClass(t.lockClass))
        }

        function h() {
            const {$nextEl: t, $prevEl: n} = e.navigation;
            t && t.length && (t.off("click", l), t.removeClass(e.params.navigation.disabledClass)), n && n.length && (n.off("click", o), n.removeClass(e.params.navigation.disabledClass))
        }

        t({
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock"
            }
        }), e.navigation = {nextEl: null, $nextEl: null, prevEl: null, $prevEl: null}, n("init", (() => {
            c(), a()
        })), n("toEdge fromEdge lock unlock", (() => {
            a()
        })), n("destroy", (() => {
            h()
        })), n("enable disable", (() => {
            const {$nextEl: t, $prevEl: n} = e.navigation;
            t && t[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), n && n[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass)
        })), n("click", ((t, n) => {
            const {$nextEl: r, $prevEl: s} = e.navigation, a = n.target;
            if (e.params.navigation.hideOnClick && !ol(a).is(s) && !ol(a).is(r)) {
                if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === a || e.pagination.el.contains(a))) return;
                let t;
                r ? t = r.hasClass(e.params.navigation.hiddenClass) : s && (t = s.hasClass(e.params.navigation.hiddenClass)), i(!0 === t ? "navigationShow" : "navigationHide"), r && r.toggleClass(e.params.navigation.hiddenClass), s && s.toggleClass(e.params.navigation.hiddenClass)
            }
        })), Object.assign(e.navigation, {update: a, init: c, destroy: h})
    }

    function Yl(e = "") {
        return `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`
    }

    function Kl({swiper: e, extendParams: t, on: n, emit: i}) {
        const r = "swiper-pagination";
        let s;
        t({
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: "bullets",
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: e => e,
                formatFractionTotal: e => e,
                bulletClass: `${r}-bullet`,
                bulletActiveClass: `${r}-bullet-active`,
                modifierClass: `${r}-`,
                currentClass: `${r}-current`,
                totalClass: `${r}-total`,
                hiddenClass: `${r}-hidden`,
                progressbarFillClass: `${r}-progressbar-fill`,
                progressbarOppositeClass: `${r}-progressbar-opposite`,
                clickableClass: `${r}-clickable`,
                lockClass: `${r}-lock`,
                horizontalClass: `${r}-horizontal`,
                verticalClass: `${r}-vertical`
            }
        }), e.pagination = {el: null, $el: null, bullets: []};
        let a = 0;

        function o() {
            return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length
        }

        function l(t, n) {
            const {bulletActiveClass: i} = e.params.pagination;
            t[n]().addClass(`${i}-${n}`)[n]().addClass(`${i}-${n}-${n}`)
        }

        function c() {
            const t = e.rtl, n = e.params.pagination;
            if (o()) return;
            const r = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                c = e.pagination.$el;
            let h;
            const u = e.params.loop ? Math.ceil((r - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;
            if (e.params.loop ? (h = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), h > r - 1 - 2 * e.loopedSlides && (h -= r - 2 * e.loopedSlides), h > u - 1 && (h -= u), h < 0 && "bullets" !== e.params.paginationType && (h = u + h)) : h = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === n.type && e.pagination.bullets && e.pagination.bullets.length > 0) {
                const i = e.pagination.bullets;
                let r, o, u;
                if (n.dynamicBullets && (s = i.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), c.css(e.isHorizontal() ? "width" : "height", s * (n.dynamicMainBullets + 4) + "px"), n.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (a += h - e.previousIndex, a > n.dynamicMainBullets - 1 ? a = n.dynamicMainBullets - 1 : a < 0 && (a = 0)), r = h - a, o = r + (Math.min(i.length, n.dynamicMainBullets) - 1), u = (o + r) / 2), i.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${n.bulletActiveClass}${e}`)).join(" ")), c.length > 1) i.each((e => {
                    const t = ol(e), i = t.index();
                    i === h && t.addClass(n.bulletActiveClass), n.dynamicBullets && (i >= r && i <= o && t.addClass(`${n.bulletActiveClass}-main`), i === r && l(t, "prev"), i === o && l(t, "next"))
                })); else {
                    const t = i.eq(h), s = t.index();
                    if (t.addClass(n.bulletActiveClass), n.dynamicBullets) {
                        const t = i.eq(r), a = i.eq(o);
                        for (let e = r; e <= o; e += 1) i.eq(e).addClass(`${n.bulletActiveClass}-main`);
                        if (e.params.loop) if (s >= i.length - n.dynamicMainBullets) {
                            for (let e = n.dynamicMainBullets; e >= 0; e -= 1) i.eq(i.length - e).addClass(`${n.bulletActiveClass}-main`);
                            i.eq(i.length - n.dynamicMainBullets - 1).addClass(`${n.bulletActiveClass}-prev`)
                        } else l(t, "prev"), l(a, "next"); else l(t, "prev"), l(a, "next")
                    }
                }
                if (n.dynamicBullets) {
                    const r = Math.min(i.length, n.dynamicMainBullets + 4), a = (s * r - s) / 2 - u * s,
                        o = t ? "right" : "left";
                    i.css(e.isHorizontal() ? o : "top", `${a}px`)
                }
            }
            if ("fraction" === n.type && (c.find(Yl(n.currentClass)).text(n.formatFractionCurrent(h + 1)), c.find(Yl(n.totalClass)).text(n.formatFractionTotal(u))), "progressbar" === n.type) {
                let t;
                t = n.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical";
                const i = (h + 1) / u;
                let r = 1, s = 1;
                "horizontal" === t ? r = i : s = i, c.find(Yl(n.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${r}) scaleY(${s})`).transition(e.params.speed)
            }
            "custom" === n.type && n.renderCustom ? (c.html(n.renderCustom(e, h + 1, u)), i("paginationRender", c[0])) : i("paginationUpdate", c[0]), e.params.watchOverflow && e.enabled && c[e.isLocked ? "addClass" : "removeClass"](n.lockClass)
        }

        function h() {
            const t = e.params.pagination;
            if (o()) return;
            const n = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                r = e.pagination.$el;
            let s = "";
            if ("bullets" === t.type) {
                let i = e.params.loop ? Math.ceil((n - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;
                e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && i > n && (i = n);
                for (let n = 0; n < i; n += 1) t.renderBullet ? s += t.renderBullet.call(e, n, t.bulletClass) : s += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`;
                r.html(s), e.pagination.bullets = r.find(Yl(t.bulletClass))
            }
            "fraction" === t.type && (s = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, r.html(s)), "progressbar" === t.type && (s = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, r.html(s)), "custom" !== t.type && i("paginationRender", e.pagination.$el[0])
        }

        function u() {
            e.params.pagination = Xl(e, e.originalParams.pagination, e.params.pagination, {el: "swiper-pagination"});
            const t = e.params.pagination;
            if (!t.el) return;
            let n = ol(t.el);
            0 !== n.length && (e.params.uniqueNavElements && "string" == typeof t.el && n.length > 1 && (n = e.$el.find(t.el), n.length > 1 && (n = n.filter((t => ol(t).parents(".swiper")[0] === e.el)))), "bullets" === t.type && t.clickable && n.addClass(t.clickableClass), n.addClass(t.modifierClass + t.type), n.addClass(t.modifierClass + e.params.direction), "bullets" === t.type && t.dynamicBullets && (n.addClass(`${t.modifierClass}${t.type}-dynamic`), a = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && n.addClass(t.progressbarOppositeClass), t.clickable && n.on("click", Yl(t.bulletClass), (function (t) {
                t.preventDefault();
                let n = ol(this).index() * e.params.slidesPerGroup;
                e.params.loop && (n += e.loopedSlides), e.slideTo(n)
            })), Object.assign(e.pagination, {$el: n, el: n[0]}), e.enabled || n.addClass(t.lockClass))
        }

        function d() {
            const t = e.params.pagination;
            if (o()) return;
            const n = e.pagination.$el;
            n.removeClass(t.hiddenClass), n.removeClass(t.modifierClass + t.type), n.removeClass(t.modifierClass + e.params.direction), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && n.off("click", Yl(t.bulletClass))
        }

        n("init", (() => {
            u(), h(), c()
        })), n("activeIndexChange", (() => {
            (e.params.loop || void 0 === e.snapIndex) && c()
        })), n("snapIndexChange", (() => {
            e.params.loop || c()
        })), n("slidesLengthChange", (() => {
            e.params.loop && (h(), c())
        })), n("snapGridLengthChange", (() => {
            e.params.loop || (h(), c())
        })), n("destroy", (() => {
            d()
        })), n("enable disable", (() => {
            const {$el: t} = e.pagination;
            t && t[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass)
        })), n("lock unlock", (() => {
            c()
        })), n("click", ((t, n) => {
            const r = n.target, {$el: s} = e.pagination;
            if (e.params.pagination.el && e.params.pagination.hideOnClick && s.length > 0 && !ol(r).hasClass(e.params.pagination.bulletClass)) {
                if (e.navigation && (e.navigation.nextEl && r === e.navigation.nextEl || e.navigation.prevEl && r === e.navigation.prevEl)) return;
                const t = s.hasClass(e.params.pagination.hiddenClass);
                i(!0 === t ? "paginationShow" : "paginationHide"), s.toggleClass(e.params.pagination.hiddenClass)
            }
        })), Object.assign(e.pagination, {render: h, update: c, init: u, destroy: d})
    }

    /**
     * @license
     * Copyright 2010-2021 Three.js Authors
     * SPDX-License-Identifier: MIT
     */Object.keys(Wl).forEach((e => {
        Object.keys(Wl[e]).forEach((t => {
            $l.prototype[t] = Wl[e][t]
        }))
    })), $l.use([function ({swiper: e, on: t, emit: n}) {
        const i = il();
        let r = null;
        const s = () => {
            e && !e.destroyed && e.initialized && (n("beforeResize"), n("resize"))
        }, a = () => {
            e && !e.destroyed && e.initialized && n("orientationchange")
        };
        t("init", (() => {
            e.params.resizeObserver && void 0 !== i.ResizeObserver ? e && !e.destroyed && e.initialized && (r = new ResizeObserver((t => {
                const {width: n, height: i} = e;
                let r = n, a = i;
                t.forEach((({contentBoxSize: t, contentRect: n, target: i}) => {
                    i && i !== e.el || (r = n ? n.width : (t[0] || t).inlineSize, a = n ? n.height : (t[0] || t).blockSize)
                })), r === n && a === i || s()
            })), r.observe(e.el)) : (i.addEventListener("resize", s), i.addEventListener("orientationchange", a))
        })), t("destroy", (() => {
            r && r.unobserve && e.el && (r.unobserve(e.el), r = null), i.removeEventListener("resize", s), i.removeEventListener("orientationchange", a)
        }))
    }, function ({swiper: e, extendParams: t, on: n, emit: i}) {
        const r = [], s = il(), a = (e, t = {}) => {
            const n = new (s.MutationObserver || s.WebkitMutationObserver)((e => {
                if (1 === e.length) return void i("observerUpdate", e[0]);
                const t = function () {
                    i("observerUpdate", e[0])
                };
                s.requestAnimationFrame ? s.requestAnimationFrame(t) : s.setTimeout(t, 0)
            }));
            n.observe(e, {
                attributes: void 0 === t.attributes || t.attributes,
                childList: void 0 === t.childList || t.childList,
                characterData: void 0 === t.characterData || t.characterData
            }), r.push(n)
        };
        t({observer: !1, observeParents: !1, observeSlideChildren: !1}), n("init", (() => {
            if (e.params.observer) {
                if (e.params.observeParents) {
                    const t = e.$el.parents();
                    for (let e = 0; e < t.length; e += 1) a(t[e])
                }
                a(e.$el[0], {childList: e.params.observeSlideChildren}), a(e.$wrapperEl[0], {attributes: !1})
            }
        })), n("destroy", (() => {
            r.forEach((e => {
                e.disconnect()
            })), r.splice(0, r.length)
        }))
    }]);
    const Jl = 100, Zl = 301, Ql = 302, ec = 306, tc = 1e3, nc = 1001, ic = 1002, rc = 1003, sc = 1004, ac = 1005,
        oc = 1006, lc = 1008, cc = 1009, hc = 1012, uc = 1014, dc = 1015, pc = 1016, fc = 1020, mc = 1022, gc = 1023,
        vc = 1026, _c = 1027, yc = 33776, xc = 33779, bc = 35840, wc = 35842, Tc = 37492, Sc = 37496, Ec = 2300,
        Mc = 2301, Ac = 2302, Lc = 2400, Cc = 2401, Rc = 2402, Pc = 2500, Ic = 3e3, Oc = 3001, Dc = 3007, Nc = 3002,
        Bc = 7680, kc = 35044, Uc = 35048, Fc = "300 es";

    class Hc {
        addEventListener(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
        }

        hasEventListener(e, t) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        }

        removeEventListener(e, t) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[e];
            if (void 0 !== n) {
                const e = n.indexOf(t);
                -1 !== e && n.splice(e, 1)
            }
        }

        dispatchEvent(e) {
            if (void 0 === this._listeners) return;
            const t = this._listeners[e.type];
            if (void 0 !== t) {
                e.target = this;
                const n = t.slice(0);
                for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
                e.target = null
            }
        }
    }

    let zc = 1234567;
    const Gc = Math.PI / 180, Vc = 180 / Math.PI, Wc = [];
    for (let e = 0; e < 256; e++) Wc[e] = (e < 16 ? "0" : "") + e.toString(16);
    const jc = "undefined" != typeof crypto && "randomUUID" in crypto;

    function $c() {
        if (jc) return crypto.randomUUID().toUpperCase();
        const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0,
            n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0;
        return (Wc[255 & e] + Wc[e >> 8 & 255] + Wc[e >> 16 & 255] + Wc[e >> 24 & 255] + "-" + Wc[255 & t] + Wc[t >> 8 & 255] + "-" + Wc[t >> 16 & 15 | 64] + Wc[t >> 24 & 255] + "-" + Wc[63 & n | 128] + Wc[n >> 8 & 255] + "-" + Wc[n >> 16 & 255] + Wc[n >> 24 & 255] + Wc[255 & i] + Wc[i >> 8 & 255] + Wc[i >> 16 & 255] + Wc[i >> 24 & 255]).toUpperCase()
    }

    function Xc(e, t, n) {
        return Math.max(t, Math.min(n, e))
    }

    function qc(e, t) {
        return (e % t + t) % t
    }

    function Yc(e, t, n) {
        return (1 - n) * e + n * t
    }

    function Kc(e) {
        return 0 == (e & e - 1) && 0 !== e
    }

    function Jc(e) {
        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
    }

    function Zc(e) {
        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
    }

    var Qc = Object.freeze({
        __proto__: null,
        DEG2RAD: Gc,
        RAD2DEG: Vc,
        generateUUID: $c,
        clamp: Xc,
        euclideanModulo: qc,
        mapLinear: function (e, t, n, i, r) {
            return i + (e - t) * (r - i) / (n - t)
        },
        inverseLerp: function (e, t, n) {
            return e !== t ? (n - e) / (t - e) : 0
        },
        lerp: Yc,
        damp: function (e, t, n, i) {
            return Yc(e, t, 1 - Math.exp(-n * i))
        },
        pingpong: function (e, t = 1) {
            return t - Math.abs(qc(e, 2 * t) - t)
        },
        smoothstep: function (e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
        },
        smootherstep: function (e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function (e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function (e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function (e) {
            return e * (.5 - Math.random())
        },
        seededRandom: function (e) {
            return void 0 !== e && (zc = e % 2147483647), zc = 16807 * zc % 2147483647, (zc - 1) / 2147483646
        },
        degToRad: function (e) {
            return e * Gc
        },
        radToDeg: function (e) {
            return e * Vc
        },
        isPowerOfTwo: Kc,
        ceilPowerOfTwo: Jc,
        floorPowerOfTwo: Zc,
        setQuaternionFromProperEuler: function (e, t, n, i, r) {
            const s = Math.cos, a = Math.sin, o = s(n / 2), l = a(n / 2), c = s((t + i) / 2), h = a((t + i) / 2),
                u = s((t - i) / 2), d = a((t - i) / 2), p = s((i - t) / 2), f = a((i - t) / 2);
            switch (r) {
                case"XYX":
                    e.set(o * h, l * u, l * d, o * c);
                    break;
                case"YZY":
                    e.set(l * d, o * h, l * u, o * c);
                    break;
                case"ZXZ":
                    e.set(l * u, l * d, o * h, o * c);
                    break;
                case"XZX":
                    e.set(o * h, l * f, l * p, o * c);
                    break;
                case"YXY":
                    e.set(l * p, o * h, l * f, o * c);
                    break;
                case"ZYZ":
                    e.set(l * f, l * p, o * h, o * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        }
    });

    class eh {
        constructor(e = 0, t = 0) {
            this.x = e, this.y = t
        }

        get width() {
            return this.x
        }

        set width(e) {
            this.x = e
        }

        get height() {
            return this.y
        }

        set height(e) {
            this.y = e
        }

        set(e, t) {
            return this.x = e, this.y = t, this
        }

        setScalar(e) {
            return this.x = e, this.y = e, this
        }

        setX(e) {
            return this.x = e, this
        }

        setY(e) {
            return this.y = e, this
        }

        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }

        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }

        clone() {
            return new this.constructor(this.x, this.y)
        }

        copy(e) {
            return this.x = e.x, this.y = e.y, this
        }

        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        }

        addScalar(e) {
            return this.x += e, this.y += e, this
        }

        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        }

        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        }

        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        }

        subScalar(e) {
            return this.x -= e, this.y -= e, this
        }

        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        }

        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this
        }

        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this
        }

        divide(e) {
            return this.x /= e.x, this.y /= e.y, this
        }

        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }

        applyMatrix3(e) {
            const t = this.x, n = this.y, i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
        }

        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        }

        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        }

        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        }

        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        }

        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }

        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }

        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }

        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }

        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        }

        negate() {
            return this.x = -this.x, this.y = -this.y, this
        }

        dot(e) {
            return this.x * e.x + this.y * e.y
        }

        cross(e) {
            return this.x * e.y - this.y * e.x
        }

        lengthSq() {
            return this.x * this.x + this.y * this.y
        }

        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }

        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }

        normalize() {
            return this.divideScalar(this.length() || 1)
        }

        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }

        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }

        distanceToSquared(e) {
            const t = this.x - e.x, n = this.y - e.y;
            return t * t + n * n
        }

        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }

        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }

        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        }

        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
        }

        equals(e) {
            return e.x === this.x && e.y === this.y
        }

        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this
        }

        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e
        }

        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        }

        rotateAround(e, t) {
            const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, s = this.y - e.y;
            return this.x = r * n - s * i + e.x, this.y = r * i + s * n + e.y, this
        }

        random() {
            return this.x = Math.random(), this.y = Math.random(), this
        }

        * [Symbol.iterator]() {
            yield this.x, yield this.y
        }
    }

    eh.prototype.isVector2 = !0;

    class th {
        constructor() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        set(e, t, n, i, r, s, a, o, l) {
            const c = this.elements;
            return c[0] = e, c[1] = i, c[2] = a, c[3] = t, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
        }

        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }

        copy(e) {
            const t = this.elements, n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        }

        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        }

        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        }

        multiply(e) {
            return this.multiplyMatrices(this, e)
        }

        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }

        multiplyMatrices(e, t) {
            const n = e.elements, i = t.elements, r = this.elements, s = n[0], a = n[3], o = n[6], l = n[1], c = n[4],
                h = n[7], u = n[2], d = n[5], p = n[8], f = i[0], m = i[3], g = i[6], v = i[1], _ = i[4], y = i[7],
                x = i[2], b = i[5], w = i[8];
            return r[0] = s * f + a * v + o * x, r[3] = s * m + a * _ + o * b, r[6] = s * g + a * y + o * w, r[1] = l * f + c * v + h * x, r[4] = l * m + c * _ + h * b, r[7] = l * g + c * y + h * w, r[2] = u * f + d * v + p * x, r[5] = u * m + d * _ + p * b, r[8] = u * g + d * y + p * w, this
        }

        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        }

        determinant() {
            const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7],
                c = e[8];
            return t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o
        }

        invert() {
            const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7],
                c = e[8], h = c * s - a * l, u = a * o - c * r, d = l * r - s * o, p = t * h + n * u + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return e[0] = h * f, e[1] = (i * l - c * n) * f, e[2] = (a * n - i * s) * f, e[3] = u * f, e[4] = (c * t - i * o) * f, e[5] = (i * r - a * t) * f, e[6] = d * f, e[7] = (n * o - l * t) * f, e[8] = (s * t - n * r) * f, this
        }

        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        }

        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }

        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        }

        setUvTransform(e, t, n, i, r, s, a) {
            const o = Math.cos(r), l = Math.sin(r);
            return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -i * l, i * o, -i * (-l * s + o * a) + a + t, 0, 0, 1), this
        }

        scale(e, t) {
            const n = this.elements;
            return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
        }

        rotate(e) {
            const t = Math.cos(e), n = Math.sin(e), i = this.elements, r = i[0], s = i[3], a = i[6], o = i[1], l = i[4],
                c = i[7];
            return i[0] = t * r + n * o, i[3] = t * s + n * l, i[6] = t * a + n * c, i[1] = -n * r + t * o, i[4] = -n * s + t * l, i[7] = -n * a + t * c, this
        }

        translate(e, t) {
            const n = this.elements;
            return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
        }

        equals(e) {
            const t = this.elements, n = e.elements;
            for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
            return !0
        }

        fromArray(e, t = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        }

        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }

        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
    }

    function nh(e) {
        if (0 === e.length) return -1 / 0;
        let t = e[0];
        for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
        return t
    }

    function ih(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e)
    }

    let rh;
    th.prototype.isMatrix3 = !0;

    class sh {
        static getDataURL(e) {
            if (/^data:/i.test(e.src)) return e.src;
            if ("undefined" == typeof HTMLCanvasElement) return e.src;
            let t;
            if (e instanceof HTMLCanvasElement) t = e; else {
                void 0 === rh && (rh = ih("canvas")), rh.width = e.width, rh.height = e.height;
                const n = rh.getContext("2d");
                e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = rh
            }
            return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
        }
    }

    let ah = 0;

    class oh extends Hc {
        constructor(e = oh.DEFAULT_IMAGE, t = oh.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, c = 3e3) {
            super(), Object.defineProperty(this, "id", {value: ah++}), this.uuid = $c(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new eh(0, 0), this.repeat = new eh(1, 1), this.center = new eh(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new th, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1
        }

        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        copy(e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        }

        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            const n = {
                metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"},
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                const i = this.image;
                if (void 0 === i.uuid && (i.uuid = $c()), !t && void 0 === e.images[i.uuid]) {
                    let t;
                    if (Array.isArray(i)) {
                        t = [];
                        for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(lh(i[e].image)) : t.push(lh(i[e]))
                    } else t = lh(i);
                    e.images[i.uuid] = {uuid: i.uuid, url: t}
                }
                n.image = i.uuid
            }
            return t || (e.textures[this.uuid] = n), n
        }

        dispose() {
            this.dispatchEvent({type: "dispose"})
        }

        transformUv(e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                case tc:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case nc:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case ic:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                case tc:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case nc:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case ic:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }

        set needsUpdate(e) {
            !0 === e && this.version++
        }
    }

    function lh(e) {
        return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? sh.getDataURL(e) : e.data ? {
            data: Array.prototype.slice.call(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
    }

    oh.DEFAULT_IMAGE = void 0, oh.DEFAULT_MAPPING = 300, oh.prototype.isTexture = !0;

    class ch {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            this.x = e, this.y = t, this.z = n, this.w = i
        }

        get width() {
            return this.z
        }

        set width(e) {
            this.z = e
        }

        get height() {
            return this.w
        }

        set height(e) {
            this.w = e
        }

        set(e, t, n, i) {
            return this.x = e, this.y = t, this.z = n, this.w = i, this
        }

        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        }

        setX(e) {
            return this.x = e, this
        }

        setY(e) {
            return this.y = e, this
        }

        setZ(e) {
            return this.z = e, this
        }

        setW(e) {
            return this.w = e, this
        }

        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }

        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }

        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }

        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        }

        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        }

        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        }

        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        }

        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        }

        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        }

        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        }

        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        }

        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
        }

        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        }

        applyMatrix4(e) {
            const t = this.x, n = this.y, i = this.z, r = this.w, s = e.elements;
            return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r, this
        }

        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }

        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        }

        setAxisAngleFromRotationMatrix(e) {
            let t, n, i, r;
            const s = .01, a = .1, o = e.elements, l = o[0], c = o[4], h = o[8], u = o[1], d = o[5], p = o[9], f = o[2],
                m = o[6], g = o[10];
            if (Math.abs(c - u) < s && Math.abs(h - f) < s && Math.abs(p - m) < s) {
                if (Math.abs(c + u) < a && Math.abs(h + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                const e = (l + 1) / 2, o = (d + 1) / 2, v = (g + 1) / 2, _ = (c + u) / 4, y = (h + f) / 4,
                    x = (p + m) / 4;
                return e > o && e > v ? e < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = _ / n, r = y / n) : o > v ? o < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = _ / i, r = x / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = y / r, i = x / r), this.set(n, i, r, t), this
            }
            let v = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c));
            return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (h - f) / v, this.z = (u - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
        }

        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        }

        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        }

        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        }

        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
        }

        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }

        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        }

        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        }

        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        }

        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        }

        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        }

        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }

        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }

        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }

        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }

        normalize() {
            return this.divideScalar(this.length() || 1)
        }

        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }

        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        }

        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
        }

        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }

        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        }

        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        }

        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }

        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        }

        * [Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w
        }
    }

    ch.prototype.isVector4 = !0;

    class hh extends Hc {
        constructor(e, t, n = {}) {
            super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new ch(0, 0, e, t), this.scissorTest = !1, this.viewport = new ch(0, 0, e, t), this.texture = new oh(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                width: e,
                height: t,
                depth: 1
            }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : oc, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }

        setTexture(e) {
            e.image = {width: this.width, height: this.height, depth: this.depth}, this.texture = e
        }

        setSize(e, t, n = 1) {
            this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        copy(e) {
            return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = {...this.texture.image}, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        }

        dispose() {
            this.dispatchEvent({type: "dispose"})
        }
    }

    hh.prototype.isWebGLRenderTarget = !0;
    (class extends hh {
        constructor(e, t, n) {
            super(e, t);
            const i = this.texture;
            this.texture = [];
            for (let e = 0; e < n; e++) this.texture[e] = i.clone()
        }

        setSize(e, t, n = 1) {
            if (this.width !== e || this.height !== t || this.depth !== n) {
                this.width = e, this.height = t, this.depth = n;
                for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n;
                this.dispose()
            }
            return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
        }

        copy(e) {
            this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0;
            for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone();
            return this
        }
    }).prototype.isWebGLMultipleRenderTargets = !0;

    class uh extends hh {
        constructor(e, t, n) {
            super(e, t, n), this.samples = 4
        }

        copy(e) {
            return super.copy.call(this, e), this.samples = e.samples, this
        }
    }

    uh.prototype.isWebGLMultisampleRenderTarget = !0;

    class dh {
        constructor(e = 0, t = 0, n = 0, i = 1) {
            this._x = e, this._y = t, this._z = n, this._w = i
        }

        static slerp(e, t, n, i) {
            return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, i)
        }

        static slerpFlat(e, t, n, i, r, s, a) {
            let o = n[i + 0], l = n[i + 1], c = n[i + 2], h = n[i + 3];
            const u = r[s + 0], d = r[s + 1], p = r[s + 2], f = r[s + 3];
            if (0 === a) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = h);
            if (1 === a) return e[t + 0] = u, e[t + 1] = d, e[t + 2] = p, void (e[t + 3] = f);
            if (h !== f || o !== u || l !== d || c !== p) {
                let e = 1 - a;
                const t = o * u + l * d + c * p + h * f, n = t >= 0 ? 1 : -1, i = 1 - t * t;
                if (i > Number.EPSILON) {
                    const r = Math.sqrt(i), s = Math.atan2(r, t * n);
                    e = Math.sin(e * s) / r, a = Math.sin(a * s) / r
                }
                const r = a * n;
                if (o = o * e + u * r, l = l * e + d * r, c = c * e + p * r, h = h * e + f * r, e === 1 - a) {
                    const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                    o *= e, l *= e, c *= e, h *= e
                }
            }
            e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h
        }

        static multiplyQuaternionsFlat(e, t, n, i, r, s) {
            const a = n[i], o = n[i + 1], l = n[i + 2], c = n[i + 3], h = r[s], u = r[s + 1], d = r[s + 2],
                p = r[s + 3];
            return e[t] = a * p + c * h + o * d - l * u, e[t + 1] = o * p + c * u + l * h - a * d, e[t + 2] = l * p + c * d + a * u - o * h, e[t + 3] = c * p - a * h - o * u - l * d, e
        }

        get x() {
            return this._x
        }

        set x(e) {
            this._x = e, this._onChangeCallback()
        }

        get y() {
            return this._y
        }

        set y(e) {
            this._y = e, this._onChangeCallback()
        }

        get z() {
            return this._z
        }

        set z(e) {
            this._z = e, this._onChangeCallback()
        }

        get w() {
            return this._w
        }

        set w(e) {
            this._w = e, this._onChangeCallback()
        }

        set(e, t, n, i) {
            return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
        }

        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }

        copy(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
        }

        setFromEuler(e, t) {
            if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            const n = e._x, i = e._y, r = e._z, s = e._order, a = Math.cos, o = Math.sin, l = a(n / 2), c = a(i / 2),
                h = a(r / 2), u = o(n / 2), d = o(i / 2), p = o(r / 2);
            switch (s) {
                case"XYZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case"YXZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case"ZXY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case"ZYX":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case"YZX":
                    this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case"XZY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
            }
            return !1 !== t && this._onChangeCallback(), this
        }

        setFromAxisAngle(e, t) {
            const n = t / 2, i = Math.sin(n);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        }

        setFromRotationMatrix(e) {
            const t = e.elements, n = t[0], i = t[4], r = t[8], s = t[1], a = t[5], o = t[9], l = t[2], c = t[6],
                h = t[10], u = n + a + h;
            if (u > 0) {
                const e = .5 / Math.sqrt(u + 1);
                this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (s - i) * e
            } else if (n > a && n > h) {
                const e = 2 * Math.sqrt(1 + n - a - h);
                this._w = (c - o) / e, this._x = .25 * e, this._y = (i + s) / e, this._z = (r + l) / e
            } else if (a > h) {
                const e = 2 * Math.sqrt(1 + a - n - h);
                this._w = (r - l) / e, this._x = (i + s) / e, this._y = .25 * e, this._z = (o + c) / e
            } else {
                const e = 2 * Math.sqrt(1 + h - n - a);
                this._w = (s - i) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e
            }
            return this._onChangeCallback(), this
        }

        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
        }

        angleTo(e) {
            return 2 * Math.acos(Math.abs(Xc(this.dot(e), -1, 1)))
        }

        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (0 === n) return this;
            const i = Math.min(1, t / n);
            return this.slerp(e, i), this
        }

        identity() {
            return this.set(0, 0, 0, 1)
        }

        invert() {
            return this.conjugate()
        }

        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }

        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }

        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }

        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }

        normalize() {
            let e = this.length();
            return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
        }

        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        }

        premultiply(e) {
            return this.multiplyQuaternions(e, this)
        }

        multiplyQuaternions(e, t) {
            const n = e._x, i = e._y, r = e._z, s = e._w, a = t._x, o = t._y, l = t._z, c = t._w;
            return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this
        }

        slerp(e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            const n = this._x, i = this._y, r = this._z, s = this._w;
            let a = s * e._w + n * e._x + i * e._y + r * e._z;
            if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
            const o = 1 - a * a;
            if (o <= Number.EPSILON) {
                const e = 1 - t;
                return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this
            }
            const l = Math.sqrt(o), c = Math.atan2(l, a), h = Math.sin((1 - t) * c) / l, u = Math.sin(t * c) / l;
            return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
        }

        slerpQuaternions(e, t, n) {
            this.copy(e).slerp(t, n)
        }

        random() {
            const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), i = 2 * Math.PI * Math.random(),
                r = 2 * Math.PI * Math.random();
            return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
        }

        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }

        fromArray(e, t = 0) {
            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
        }

        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        }

        fromBufferAttribute(e, t) {
            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
        }

        _onChange(e) {
            return this._onChangeCallback = e, this
        }

        _onChangeCallback() {
        }
    }

    dh.prototype.isQuaternion = !0;

    class ph {
        constructor(e = 0, t = 0, n = 0) {
            this.x = e, this.y = t, this.z = n
        }

        set(e, t, n) {
            return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
        }

        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this
        }

        setX(e) {
            return this.x = e, this
        }

        setY(e) {
            return this.y = e, this
        }

        setZ(e) {
            return this.z = e, this
        }

        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }

        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }

        clone() {
            return new this.constructor(this.x, this.y, this.z)
        }

        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        }

        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        }

        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this
        }

        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        }

        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        }

        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        }

        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        }

        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        }

        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        }

        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        }

        multiplyVectors(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        }

        applyEuler(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(mh.setFromEuler(e))
        }

        applyAxisAngle(e, t) {
            return this.applyQuaternion(mh.setFromAxisAngle(e, t))
        }

        applyMatrix3(e) {
            const t = this.x, n = this.y, i = this.z, r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
        }

        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize()
        }

        applyMatrix4(e) {
            const t = this.x, n = this.y, i = this.z, r = e.elements, s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s, this
        }

        applyQuaternion(e) {
            const t = this.x, n = this.y, i = this.z, r = e.x, s = e.y, a = e.z, o = e.w, l = o * t + s * i - a * n,
                c = o * n + a * t - r * i, h = o * i + r * n - s * t, u = -r * t - s * n - a * i;
            return this.x = l * o + u * -r + c * -a - h * -s, this.y = c * o + u * -s + h * -r - l * -a, this.z = h * o + u * -a + l * -s - c * -r, this
        }

        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }

        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        }

        transformDirection(e) {
            const t = this.x, n = this.y, i = this.z, r = e.elements;
            return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
        }

        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        }

        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }

        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        }

        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        }

        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        }

        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
        }

        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }

        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }

        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }

        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }

        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        }

        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }

        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }

        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }

        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }

        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }

        normalize() {
            return this.divideScalar(this.length() || 1)
        }

        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }

        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        }

        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
        }

        cross(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
        }

        crossVectors(e, t) {
            const n = e.x, i = e.y, r = e.z, s = t.x, a = t.y, o = t.z;
            return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this
        }

        projectOnVector(e) {
            const t = e.lengthSq();
            if (0 === t) return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        }

        projectOnPlane(e) {
            return fh.copy(this).projectOnVector(e), this.sub(fh)
        }

        reflect(e) {
            return this.sub(fh.copy(e).multiplyScalar(2 * this.dot(e)))
        }

        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Xc(n, -1, 1))
        }

        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }

        distanceToSquared(e) {
            const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
            return t * t + n * n + i * i
        }

        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }

        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }

        setFromSphericalCoords(e, t, n) {
            const i = Math.sin(t) * e;
            return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
        }

        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }

        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
        }

        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this
        }

        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(),
                i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = i, this
        }

        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, 4 * t)
        }

        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, 3 * t)
        }

        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }

        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        }

        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        }

        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }

        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }

        randomDirection() {
            const e = 2 * (Math.random() - .5), t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
            return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
        }

        * [Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z
        }
    }

    ph.prototype.isVector3 = !0;
    const fh = new ph, mh = new dh;

    class gh {
        constructor(e = new ph(1 / 0, 1 / 0, 1 / 0), t = new ph(-1 / 0, -1 / 0, -1 / 0)) {
            this.min = e, this.max = t
        }

        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        }

        setFromArray(e) {
            let t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0;
            for (let o = 0, l = e.length; o < l; o += 3) {
                const l = e[o], c = e[o + 1], h = e[o + 2];
                l < t && (t = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > a && (a = h)
            }
            return this.min.set(t, n, i), this.max.set(r, s, a), this
        }

        setFromBufferAttribute(e) {
            let t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0;
            for (let o = 0, l = e.count; o < l; o++) {
                const l = e.getX(o), c = e.getY(o), h = e.getZ(o);
                l < t && (t = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > a && (a = h)
            }
            return this.min.set(t, n, i), this.max.set(r, s, a), this
        }

        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        }

        setFromCenterAndSize(e, t) {
            const n = _h.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        }

        setFromObject(e) {
            return this.makeEmpty(), this.expandByObject(e)
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        }

        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        }

        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }

        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }

        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }

        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this
        }

        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this
        }

        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        }

        expandByObject(e) {
            e.updateWorldMatrix(!1, !1);
            const t = e.geometry;
            void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), yh.copy(t.boundingBox), yh.applyMatrix4(e.matrixWorld), this.union(yh));
            const n = e.children;
            for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
            return this
        }

        containsPoint(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        }

        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }

        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }

        intersectsBox(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        }

        intersectsSphere(e) {
            return this.clampPoint(e.center, _h), _h.distanceToSquared(e.center) <= e.radius * e.radius
        }

        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
        }

        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(Mh), Ah.subVectors(this.max, Mh), xh.subVectors(e.a, Mh), bh.subVectors(e.b, Mh), wh.subVectors(e.c, Mh), Th.subVectors(bh, xh), Sh.subVectors(wh, bh), Eh.subVectors(xh, wh);
            let t = [0, -Th.z, Th.y, 0, -Sh.z, Sh.y, 0, -Eh.z, Eh.y, Th.z, 0, -Th.x, Sh.z, 0, -Sh.x, Eh.z, 0, -Eh.x, -Th.y, Th.x, 0, -Sh.y, Sh.x, 0, -Eh.y, Eh.x, 0];
            return !!Rh(t, xh, bh, wh, Ah) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Rh(t, xh, bh, wh, Ah) && (Lh.crossVectors(Th, Sh), t = [Lh.x, Lh.y, Lh.z], Rh(t, xh, bh, wh, Ah)))
        }

        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }

        distanceToPoint(e) {
            return _h.copy(e).clamp(this.min, this.max).sub(e).length()
        }

        getBoundingSphere(e) {
            return this.getCenter(e.center), e.radius = .5 * this.getSize(_h).length(), e
        }

        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        }

        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        }

        applyMatrix4(e) {
            return this.isEmpty() || (vh[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), vh[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), vh[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), vh[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), vh[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), vh[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), vh[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), vh[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(vh)), this
        }

        translate(e) {
            return this.min.add(e), this.max.add(e), this
        }

        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }

    gh.prototype.isBox3 = !0;
    const vh = [new ph, new ph, new ph, new ph, new ph, new ph, new ph, new ph], _h = new ph, yh = new gh, xh = new ph,
        bh = new ph, wh = new ph, Th = new ph, Sh = new ph, Eh = new ph, Mh = new ph, Ah = new ph, Lh = new ph,
        Ch = new ph;

    function Rh(e, t, n, i, r) {
        for (let s = 0, a = e.length - 3; s <= a; s += 3) {
            Ch.fromArray(e, s);
            const a = r.x * Math.abs(Ch.x) + r.y * Math.abs(Ch.y) + r.z * Math.abs(Ch.z), o = t.dot(Ch), l = n.dot(Ch),
                c = i.dot(Ch);
            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
        }
        return !0
    }

    const Ph = new gh, Ih = new ph, Oh = new ph, Dh = new ph;

    class Nh {
        constructor(e = new ph, t = -1) {
            this.center = e, this.radius = t
        }

        set(e, t) {
            return this.center.copy(e), this.radius = t, this
        }

        setFromPoints(e, t) {
            const n = this.center;
            void 0 !== t ? n.copy(t) : Ph.setFromPoints(e).getCenter(n);
            let i = 0;
            for (let t = 0, r = e.length; t < r; t++) i = Math.max(i, n.distanceToSquared(e[t]));
            return this.radius = Math.sqrt(i), this
        }

        copy(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        }

        isEmpty() {
            return this.radius < 0
        }

        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this
        }

        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }

        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius
        }

        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }

        intersectsBox(e) {
            return e.intersectsSphere(this)
        }

        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }

        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        }

        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
        }

        applyMatrix4(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        }

        translate(e) {
            return this.center.add(e), this
        }

        expandByPoint(e) {
            Dh.subVectors(e, this.center);
            const t = Dh.lengthSq();
            if (t > this.radius * this.radius) {
                const e = Math.sqrt(t), n = .5 * (e - this.radius);
                this.center.add(Dh.multiplyScalar(n / e)), this.radius += n
            }
            return this
        }

        union(e) {
            return Oh.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Ih.copy(e.center).add(Oh)), this.expandByPoint(Ih.copy(e.center).sub(Oh)), this
        }

        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }

        clone() {
            return (new this.constructor).copy(this)
        }
    }

    const Bh = new ph, kh = new ph, Uh = new ph, Fh = new ph, Hh = new ph, zh = new ph, Gh = new ph;

    class Vh {
        constructor(e = new ph, t = new ph(0, 0, -1)) {
            this.origin = e, this.direction = t
        }

        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        }

        copy(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        }

        at(e, t) {
            return t.copy(this.direction).multiplyScalar(e).add(this.origin)
        }

        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        }

        recast(e) {
            return this.origin.copy(this.at(e, Bh)), this
        }

        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
        }

        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }

        distanceSqToPoint(e) {
            const t = Bh.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (Bh.copy(this.direction).multiplyScalar(t).add(this.origin), Bh.distanceToSquared(e))
        }

        distanceSqToSegment(e, t, n, i) {
            kh.copy(e).add(t).multiplyScalar(.5), Uh.copy(t).sub(e).normalize(), Fh.copy(this.origin).sub(kh);
            const r = .5 * e.distanceTo(t), s = -this.direction.dot(Uh), a = Fh.dot(this.direction), o = -Fh.dot(Uh),
                l = Fh.lengthSq(), c = Math.abs(1 - s * s);
            let h, u, d, p;
            if (c > 0) if (h = s * o - a, u = s * a - o, p = r * c, h >= 0) if (u >= -p) if (u <= p) {
                const e = 1 / c;
                h *= e, u *= e, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
            } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l; else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l; else u <= -p ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l); else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
            return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Uh).multiplyScalar(u).add(kh), d
        }

        intersectSphere(e, t) {
            Bh.subVectors(e.center, this.origin);
            const n = Bh.dot(this.direction), i = Bh.dot(Bh) - n * n, r = e.radius * e.radius;
            if (i > r) return null;
            const s = Math.sqrt(r - i), a = n - s, o = n + s;
            return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
        }

        intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }

        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        }

        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return null === n ? null : this.at(n, t)
        }

        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            if (0 === t) return !0;
            return e.normal.dot(this.direction) * t < 0
        }

        intersectBox(e, t) {
            let n, i, r, s, a, o;
            const l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin;
            return l >= 0 ? (n = (e.min.x - u.x) * l, i = (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l, i = (e.min.x - u.x) * l), c >= 0 ? (r = (e.min.y - u.y) * c, s = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c, s = (e.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (a = (e.min.z - u.z) * h, o = (e.max.z - u.z) * h) : (a = (e.max.z - u.z) * h, o = (e.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
        }

        intersectsBox(e) {
            return null !== this.intersectBox(e, Bh)
        }

        intersectTriangle(e, t, n, i, r) {
            Hh.subVectors(t, e), zh.subVectors(n, e), Gh.crossVectors(Hh, zh);
            let s, a = this.direction.dot(Gh);
            if (a > 0) {
                if (i) return null;
                s = 1
            } else {
                if (!(a < 0)) return null;
                s = -1, a = -a
            }
            Fh.subVectors(this.origin, e);
            const o = s * this.direction.dot(zh.crossVectors(Fh, zh));
            if (o < 0) return null;
            const l = s * this.direction.dot(Hh.cross(Fh));
            if (l < 0) return null;
            if (o + l > a) return null;
            const c = -s * Fh.dot(Gh);
            return c < 0 ? null : this.at(c / a, r)
        }

        applyMatrix4(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        }

        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }

        clone() {
            return (new this.constructor).copy(this)
        }
    }

    class Wh {
        constructor() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        set(e, t, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
            const g = this.elements;
            return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
        }

        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }

        clone() {
            return (new Wh).fromArray(this.elements)
        }

        copy(e) {
            const t = this.elements, n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
        }

        copyPosition(e) {
            const t = this.elements, n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
        }

        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
        }

        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        }

        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
        }

        extractRotation(e) {
            const t = this.elements, n = e.elements, i = 1 / jh.setFromMatrixColumn(e, 0).length(),
                r = 1 / jh.setFromMatrixColumn(e, 1).length(), s = 1 / jh.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }

        makeRotationFromEuler(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            const t = this.elements, n = e.x, i = e.y, r = e.z, s = Math.cos(n), a = Math.sin(n), o = Math.cos(i),
                l = Math.sin(i), c = Math.cos(r), h = Math.sin(r);
            if ("XYZ" === e.order) {
                const e = s * c, n = s * h, i = a * c, r = a * h;
                t[0] = o * c, t[4] = -o * h, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -a * o, t[2] = r - e * l, t[6] = i + n * l, t[10] = s * o
            } else if ("YXZ" === e.order) {
                const e = o * c, n = o * h, i = l * c, r = l * h;
                t[0] = e + r * a, t[4] = i * a - n, t[8] = s * l, t[1] = s * h, t[5] = s * c, t[9] = -a, t[2] = n * a - i, t[6] = r + e * a, t[10] = s * o
            } else if ("ZXY" === e.order) {
                const e = o * c, n = o * h, i = l * c, r = l * h;
                t[0] = e - r * a, t[4] = -s * h, t[8] = i + n * a, t[1] = n + i * a, t[5] = s * c, t[9] = r - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o
            } else if ("ZYX" === e.order) {
                const e = s * c, n = s * h, i = a * c, r = a * h;
                t[0] = o * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = o * h, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = a * o, t[10] = s * o
            } else if ("YZX" === e.order) {
                const e = s * o, n = s * l, i = a * o, r = a * l;
                t[0] = o * c, t[4] = r - e * h, t[8] = i * h + n, t[1] = h, t[5] = s * c, t[9] = -a * c, t[2] = -l * c, t[6] = n * h + i, t[10] = e - r * h
            } else if ("XZY" === e.order) {
                const e = s * o, n = s * l, i = a * o, r = a * l;
                t[0] = o * c, t[4] = -h, t[8] = l * c, t[1] = e * h + r, t[5] = s * c, t[9] = n * h - i, t[2] = i * h - n, t[6] = a * c, t[10] = r * h + e
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }

        makeRotationFromQuaternion(e) {
            return this.compose(Xh, e, qh)
        }

        lookAt(e, t, n) {
            const i = this.elements;
            return Jh.subVectors(e, t), 0 === Jh.lengthSq() && (Jh.z = 1), Jh.normalize(), Yh.crossVectors(n, Jh), 0 === Yh.lengthSq() && (1 === Math.abs(n.z) ? Jh.x += 1e-4 : Jh.z += 1e-4, Jh.normalize(), Yh.crossVectors(n, Jh)), Yh.normalize(), Kh.crossVectors(Jh, Yh), i[0] = Yh.x, i[4] = Kh.x, i[8] = Jh.x, i[1] = Yh.y, i[5] = Kh.y, i[9] = Jh.y, i[2] = Yh.z, i[6] = Kh.z, i[10] = Jh.z, this
        }

        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        }

        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }

        multiplyMatrices(e, t) {
            const n = e.elements, i = t.elements, r = this.elements, s = n[0], a = n[4], o = n[8], l = n[12], c = n[1],
                h = n[5], u = n[9], d = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3], _ = n[7], y = n[11],
                x = n[15], b = i[0], w = i[4], T = i[8], S = i[12], E = i[1], M = i[5], A = i[9], L = i[13], C = i[2],
                R = i[6], P = i[10], I = i[14], O = i[3], D = i[7], N = i[11], B = i[15];
            return r[0] = s * b + a * E + o * C + l * O, r[4] = s * w + a * M + o * R + l * D, r[8] = s * T + a * A + o * P + l * N, r[12] = s * S + a * L + o * I + l * B, r[1] = c * b + h * E + u * C + d * O, r[5] = c * w + h * M + u * R + d * D, r[9] = c * T + h * A + u * P + d * N, r[13] = c * S + h * L + u * I + d * B, r[2] = p * b + f * E + m * C + g * O, r[6] = p * w + f * M + m * R + g * D, r[10] = p * T + f * A + m * P + g * N, r[14] = p * S + f * L + m * I + g * B, r[3] = v * b + _ * E + y * C + x * O, r[7] = v * w + _ * M + y * R + x * D, r[11] = v * T + _ * A + y * P + x * N, r[15] = v * S + _ * L + y * I + x * B, this
        }

        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        }

        determinant() {
            const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], s = e[1], a = e[5], o = e[9], l = e[13],
                c = e[2], h = e[6], u = e[10], d = e[14];
            return e[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) + e[7] * (+t * o * d - t * l * u + r * s * u - i * s * d + i * l * c - r * o * c) + e[11] * (+t * l * h - t * a * d - r * s * h + n * s * d + r * a * c - n * l * c) + e[15] * (-i * a * c - t * o * h + t * a * u + i * s * h - n * s * u + n * o * c)
        }

        transpose() {
            const e = this.elements;
            let t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        }

        setPosition(e, t, n) {
            const i = this.elements;
            return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
        }

        invert() {
            const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7],
                c = e[8], h = e[9], u = e[10], d = e[11], p = e[12], f = e[13], m = e[14], g = e[15],
                v = h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g,
                _ = p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g,
                y = c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g,
                x = p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m,
                b = t * v + n * _ + i * y + r * x;
            if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / b;
            return e[0] = v * w, e[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * w, e[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * w, e[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * w, e[4] = _ * w, e[5] = (c * m * r - p * u * r + p * i * d - t * m * d - c * i * g + t * u * g) * w, e[6] = (p * o * r - s * m * r - p * i * l + t * m * l + s * i * g - t * o * g) * w, e[7] = (s * u * r - c * o * r + c * i * l - t * u * l - s * i * d + t * o * d) * w, e[8] = y * w, e[9] = (p * h * r - c * f * r - p * n * d + t * f * d + c * n * g - t * h * g) * w, e[10] = (s * f * r - p * a * r + p * n * l - t * f * l - s * n * g + t * a * g) * w, e[11] = (c * a * r - s * h * r - c * n * l + t * h * l + s * n * d - t * a * d) * w, e[12] = x * w, e[13] = (c * f * i - p * h * i + p * n * u - t * f * u - c * n * m + t * h * m) * w, e[14] = (p * a * i - s * f * i - p * n * o + t * f * o + s * n * m - t * a * m) * w, e[15] = (s * h * i - c * a * i + c * n * o - t * h * o - s * n * u + t * a * u) * w, this
        }

        scale(e) {
            const t = this.elements, n = e.x, i = e.y, r = e.z;
            return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
        }

        getMaxScaleOnAxis() {
            const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i))
        }

        makeTranslation(e, t, n) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
        }

        makeRotationX(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
        }

        makeRotationY(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
        }

        makeRotationZ(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }

        makeRotationAxis(e, t) {
            const n = Math.cos(t), i = Math.sin(t), r = 1 - n, s = e.x, a = e.y, o = e.z, l = r * s, c = r * a;
            return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this
        }

        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        }

        makeShear(e, t, n, i, r, s) {
            return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this
        }

        compose(e, t, n) {
            const i = this.elements, r = t._x, s = t._y, a = t._z, o = t._w, l = r + r, c = s + s, h = a + a, u = r * l,
                d = r * c, p = r * h, f = s * c, m = s * h, g = a * h, v = o * l, _ = o * c, y = o * h, x = n.x,
                b = n.y, w = n.z;
            return i[0] = (1 - (f + g)) * x, i[1] = (d + y) * x, i[2] = (p - _) * x, i[3] = 0, i[4] = (d - y) * b, i[5] = (1 - (u + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (p + _) * w, i[9] = (m - v) * w, i[10] = (1 - (u + f)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
        }

        decompose(e, t, n) {
            const i = this.elements;
            let r = jh.set(i[0], i[1], i[2]).length();
            const s = jh.set(i[4], i[5], i[6]).length(), a = jh.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], $h.copy(this);
            const o = 1 / r, l = 1 / s, c = 1 / a;
            return $h.elements[0] *= o, $h.elements[1] *= o, $h.elements[2] *= o, $h.elements[4] *= l, $h.elements[5] *= l, $h.elements[6] *= l, $h.elements[8] *= c, $h.elements[9] *= c, $h.elements[10] *= c, t.setFromRotationMatrix($h), n.x = r, n.y = s, n.z = a, this
        }

        makePerspective(e, t, n, i, r, s) {
            void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            const a = this.elements, o = 2 * r / (t - e), l = 2 * r / (n - i), c = (t + e) / (t - e),
                h = (n + i) / (n - i), u = -(s + r) / (s - r), d = -2 * s * r / (s - r);
            return a[0] = o, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        }

        makeOrthographic(e, t, n, i, r, s) {
            const a = this.elements, o = 1 / (t - e), l = 1 / (n - i), c = 1 / (s - r), h = (t + e) * o,
                u = (n + i) * l, d = (s + r) * c;
            return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        }

        equals(e) {
            const t = this.elements, n = e.elements;
            for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
            return !0
        }

        fromArray(e, t = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this
        }

        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
        }
    }

    Wh.prototype.isMatrix4 = !0;
    const jh = new ph, $h = new Wh, Xh = new ph(0, 0, 0), qh = new ph(1, 1, 1), Yh = new ph, Kh = new ph, Jh = new ph,
        Zh = new Wh, Qh = new dh;

    class eu {
        constructor(e = 0, t = 0, n = 0, i = eu.DefaultOrder) {
            this._x = e, this._y = t, this._z = n, this._order = i
        }

        get x() {
            return this._x
        }

        set x(e) {
            this._x = e, this._onChangeCallback()
        }

        get y() {
            return this._y
        }

        set y(e) {
            this._y = e, this._onChangeCallback()
        }

        get z() {
            return this._z
        }

        set z(e) {
            this._z = e, this._onChangeCallback()
        }

        get order() {
            return this._order
        }

        set order(e) {
            this._order = e, this._onChangeCallback()
        }

        set(e, t, n, i = this._order) {
            return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
        }

        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }

        copy(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
        }

        setFromRotationMatrix(e, t = this._order, n = !0) {
            const i = e.elements, r = i[0], s = i[4], a = i[8], o = i[1], l = i[5], c = i[9], h = i[2], u = i[6],
                d = i[10];
            switch (t) {
                case"XYZ":
                    this._y = Math.asin(Xc(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                    break;
                case"YXZ":
                    this._x = Math.asin(-Xc(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                    break;
                case"ZXY":
                    this._x = Math.asin(Xc(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                    break;
                case"ZYX":
                    this._y = Math.asin(-Xc(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                    break;
                case"YZX":
                    this._z = Math.asin(Xc(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                    break;
                case"XZY":
                    this._z = Math.asin(-Xc(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t, !0 === n && this._onChangeCallback(), this
        }

        setFromQuaternion(e, t, n) {
            return Zh.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Zh, t, n)
        }

        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t)
        }

        reorder(e) {
            return Qh.setFromEuler(this), this.setFromQuaternion(Qh, e)
        }

        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }

        fromArray(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
        }

        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        }

        toVector3(e) {
            return e ? e.set(this._x, this._y, this._z) : new ph(this._x, this._y, this._z)
        }

        _onChange(e) {
            return this._onChangeCallback = e, this
        }

        _onChangeCallback() {
        }
    }

    eu.prototype.isEuler = !0, eu.DefaultOrder = "XYZ", eu.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];

    class tu {
        constructor() {
            this.mask = 1
        }

        set(e) {
            this.mask = 1 << e | 0
        }

        enable(e) {
            this.mask |= 1 << e | 0
        }

        enableAll() {
            this.mask = -1
        }

        toggle(e) {
            this.mask ^= 1 << e | 0
        }

        disable(e) {
            this.mask &= ~(1 << e | 0)
        }

        disableAll() {
            this.mask = 0
        }

        test(e) {
            return 0 != (this.mask & e.mask)
        }
    }

    let nu = 0;
    const iu = new ph, ru = new dh, su = new Wh, au = new ph, ou = new ph, lu = new ph, cu = new dh,
        hu = new ph(1, 0, 0), uu = new ph(0, 1, 0), du = new ph(0, 0, 1), pu = {type: "added"}, fu = {type: "removed"};

    class mu extends Hc {
        constructor() {
            super(), Object.defineProperty(this, "id", {value: nu++}), this.uuid = $c(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = mu.DefaultUp.clone();
            const e = new ph, t = new eu, n = new dh, i = new ph(1, 1, 1);
            t._onChange((function () {
                n.setFromEuler(t, !1)
            })), n._onChange((function () {
                t.setFromQuaternion(n, void 0, !1)
            })), Object.defineProperties(this, {
                position: {configurable: !0, enumerable: !0, value: e},
                rotation: {configurable: !0, enumerable: !0, value: t},
                quaternion: {configurable: !0, enumerable: !0, value: n},
                scale: {configurable: !0, enumerable: !0, value: i},
                modelViewMatrix: {value: new Wh},
                normalMatrix: {value: new th}
            }), this.matrix = new Wh, this.matrixWorld = new Wh, this.matrixAutoUpdate = mu.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new tu, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
        }

        onBeforeRender() {
        }

        onAfterRender() {
        }

        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }

        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this
        }

        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        }

        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0)
        }

        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e)
        }

        setRotationFromQuaternion(e) {
            this.quaternion.copy(e)
        }

        rotateOnAxis(e, t) {
            return ru.setFromAxisAngle(e, t), this.quaternion.multiply(ru), this
        }

        rotateOnWorldAxis(e, t) {
            return ru.setFromAxisAngle(e, t), this.quaternion.premultiply(ru), this
        }

        rotateX(e) {
            return this.rotateOnAxis(hu, e)
        }

        rotateY(e) {
            return this.rotateOnAxis(uu, e)
        }

        rotateZ(e) {
            return this.rotateOnAxis(du, e)
        }

        translateOnAxis(e, t) {
            return iu.copy(e).applyQuaternion(this.quaternion), this.position.add(iu.multiplyScalar(t)), this
        }

        translateX(e) {
            return this.translateOnAxis(hu, e)
        }

        translateY(e) {
            return this.translateOnAxis(uu, e)
        }

        translateZ(e) {
            return this.translateOnAxis(du, e)
        }

        localToWorld(e) {
            return e.applyMatrix4(this.matrixWorld)
        }

        worldToLocal(e) {
            return e.applyMatrix4(su.copy(this.matrixWorld).invert())
        }

        lookAt(e, t, n) {
            e.isVector3 ? au.copy(e) : au.set(e, t, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1), ou.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? su.lookAt(ou, au, this.up) : su.lookAt(au, ou, this.up), this.quaternion.setFromRotationMatrix(su), i && (su.extractRotation(i.matrixWorld), ru.setFromRotationMatrix(su), this.quaternion.premultiply(ru.invert()))
        }

        add(e) {
            if (arguments.length > 1) {
                for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(pu)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        }

        remove(e) {
            if (arguments.length > 1) {
                for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            const t = this.children.indexOf(e);
            return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(fu)), this
        }

        removeFromParent() {
            const e = this.parent;
            return null !== e && e.remove(this), this
        }

        clear() {
            for (let e = 0; e < this.children.length; e++) {
                const t = this.children[e];
                t.parent = null, t.dispatchEvent(fu)
            }
            return this.children.length = 0, this
        }

        attach(e) {
            return this.updateWorldMatrix(!0, !1), su.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), su.multiply(e.parent.matrixWorld)), e.applyMatrix4(su), this.add(e), e.updateWorldMatrix(!1, !0), this
        }

        getObjectById(e) {
            return this.getObjectByProperty("id", e)
        }

        getObjectByName(e) {
            return this.getObjectByProperty("name", e)
        }

        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(e, t);
                if (void 0 !== i) return i
            }
        }

        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
        }

        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ou, e, lu), e
        }

        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ou, cu, e), e
        }

        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }

        raycast() {
        }

        traverse(e) {
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
        }

        traverseVisible(e) {
            if (!1 === this.visible) return;
            e(this);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
        }

        traverseAncestors(e) {
            const t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        }

        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        }

        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            const t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
        }

        updateWorldMatrix(e, t) {
            const n = this.parent;
            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                const e = this.children;
                for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
            }
        }

        toJSON(e) {
            const t = void 0 === e || "string" == typeof e, n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            }, n.metadata = {version: 4.5, type: "Object", generator: "Object3D.toJSON"});
            const i = {};

            function r(t, n) {
                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
            }

            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(e.geometries, this.geometry);
                const t = this.geometry.parameters;
                if (void 0 !== t && void 0 !== t.shapes) {
                    const n = t.shapes;
                    if (Array.isArray(n)) for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        r(e.shapes, i)
                    } else r(e.shapes, n)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
                const t = [];
                for (let n = 0, i = this.material.length; n < i; n++) t.push(r(e.materials, this.material[n]));
                i.material = t
            } else i.material = r(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let t = 0; t < this.animations.length; t++) {
                    const n = this.animations[t];
                    i.animations.push(r(e.animations, n))
                }
            }
            if (t) {
                const t = s(e.geometries), i = s(e.materials), r = s(e.textures), a = s(e.images), o = s(e.shapes),
                    l = s(e.skeletons), c = s(e.animations);
                t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
            }
            return n.object = i, n;

            function s(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    delete i.metadata, t.push(i)
                }
                return t
            }
        }

        clone(e) {
            return (new this.constructor).copy(this, e)
        }

        copy(e, t = !0) {
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) {
                const n = e.children[t];
                this.add(n.clone())
            }
            return this
        }
    }

    mu.DefaultUp = new ph(0, 1, 0), mu.DefaultMatrixAutoUpdate = !0, mu.prototype.isObject3D = !0;
    const gu = new ph, vu = new ph, _u = new ph, yu = new ph, xu = new ph, bu = new ph, wu = new ph, Tu = new ph,
        Su = new ph, Eu = new ph;

    class Mu {
        constructor(e = new ph, t = new ph, n = new ph) {
            this.a = e, this.b = t, this.c = n
        }

        static getNormal(e, t, n, i) {
            i.subVectors(n, t), gu.subVectors(e, t), i.cross(gu);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        }

        static getBarycoord(e, t, n, i, r) {
            gu.subVectors(i, t), vu.subVectors(n, t), _u.subVectors(e, t);
            const s = gu.dot(gu), a = gu.dot(vu), o = gu.dot(_u), l = vu.dot(vu), c = vu.dot(_u), h = s * l - a * a;
            if (0 === h) return r.set(-2, -1, -1);
            const u = 1 / h, d = (l * o - a * c) * u, p = (s * c - a * o) * u;
            return r.set(1 - d - p, p, d)
        }

        static containsPoint(e, t, n, i) {
            return this.getBarycoord(e, t, n, i, yu), yu.x >= 0 && yu.y >= 0 && yu.x + yu.y <= 1
        }

        static getUV(e, t, n, i, r, s, a, o) {
            return this.getBarycoord(e, t, n, i, yu), o.set(0, 0), o.addScaledVector(r, yu.x), o.addScaledVector(s, yu.y), o.addScaledVector(a, yu.z), o
        }

        static isFrontFacing(e, t, n, i) {
            return gu.subVectors(n, t), vu.subVectors(e, t), gu.cross(vu).dot(i) < 0
        }

        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
        }

        setFromPointsAndIndices(e, t, n, i) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
        }

        setFromAttributeAndIndices(e, t, n, i) {
            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        }

        getArea() {
            return gu.subVectors(this.c, this.b), vu.subVectors(this.a, this.b), .5 * gu.cross(vu).length()
        }

        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }

        getNormal(e) {
            return Mu.getNormal(this.a, this.b, this.c, e)
        }

        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
        }

        getBarycoord(e, t) {
            return Mu.getBarycoord(e, this.a, this.b, this.c, t)
        }

        getUV(e, t, n, i, r) {
            return Mu.getUV(e, this.a, this.b, this.c, t, n, i, r)
        }

        containsPoint(e) {
            return Mu.containsPoint(e, this.a, this.b, this.c)
        }

        isFrontFacing(e) {
            return Mu.isFrontFacing(this.a, this.b, this.c, e)
        }

        intersectsBox(e) {
            return e.intersectsTriangle(this)
        }

        closestPointToPoint(e, t) {
            const n = this.a, i = this.b, r = this.c;
            let s, a;
            xu.subVectors(i, n), bu.subVectors(r, n), Tu.subVectors(e, n);
            const o = xu.dot(Tu), l = bu.dot(Tu);
            if (o <= 0 && l <= 0) return t.copy(n);
            Su.subVectors(e, i);
            const c = xu.dot(Su), h = bu.dot(Su);
            if (c >= 0 && h <= c) return t.copy(i);
            const u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), t.copy(n).addScaledVector(xu, s);
            Eu.subVectors(e, r);
            const d = xu.dot(Eu), p = bu.dot(Eu);
            if (p >= 0 && d <= p) return t.copy(r);
            const f = d * l - o * p;
            if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(n).addScaledVector(bu, a);
            const m = c * p - d * h;
            if (m <= 0 && h - c >= 0 && d - p >= 0) return wu.subVectors(r, i), a = (h - c) / (h - c + (d - p)), t.copy(i).addScaledVector(wu, a);
            const g = 1 / (m + f + u);
            return s = f * g, a = u * g, t.copy(n).addScaledVector(xu, s).addScaledVector(bu, a)
        }

        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }

    let Au = 0;

    class Lu extends Hc {
        constructor() {
            super(), Object.defineProperty(this, "id", {value: Au++}), this.uuid = $c(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.format = gc, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Jl, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Bc, this.stencilZFail = Bc, this.stencilZPass = Bc, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
        }

        get alphaTest() {
            return this._alphaTest
        }

        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
        }

        onBuild() {
        }

        onBeforeRender() {
        }

        onBeforeCompile() {
        }

        customProgramCacheKey() {
            return this.onBeforeCompile.toString()
        }

        setValues(e) {
            if (void 0 !== e) for (const t in e) {
                const n = e[t];
                if (void 0 === n) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                if ("shading" === t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                    continue
                }
                const i = this[t];
                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
            }
        }

        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            t && (e = {textures: {}, images: {}});
            const n = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};

            function i(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    delete i.metadata, t.push(i)
                }
                return t
            }

            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenTint && this.sheenTint.isColor && (n.sheenTint = this.sheenTint.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularTintMap && this.specularTintMap.isTexture && (n.specularTintMap = this.specularTintMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (n.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.format !== gc && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                const t = i(e.textures), r = i(e.images);
                t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r)
            }
            return n
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        copy(e) {
            this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.format = e.format, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (null !== t) {
                const e = t.length;
                n = new Array(e);
                for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
        }

        dispose() {
            this.dispatchEvent({type: "dispose"})
        }

        set needsUpdate(e) {
            !0 === e && this.version++
        }
    }

    Lu.prototype.isMaterial = !0;
    const Cu = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, Ru = {h: 0, s: 0, l: 0}, Pu = {h: 0, s: 0, l: 0};

    function Iu(e, t, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }

    function Ou(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }

    function Du(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }

    class Nu {
        constructor(e, t, n) {
            return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
        }

        set(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        }

        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this
        }

        setHex(e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        }

        setRGB(e, t, n) {
            return this.r = e, this.g = t, this.b = n, this
        }

        setHSL(e, t, n) {
            if (e = qc(e, 1), t = Xc(t, 0, 1), n = Xc(n, 0, 1), 0 === t) this.r = this.g = this.b = n; else {
                const i = n <= .5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i;
                this.r = Iu(r, i, e + 1 / 3), this.g = Iu(r, i, e), this.b = Iu(r, i, e - 1 / 3)
            }
            return this
        }

        setStyle(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }

            let n;
            if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                let e;
                const i = n[1], r = n[2];
                switch (i) {
                    case"rgb":
                    case"rgba":
                        if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this;
                        if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this;
                        break;
                    case"hsl":
                    case"hsla":
                        if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                            const n = parseFloat(e[1]) / 360, i = parseInt(e[2], 10) / 100,
                                r = parseInt(e[3], 10) / 100;
                            return t(e[4]), this.setHSL(n, i, r)
                        }
                }
            } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const e = n[1], t = e.length;
                if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this;
                if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this
            }
            return e && e.length > 0 ? this.setColorName(e) : this
        }

        setColorName(e) {
            const t = Cu[e.toLowerCase()];
            return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
        }

        clone() {
            return new this.constructor(this.r, this.g, this.b)
        }

        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        }

        copyGammaToLinear(e, t = 2) {
            return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        }

        copyLinearToGamma(e, t = 2) {
            const n = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
        }

        convertGammaToLinear(e) {
            return this.copyGammaToLinear(this, e), this
        }

        convertLinearToGamma(e) {
            return this.copyLinearToGamma(this, e), this
        }

        copySRGBToLinear(e) {
            return this.r = Ou(e.r), this.g = Ou(e.g), this.b = Ou(e.b), this
        }

        copyLinearToSRGB(e) {
            return this.r = Du(e.r), this.g = Du(e.g), this.b = Du(e.b), this
        }

        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this
        }

        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this
        }

        getHex() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        }

        getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }

        getHSL(e) {
            const t = this.r, n = this.g, i = this.b, r = Math.max(t, n, i), s = Math.min(t, n, i);
            let a, o;
            const l = (s + r) / 2;
            if (s === r) a = 0, o = 0; else {
                const e = r - s;
                switch (o = l <= .5 ? e / (r + s) : e / (2 - r - s), r) {
                    case t:
                        a = (n - i) / e + (n < i ? 6 : 0);
                        break;
                    case n:
                        a = (i - t) / e + 2;
                        break;
                    case i:
                        a = (t - n) / e + 4
                }
                a /= 6
            }
            return e.h = a, e.s = o, e.l = l, e
        }

        getStyle() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }

        offsetHSL(e, t, n) {
            return this.getHSL(Ru), Ru.h += e, Ru.s += t, Ru.l += n, this.setHSL(Ru.h, Ru.s, Ru.l), this
        }

        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        }

        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        }

        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this
        }

        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        }

        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        }

        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        }

        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        }

        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
        }

        lerpHSL(e, t) {
            this.getHSL(Ru), e.getHSL(Pu);
            const n = Yc(Ru.h, Pu.h, t), i = Yc(Ru.s, Pu.s, t), r = Yc(Ru.l, Pu.l, t);
            return this.setHSL(n, i, r), this
        }

        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }

        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        }

        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        }

        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
        }

        toJSON() {
            return this.getHex()
        }
    }

    Nu.NAMES = Cu, Nu.prototype.isColor = !0, Nu.prototype.r = 1, Nu.prototype.g = 1, Nu.prototype.b = 1;

    class Bu extends Lu {
        constructor(e) {
            super(), this.type = "MeshBasicMaterial", this.color = new Nu(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
        }
    }

    Bu.prototype.isMeshBasicMaterial = !0;
    const ku = new ph, Uu = new eh;

    class Fu {
        constructor(e, t, n) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = kc, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        onUploadCallback() {
        }

        set needsUpdate(e) {
            !0 === e && this.version++
        }

        setUsage(e) {
            return this.usage = e, this
        }

        copy(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
        }

        copyAt(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
            return this
        }

        copyArray(e) {
            return this.array.set(e), this
        }

        copyColorsArray(e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
                let r = e[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Nu), t[n++] = r.r, t[n++] = r.g, t[n++] = r.b
            }
            return this
        }

        copyVector2sArray(e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
                let r = e[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new eh), t[n++] = r.x, t[n++] = r.y
            }
            return this
        }

        copyVector3sArray(e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
                let r = e[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new ph), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z
            }
            return this
        }

        copyVector4sArray(e) {
            const t = this.array;
            let n = 0;
            for (let i = 0, r = e.length; i < r; i++) {
                let r = e[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new ch), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n++] = r.w
            }
            return this
        }

        applyMatrix3(e) {
            if (2 === this.itemSize) for (let t = 0, n = this.count; t < n; t++) Uu.fromBufferAttribute(this, t), Uu.applyMatrix3(e), this.setXY(t, Uu.x, Uu.y); else if (3 === this.itemSize) for (let t = 0, n = this.count; t < n; t++) ku.fromBufferAttribute(this, t), ku.applyMatrix3(e), this.setXYZ(t, ku.x, ku.y, ku.z);
            return this
        }

        applyMatrix4(e) {
            for (let t = 0, n = this.count; t < n; t++) ku.x = this.getX(t), ku.y = this.getY(t), ku.z = this.getZ(t), ku.applyMatrix4(e), this.setXYZ(t, ku.x, ku.y, ku.z);
            return this
        }

        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) ku.x = this.getX(t), ku.y = this.getY(t), ku.z = this.getZ(t), ku.applyNormalMatrix(e), this.setXYZ(t, ku.x, ku.y, ku.z);
            return this
        }

        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) ku.x = this.getX(t), ku.y = this.getY(t), ku.z = this.getZ(t), ku.transformDirection(e), this.setXYZ(t, ku.x, ku.y, ku.z);
            return this
        }

        set(e, t = 0) {
            return this.array.set(e, t), this
        }

        getX(e) {
            return this.array[e * this.itemSize]
        }

        setX(e, t) {
            return this.array[e * this.itemSize] = t, this
        }

        getY(e) {
            return this.array[e * this.itemSize + 1]
        }

        setY(e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        }

        getZ(e) {
            return this.array[e * this.itemSize + 2]
        }

        setZ(e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        }

        getW(e) {
            return this.array[e * this.itemSize + 3]
        }

        setW(e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        }

        setXY(e, t, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
        }

        setXYZ(e, t, n, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
        }

        setXYZW(e, t, n, i, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
        }

        onUpload(e) {
            return this.onUploadCallback = e, this
        }

        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }

        toJSON() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            };
            return "" !== this.name && (e.name = this.name), this.usage !== kc && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
        }
    }

    Fu.prototype.isBufferAttribute = !0;

    class Hu extends Fu {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n)
        }
    }

    class zu extends Fu {
        constructor(e, t, n) {
            super(new Uint32Array(e), t, n)
        }
    }

    (class extends Fu {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n)
        }
    }).prototype.isFloat16BufferAttribute = !0;

    class Gu extends Fu {
        constructor(e, t, n) {
            super(new Float32Array(e), t, n)
        }
    }

    let Vu = 0;
    const Wu = new Wh, ju = new mu, $u = new ph, Xu = new gh, qu = new gh, Yu = new ph;

    class Ku extends Hc {
        constructor() {
            super(), Object.defineProperty(this, "id", {value: Vu++}), this.uuid = $c(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }

        getIndex() {
            return this.index
        }

        setIndex(e) {
            return Array.isArray(e) ? this.index = new (nh(e) > 65535 ? zu : Hu)(e, 1) : this.index = e, this
        }

        getAttribute(e) {
            return this.attributes[e]
        }

        setAttribute(e, t) {
            return this.attributes[e] = t, this
        }

        deleteAttribute(e) {
            return delete this.attributes[e], this
        }

        hasAttribute(e) {
            return void 0 !== this.attributes[e]
        }

        addGroup(e, t, n = 0) {
            this.groups.push({start: e, count: t, materialIndex: n})
        }

        clearGroups() {
            this.groups = []
        }

        setDrawRange(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        }

        applyMatrix4(e) {
            const t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (void 0 !== n) {
                const t = (new th).getNormalMatrix(e);
                n.applyNormalMatrix(t), n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        }

        applyQuaternion(e) {
            return Wu.makeRotationFromQuaternion(e), this.applyMatrix4(Wu), this
        }

        rotateX(e) {
            return Wu.makeRotationX(e), this.applyMatrix4(Wu), this
        }

        rotateY(e) {
            return Wu.makeRotationY(e), this.applyMatrix4(Wu), this
        }

        rotateZ(e) {
            return Wu.makeRotationZ(e), this.applyMatrix4(Wu), this
        }

        translate(e, t, n) {
            return Wu.makeTranslation(e, t, n), this.applyMatrix4(Wu), this
        }

        scale(e, t, n) {
            return Wu.makeScale(e, t, n), this.applyMatrix4(Wu), this
        }

        lookAt(e) {
            return ju.lookAt(e), ju.updateMatrix(), this.applyMatrix4(ju.matrix), this
        }

        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter($u).negate(), this.translate($u.x, $u.y, $u.z), this
        }

        setFromPoints(e) {
            const t = [];
            for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n];
                t.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new Gu(t, 3)), this
        }

        computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new gh);
            const e = this.attributes.position, t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ph(-1 / 0, -1 / 0, -1 / 0), new ph(1 / 0, 1 / 0, 1 / 0));
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    Xu.setFromBufferAttribute(n), this.morphTargetsRelative ? (Yu.addVectors(this.boundingBox.min, Xu.min), this.boundingBox.expandByPoint(Yu), Yu.addVectors(this.boundingBox.max, Xu.max), this.boundingBox.expandByPoint(Yu)) : (this.boundingBox.expandByPoint(Xu.min), this.boundingBox.expandByPoint(Xu.max))
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }

        computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new Nh);
            const e = this.attributes.position, t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ph, 1 / 0);
            if (e) {
                const n = this.boundingSphere.center;
                if (Xu.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    qu.setFromBufferAttribute(n), this.morphTargetsRelative ? (Yu.addVectors(Xu.min, qu.min), Xu.expandByPoint(Yu), Yu.addVectors(Xu.max, qu.max), Xu.expandByPoint(Yu)) : (Xu.expandByPoint(qu.min), Xu.expandByPoint(qu.max))
                }
                Xu.getCenter(n);
                let i = 0;
                for (let t = 0, r = e.count; t < r; t++) Yu.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(Yu));
                if (t) for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r], a = this.morphTargetsRelative;
                    for (let t = 0, r = s.count; t < r; t++) Yu.fromBufferAttribute(s, t), a && ($u.fromBufferAttribute(e, t), Yu.add($u)), i = Math.max(i, n.distanceToSquared(Yu))
                }
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }

        computeTangents() {
            const e = this.index, t = this.attributes;
            if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            const n = e.array, i = t.position.array, r = t.normal.array, s = t.uv.array, a = i.length / 3;
            void 0 === t.tangent && this.setAttribute("tangent", new Fu(new Float32Array(4 * a), 4));
            const o = t.tangent.array, l = [], c = [];
            for (let e = 0; e < a; e++) l[e] = new ph, c[e] = new ph;
            const h = new ph, u = new ph, d = new ph, p = new eh, f = new eh, m = new eh, g = new ph, v = new ph;

            function _(e, t, n) {
                h.fromArray(i, 3 * e), u.fromArray(i, 3 * t), d.fromArray(i, 3 * n), p.fromArray(s, 2 * e), f.fromArray(s, 2 * t), m.fromArray(s, 2 * n), u.sub(h), d.sub(h), f.sub(p), m.sub(p);
                const r = 1 / (f.x * m.y - m.x * f.y);
                isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(v), c[t].add(v), c[n].add(v))
            }

            let y = this.groups;
            0 === y.length && (y = [{start: 0, count: n.length}]);
            for (let e = 0, t = y.length; e < t; ++e) {
                const t = y[e], i = t.start;
                for (let e = i, r = i + t.count; e < r; e += 3) _(n[e + 0], n[e + 1], n[e + 2])
            }
            const x = new ph, b = new ph, w = new ph, T = new ph;

            function S(e) {
                w.fromArray(r, 3 * e), T.copy(w);
                const t = l[e];
                x.copy(t), x.sub(w.multiplyScalar(w.dot(t))).normalize(), b.crossVectors(T, t);
                const n = b.dot(c[e]) < 0 ? -1 : 1;
                o[4 * e] = x.x, o[4 * e + 1] = x.y, o[4 * e + 2] = x.z, o[4 * e + 3] = n
            }

            for (let e = 0, t = y.length; e < t; ++e) {
                const t = y[e], i = t.start;
                for (let e = i, r = i + t.count; e < r; e += 3) S(n[e + 0]), S(n[e + 1]), S(n[e + 2])
            }
        }

        computeVertexNormals() {
            const e = this.index, t = this.getAttribute("position");
            if (void 0 !== t) {
                let n = this.getAttribute("normal");
                if (void 0 === n) n = new Fu(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n); else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                const i = new ph, r = new ph, s = new ph, a = new ph, o = new ph, l = new ph, c = new ph, h = new ph;
                if (e) for (let u = 0, d = e.count; u < d; u += 3) {
                    const d = e.getX(u + 0), p = e.getX(u + 1), f = e.getX(u + 2);
                    i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), s.fromBufferAttribute(t, f), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z)
                } else for (let e = 0, a = t.count; e < a; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        }

        merge(e, t) {
            if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
            void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            const n = this.attributes;
            for (const i in n) {
                if (void 0 === e.attributes[i]) continue;
                const r = n[i].array, s = e.attributes[i], a = s.array, o = s.itemSize * t,
                    l = Math.min(a.length, r.length - o);
                for (let e = 0, t = o; e < l; e++, t++) r[t] = a[e]
            }
            return this
        }

        normalizeNormals() {
            const e = this.attributes.normal;
            for (let t = 0, n = e.count; t < n; t++) Yu.fromBufferAttribute(e, t), Yu.normalize(), e.setXYZ(t, Yu.x, Yu.y, Yu.z)
        }

        toNonIndexed() {
            function e(e, t) {
                const n = e.array, i = e.itemSize, r = e.normalized, s = new n.constructor(t.length * i);
                let a = 0, o = 0;
                for (let r = 0, l = t.length; r < l; r++) {
                    a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                    for (let e = 0; e < i; e++) s[o++] = n[a++]
                }
                return new Fu(s, i, r)
            }

            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const t = new Ku, n = this.index.array, i = this.attributes;
            for (const r in i) {
                const s = e(i[r], n);
                t.setAttribute(r, s)
            }
            const r = this.morphAttributes;
            for (const i in r) {
                const s = [], a = r[i];
                for (let t = 0, i = a.length; t < i; t++) {
                    const i = e(a[t], n);
                    s.push(i)
                }
                t.morphAttributes[i] = s
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let e = 0, n = s.length; e < n; e++) {
                const n = s[e];
                t.addGroup(n.start, n.count, n.materialIndex)
            }
            return t
        }

        toJSON() {
            const e = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                const t = this.parameters;
                for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            e.data = {attributes: {}};
            const t = this.index;
            null !== t && (e.data.index = {type: t.array.constructor.name, array: Array.prototype.slice.call(t.array)});
            const n = this.attributes;
            for (const t in n) {
                const i = n[t];
                e.data.attributes[t] = i.toJSON(e.data)
            }
            const i = {};
            let r = !1;
            for (const t in this.morphAttributes) {
                const n = this.morphAttributes[t], s = [];
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    s.push(i.toJSON(e.data))
                }
                s.length > 0 && (i[t] = s, r = !0)
            }
            r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
            const s = this.groups;
            s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
            const a = this.boundingSphere;
            return null !== a && (e.data.boundingSphere = {center: a.center.toArray(), radius: a.radius}), e
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        copy(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            null !== n && this.setIndex(n.clone(t));
            const i = e.attributes;
            for (const e in i) {
                const n = i[e];
                this.setAttribute(e, n.clone(t))
            }
            const r = e.morphAttributes;
            for (const e in r) {
                const n = [], i = r[e];
                for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
                this.morphAttributes[e] = n
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const s = e.groups;
            for (let e = 0, t = s.length; e < t; e++) {
                const t = s[e];
                this.addGroup(t.start, t.count, t.materialIndex)
            }
            const a = e.boundingBox;
            null !== a && (this.boundingBox = a.clone());
            const o = e.boundingSphere;
            return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
        }

        dispose() {
            this.dispatchEvent({type: "dispose"})
        }
    }

    Ku.prototype.isBufferGeometry = !0;
    const Ju = new Wh, Zu = new Vh, Qu = new Nh, ed = new ph, td = new ph, nd = new ph, id = new ph, rd = new ph,
        sd = new ph, ad = new ph, od = new ph, ld = new ph, cd = new eh, hd = new eh, ud = new eh, dd = new ph,
        pd = new ph;

    class fd extends mu {
        constructor(e = new Ku, t = new Bu) {
            super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
        }

        copy(e) {
            return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
        }

        updateMorphTargets() {
            const e = this.geometry;
            if (e.isBufferGeometry) {
                const t = e.morphAttributes, n = Object.keys(t);
                if (n.length > 0) {
                    const e = t[n[0]];
                    if (void 0 !== e) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    }
                }
            } else {
                const t = e.morphTargets;
                void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }

        raycast(e, t) {
            const n = this.geometry, i = this.material, r = this.matrixWorld;
            if (void 0 === i) return;
            if (null === n.boundingSphere && n.computeBoundingSphere(), Qu.copy(n.boundingSphere), Qu.applyMatrix4(r), !1 === e.ray.intersectsSphere(Qu)) return;
            if (Ju.copy(r).invert(), Zu.copy(e.ray).applyMatrix4(Ju), null !== n.boundingBox && !1 === Zu.intersectsBox(n.boundingBox)) return;
            let s;
            if (n.isBufferGeometry) {
                const r = n.index, a = n.attributes.position, o = n.morphAttributes.position,
                    l = n.morphTargetsRelative, c = n.attributes.uv, h = n.attributes.uv2, u = n.groups,
                    d = n.drawRange;
                if (null !== r) if (Array.isArray(i)) for (let n = 0, p = u.length; n < p; n++) {
                    const p = u[n], f = i[p.materialIndex];
                    for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                        const i = r.getX(n), u = r.getX(n + 1), d = r.getX(n + 2);
                        s = md(this, f, e, Zu, a, o, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, t.push(s))
                    }
                } else {
                    for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                        const u = r.getX(n), d = r.getX(n + 1), p = r.getX(n + 2);
                        s = md(this, i, e, Zu, a, o, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
                    }
                } else if (void 0 !== a) if (Array.isArray(i)) for (let n = 0, r = u.length; n < r; n++) {
                    const r = u[n], p = i[r.materialIndex];
                    for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) {
                        s = md(this, p, e, Zu, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, t.push(s))
                    }
                } else {
                    for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) {
                        s = md(this, i, e, Zu, a, o, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
                    }
                }
            } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }

    function md(e, t, n, i, r, s, a, o, l, c, h, u) {
        ed.fromBufferAttribute(r, c), td.fromBufferAttribute(r, h), nd.fromBufferAttribute(r, u);
        const d = e.morphTargetInfluences;
        if (s && d) {
            ad.set(0, 0, 0), od.set(0, 0, 0), ld.set(0, 0, 0);
            for (let e = 0, t = s.length; e < t; e++) {
                const t = d[e], n = s[e];
                0 !== t && (id.fromBufferAttribute(n, c), rd.fromBufferAttribute(n, h), sd.fromBufferAttribute(n, u), a ? (ad.addScaledVector(id, t), od.addScaledVector(rd, t), ld.addScaledVector(sd, t)) : (ad.addScaledVector(id.sub(ed), t), od.addScaledVector(rd.sub(td), t), ld.addScaledVector(sd.sub(nd), t)))
            }
            ed.add(ad), td.add(od), nd.add(ld)
        }
        e.isSkinnedMesh && (e.boneTransform(c, ed), e.boneTransform(h, td), e.boneTransform(u, nd));
        const p = function (e, t, n, i, r, s, a, o) {
            let l;
            if (l = 1 === t.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== t.side, o), null === l) return null;
            pd.copy(o), pd.applyMatrix4(e.matrixWorld);
            const c = n.ray.origin.distanceTo(pd);
            return c < n.near || c > n.far ? null : {distance: c, point: pd.clone(), object: e}
        }(e, t, n, i, ed, td, nd, dd);
        if (p) {
            o && (cd.fromBufferAttribute(o, c), hd.fromBufferAttribute(o, h), ud.fromBufferAttribute(o, u), p.uv = Mu.getUV(dd, ed, td, nd, cd, hd, ud, new eh)), l && (cd.fromBufferAttribute(l, c), hd.fromBufferAttribute(l, h), ud.fromBufferAttribute(l, u), p.uv2 = Mu.getUV(dd, ed, td, nd, cd, hd, ud, new eh));
            const e = {a: c, b: h, c: u, normal: new ph, materialIndex: 0};
            Mu.getNormal(ed, td, nd, e.normal), p.face = e
        }
        return p
    }

    fd.prototype.isMesh = !0;

    class gd extends Ku {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: s
            };
            const a = this;
            i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
            const o = [], l = [], c = [], h = [];
            let u = 0, d = 0;

            function p(e, t, n, i, r, s, p, f, m, g, v) {
                const _ = s / m, y = p / g, x = s / 2, b = p / 2, w = f / 2, T = m + 1, S = g + 1;
                let E = 0, M = 0;
                const A = new ph;
                for (let s = 0; s < S; s++) {
                    const a = s * y - b;
                    for (let o = 0; o < T; o++) {
                        const u = o * _ - x;
                        A[e] = u * i, A[t] = a * r, A[n] = w, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = f > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / m), h.push(1 - s / g), E += 1
                    }
                }
                for (let e = 0; e < g; e++) for (let t = 0; t < m; t++) {
                    const n = u + t + T * e, i = u + t + T * (e + 1), r = u + (t + 1) + T * (e + 1),
                        s = u + (t + 1) + T * e;
                    o.push(n, i, s), o.push(i, r, s), M += 6
                }
                a.addGroup(d, M, v), d += M, u += E
            }

            p("z", "y", "x", -1, -1, n, t, e, s, r, 0), p("z", "y", "x", 1, -1, n, t, -e, s, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, s, 2), p("x", "z", "y", 1, -1, e, n, -t, i, s, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Gu(l, 3)), this.setAttribute("normal", new Gu(c, 3)), this.setAttribute("uv", new Gu(h, 2))
        }

        static fromJSON(e) {
            return new gd(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
        }
    }

    function vd(e) {
        const t = {};
        for (const n in e) {
            t[n] = {};
            for (const i in e[n]) {
                const r = e[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
            }
        }
        return t
    }

    function _d(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const i = vd(e[n]);
            for (const e in i) t[e] = i[e]
        }
        return t
    }

    const yd = {clone: vd, merge: _d};

    class xd extends Lu {
        constructor(e) {
            super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
        }

        copy(e) {
            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = vd(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
        }

        toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion, t.uniforms = {};
            for (const n in this.uniforms) {
                const i = this.uniforms[n].value;
                i && i.isTexture ? t.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(e).uuid
                } : i && i.isColor ? t.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? t.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? t.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? t.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? t.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? t.uniforms[n] = {type: "m4", value: i.toArray()} : t.uniforms[n] = {value: i}
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
            const n = {};
            for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t
        }
    }

    xd.prototype.isShaderMaterial = !0;

    class bd extends mu {
        constructor() {
            super(), this.type = "Camera", this.matrixWorldInverse = new Wh, this.projectionMatrix = new Wh, this.projectionMatrixInverse = new Wh
        }

        copy(e, t) {
            return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
        }

        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        }

        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }

        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }

        clone() {
            return (new this.constructor).copy(this)
        }
    }

    bd.prototype.isCamera = !0;

    class wd extends bd {
        constructor(e = 50, t = 1, n = .1, i = 2e3) {
            super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        copy(e, t) {
            return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        }

        setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * Vc * Math.atan(t), this.updateProjectionMatrix()
        }

        getFocalLength() {
            const e = Math.tan(.5 * Gc * this.fov);
            return .5 * this.getFilmHeight() / e
        }

        getEffectiveFOV() {
            return 2 * Vc * Math.atan(Math.tan(.5 * Gc * this.fov) / this.zoom)
        }

        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }

        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }

        setViewOffset(e, t, n, i, r, s) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
        }

        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }

        updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(.5 * Gc * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -.5 * i;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
                const e = s.fullWidth, a = s.fullHeight;
                r += s.offsetX * i / e, t -= s.offsetY * n / a, i *= s.width / e, n *= s.height / a
            }
            const a = this.filmOffset;
            0 !== a && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }

        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    }

    wd.prototype.isPerspectiveCamera = !0;
    const Td = 90;

    class Sd extends mu {
        constructor(e, t, n) {
            if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            this.renderTarget = n;
            const i = new wd(Td, 1, e, t);
            i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ph(1, 0, 0)), this.add(i);
            const r = new wd(Td, 1, e, t);
            r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new ph(-1, 0, 0)), this.add(r);
            const s = new wd(Td, 1, e, t);
            s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new ph(0, 1, 0)), this.add(s);
            const a = new wd(Td, 1, e, t);
            a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new ph(0, -1, 0)), this.add(a);
            const o = new wd(Td, 1, e, t);
            o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new ph(0, 0, 1)), this.add(o);
            const l = new wd(Td, 1, e, t);
            l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new ph(0, 0, -1)), this.add(l)
        }

        update(e, t) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget, [i, r, s, a, o, l] = this.children, c = e.xr.enabled, h = e.getRenderTarget();
            e.xr.enabled = !1;
            const u = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = u, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(h), e.xr.enabled = c
        }
    }

    class Ed extends oh {
        constructor(e, t, n, i, r, s, a, o, l, c) {
            super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : Zl, n, i, r, s, a, o, l, c), this.flipY = !1
        }

        get images() {
            return this.image
        }

        set images(e) {
            this.image = e
        }
    }

    Ed.prototype.isCubeTexture = !0;

    class Md extends hh {
        constructor(e, t, n) {
            Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), super(e, e, t), t = t || {}, this.texture = new Ed(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : oc, this.texture._needsFlipEnvMap = !1
        }

        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type, this.texture.format = gc, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
            const n = {
                uniforms: {tEquirect: {value: null}},
                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
            }, i = new gd(5, 5, 5), r = new xd({
                name: "CubemapFromEquirect",
                uniforms: vd(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: 1,
                blending: 0
            });
            r.uniforms.tEquirect.value = t;
            const s = new fd(i, r), a = t.minFilter;
            t.minFilter === lc && (t.minFilter = oc);
            return new Sd(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
        }

        clear(e, t, n, i) {
            const r = e.getRenderTarget();
            for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
            e.setRenderTarget(r)
        }
    }

    Md.prototype.isWebGLCubeRenderTarget = !0;
    const Ad = new ph, Ld = new ph, Cd = new th;

    class Rd {
        constructor(e = new ph(1, 0, 0), t = 0) {
            this.normal = e, this.constant = t
        }

        set(e, t) {
            return this.normal.copy(e), this.constant = t, this
        }

        setComponents(e, t, n, i) {
            return this.normal.set(e, t, n), this.constant = i, this
        }

        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        }

        setFromCoplanarPoints(e, t, n) {
            const i = Ad.subVectors(n, t).cross(Ld.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e), this
        }

        copy(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        }

        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        }

        negate() {
            return this.constant *= -1, this.normal.negate(), this
        }

        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant
        }

        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius
        }

        projectPoint(e, t) {
            return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        }

        intersectLine(e, t) {
            const n = e.delta(Ad), i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
            const r = -(e.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start)
        }

        intersectsLine(e) {
            const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        }

        intersectsBox(e) {
            return e.intersectsPlane(this)
        }

        intersectsSphere(e) {
            return e.intersectsPlane(this)
        }

        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant)
        }

        applyMatrix4(e, t) {
            const n = t || Cd.getNormalMatrix(e), i = this.coplanarPoint(Ad).applyMatrix4(e),
                r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r), this
        }

        translate(e) {
            return this.constant -= e.dot(this.normal), this
        }

        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }

        clone() {
            return (new this.constructor).copy(this)
        }
    }

    Rd.prototype.isPlane = !0;
    const Pd = new Nh, Id = new ph;

    class Od {
        constructor(e = new Rd, t = new Rd, n = new Rd, i = new Rd, r = new Rd, s = new Rd) {
            this.planes = [e, t, n, i, r, s]
        }

        set(e, t, n, i, r, s) {
            const a = this.planes;
            return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this
        }

        copy(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this
        }

        setFromProjectionMatrix(e) {
            const t = this.planes, n = e.elements, i = n[0], r = n[1], s = n[2], a = n[3], o = n[4], l = n[5], c = n[6],
                h = n[7], u = n[8], d = n[9], p = n[10], f = n[11], m = n[12], g = n[13], v = n[14], _ = n[15];
            return t[0].setComponents(a - i, h - o, f - u, _ - m).normalize(), t[1].setComponents(a + i, h + o, f + u, _ + m).normalize(), t[2].setComponents(a + r, h + l, f + d, _ + g).normalize(), t[3].setComponents(a - r, h - l, f - d, _ - g).normalize(), t[4].setComponents(a - s, h - c, f - p, _ - v).normalize(), t[5].setComponents(a + s, h + c, f + p, _ + v).normalize(), this
        }

        intersectsObject(e) {
            const t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(), Pd.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Pd)
        }

        intersectsSprite(e) {
            return Pd.center.set(0, 0, 0), Pd.radius = .7071067811865476, Pd.applyMatrix4(e.matrixWorld), this.intersectsSphere(Pd)
        }

        intersectsSphere(e) {
            const t = this.planes, n = e.center, i = -e.radius;
            for (let e = 0; e < 6; e++) {
                if (t[e].distanceToPoint(n) < i) return !1
            }
            return !0
        }

        intersectsBox(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = t[n];
                if (Id.x = i.normal.x > 0 ? e.max.x : e.min.x, Id.y = i.normal.y > 0 ? e.max.y : e.min.y, Id.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Id) < 0) return !1
            }
            return !0
        }

        containsPoint(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
            return !0
        }

        clone() {
            return (new this.constructor).copy(this)
        }
    }

    function Dd() {
        let e = null, t = !1, n = null, i = null;

        function r(t, s) {
            n(t, s), i = e.requestAnimationFrame(r)
        }

        return {
            start: function () {
                !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0)
            }, stop: function () {
                e.cancelAnimationFrame(i), t = !1
            }, setAnimationLoop: function (e) {
                n = e
            }, setContext: function (t) {
                e = t
            }
        }
    }

    function Nd(e, t) {
        const n = t.isWebGL2, i = new WeakMap;
        return {
            get: function (e) {
                return e.isInterleavedBufferAttribute && (e = e.data), i.get(e)
            }, remove: function (t) {
                t.isInterleavedBufferAttribute && (t = t.data);
                const n = i.get(t);
                n && (e.deleteBuffer(n.buffer), i.delete(t))
            }, update: function (t, r) {
                if (t.isGLBufferAttribute) {
                    const e = i.get(t);
                    return void ((!e || e.version < t.version) && i.set(t, {
                        buffer: t.buffer,
                        type: t.type,
                        bytesPerElement: t.elementSize,
                        version: t.version
                    }))
                }
                t.isInterleavedBufferAttribute && (t = t.data);
                const s = i.get(t);
                void 0 === s ? i.set(t, function (t, i) {
                    const r = t.array, s = t.usage, a = e.createBuffer();
                    e.bindBuffer(i, a), e.bufferData(i, r, s), t.onUploadCallback();
                    let o = 5126;
                    return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? o = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (o = 5121), {
                        buffer: a,
                        type: o,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(t, r)) : s.version < t.version && (!function (t, i, r) {
                    const s = i.array, a = i.updateRange;
                    e.bindBuffer(r, t), -1 === a.count ? e.bufferSubData(r, 0, s) : (n ? e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
                }(s.buffer, t, r), s.version = t.version)
            }
        }
    }

    class Bd extends Ku {
        constructor(e = 1, t = 1, n = 1, i = 1) {
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            };
            const r = e / 2, s = t / 2, a = Math.floor(n), o = Math.floor(i), l = a + 1, c = o + 1, h = e / a,
                u = t / o, d = [], p = [], f = [], m = [];
            for (let e = 0; e < c; e++) {
                const t = e * u - s;
                for (let n = 0; n < l; n++) {
                    const i = n * h - r;
                    p.push(i, -t, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - e / o)
                }
            }
            for (let e = 0; e < o; e++) for (let t = 0; t < a; t++) {
                const n = t + l * e, i = t + l * (e + 1), r = t + 1 + l * (e + 1), s = t + 1 + l * e;
                d.push(n, i, s), d.push(i, r, s)
            }
            this.setIndex(d), this.setAttribute("position", new Gu(p, 3)), this.setAttribute("normal", new Gu(f, 3)), this.setAttribute("uv", new Gu(m, 2))
        }

        static fromJSON(e) {
            return new Bd(e.width, e.height, e.widthSegments, e.heightSegments)
        }
    }

    const kd = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenTint * ( D * V );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n\tuniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
    }, Ud = {
        common: {
            diffuse: {value: new Nu(16777215)},
            opacity: {value: 1},
            map: {value: null},
            uvTransform: {value: new th},
            uv2Transform: {value: new th},
            alphaMap: {value: null},
            alphaTest: {value: 0}
        },
        specularmap: {specularMap: {value: null}},
        envmap: {
            envMap: {value: null},
            flipEnvMap: {value: -1},
            reflectivity: {value: 1},
            ior: {value: 1.5},
            refractionRatio: {value: .98},
            maxMipLevel: {value: 0}
        },
        aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
        lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
        emissivemap: {emissiveMap: {value: null}},
        bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
        normalmap: {normalMap: {value: null}, normalScale: {value: new eh(1, 1)}},
        displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}},
        roughnessmap: {roughnessMap: {value: null}},
        metalnessmap: {metalnessMap: {value: null}},
        gradientmap: {gradientMap: {value: null}},
        fog: {
            fogDensity: {value: 25e-5},
            fogNear: {value: 1},
            fogFar: {value: 2e3},
            fogColor: {value: new Nu(16777215)}
        },
        lights: {
            ambientLightColor: {value: []},
            lightProbe: {value: []},
            directionalLights: {value: [], properties: {direction: {}, color: {}}},
            directionalLightShadows: {
                value: [],
                properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
            },
            directionalShadowMap: {value: []},
            directionalShadowMatrix: {value: []},
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
            },
            spotShadowMap: {value: []},
            spotShadowMatrix: {value: []},
            pointLights: {value: [], properties: {color: {}, position: {}, decay: {}, distance: {}}},
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {value: []},
            pointShadowMatrix: {value: []},
            hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
            rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}},
            ltc_1: {value: null},
            ltc_2: {value: null}
        },
        points: {
            diffuse: {value: new Nu(16777215)},
            opacity: {value: 1},
            size: {value: 1},
            scale: {value: 1},
            map: {value: null},
            alphaMap: {value: null},
            alphaTest: {value: 0},
            uvTransform: {value: new th}
        },
        sprite: {
            diffuse: {value: new Nu(16777215)},
            opacity: {value: 1},
            center: {value: new eh(.5, .5)},
            rotation: {value: 0},
            map: {value: null},
            alphaMap: {value: null},
            alphaTest: {value: 0},
            uvTransform: {value: new th}
        }
    }, Fd = {
        basic: {
            uniforms: _d([Ud.common, Ud.specularmap, Ud.envmap, Ud.aomap, Ud.lightmap, Ud.fog]),
            vertexShader: kd.meshbasic_vert,
            fragmentShader: kd.meshbasic_frag
        },
        lambert: {
            uniforms: _d([Ud.common, Ud.specularmap, Ud.envmap, Ud.aomap, Ud.lightmap, Ud.emissivemap, Ud.fog, Ud.lights, {emissive: {value: new Nu(0)}}]),
            vertexShader: kd.meshlambert_vert,
            fragmentShader: kd.meshlambert_frag
        },
        phong: {
            uniforms: _d([Ud.common, Ud.specularmap, Ud.envmap, Ud.aomap, Ud.lightmap, Ud.emissivemap, Ud.bumpmap, Ud.normalmap, Ud.displacementmap, Ud.fog, Ud.lights, {
                emissive: {value: new Nu(0)},
                specular: {value: new Nu(1118481)},
                shininess: {value: 30}
            }]), vertexShader: kd.meshphong_vert, fragmentShader: kd.meshphong_frag
        },
        standard: {
            uniforms: _d([Ud.common, Ud.envmap, Ud.aomap, Ud.lightmap, Ud.emissivemap, Ud.bumpmap, Ud.normalmap, Ud.displacementmap, Ud.roughnessmap, Ud.metalnessmap, Ud.fog, Ud.lights, {
                emissive: {value: new Nu(0)},
                roughness: {value: 1},
                metalness: {value: 0},
                envMapIntensity: {value: 1}
            }]), vertexShader: kd.meshphysical_vert, fragmentShader: kd.meshphysical_frag
        },
        toon: {
            uniforms: _d([Ud.common, Ud.aomap, Ud.lightmap, Ud.emissivemap, Ud.bumpmap, Ud.normalmap, Ud.displacementmap, Ud.gradientmap, Ud.fog, Ud.lights, {emissive: {value: new Nu(0)}}]),
            vertexShader: kd.meshtoon_vert,
            fragmentShader: kd.meshtoon_frag
        },
        matcap: {
            uniforms: _d([Ud.common, Ud.bumpmap, Ud.normalmap, Ud.displacementmap, Ud.fog, {matcap: {value: null}}]),
            vertexShader: kd.meshmatcap_vert,
            fragmentShader: kd.meshmatcap_frag
        },
        points: {uniforms: _d([Ud.points, Ud.fog]), vertexShader: kd.points_vert, fragmentShader: kd.points_frag},
        dashed: {
            uniforms: _d([Ud.common, Ud.fog, {scale: {value: 1}, dashSize: {value: 1}, totalSize: {value: 2}}]),
            vertexShader: kd.linedashed_vert,
            fragmentShader: kd.linedashed_frag
        },
        depth: {
            uniforms: _d([Ud.common, Ud.displacementmap]),
            vertexShader: kd.depth_vert,
            fragmentShader: kd.depth_frag
        },
        normal: {
            uniforms: _d([Ud.common, Ud.bumpmap, Ud.normalmap, Ud.displacementmap, {opacity: {value: 1}}]),
            vertexShader: kd.meshnormal_vert,
            fragmentShader: kd.meshnormal_frag
        },
        sprite: {uniforms: _d([Ud.sprite, Ud.fog]), vertexShader: kd.sprite_vert, fragmentShader: kd.sprite_frag},
        background: {
            uniforms: {uvTransform: {value: new th}, t2D: {value: null}},
            vertexShader: kd.background_vert,
            fragmentShader: kd.background_frag
        },
        cube: {
            uniforms: _d([Ud.envmap, {opacity: {value: 1}}]),
            vertexShader: kd.cube_vert,
            fragmentShader: kd.cube_frag
        },
        equirect: {
            uniforms: {tEquirect: {value: null}},
            vertexShader: kd.equirect_vert,
            fragmentShader: kd.equirect_frag
        },
        distanceRGBA: {
            uniforms: _d([Ud.common, Ud.displacementmap, {
                referencePosition: {value: new ph},
                nearDistance: {value: 1},
                farDistance: {value: 1e3}
            }]), vertexShader: kd.distanceRGBA_vert, fragmentShader: kd.distanceRGBA_frag
        },
        shadow: {
            uniforms: _d([Ud.lights, Ud.fog, {color: {value: new Nu(0)}, opacity: {value: 1}}]),
            vertexShader: kd.shadow_vert,
            fragmentShader: kd.shadow_frag
        }
    };

    function Hd(e, t, n, i, r) {
        const s = new Nu(0);
        let a, o, l = 0, c = null, h = 0, u = null;

        function d(e, t) {
            n.buffers.color.setClear(e.r, e.g, e.b, t, r)
        }

        return {
            getClearColor: function () {
                return s
            }, setClearColor: function (e, t = 1) {
                s.set(e), l = t, d(s, l)
            }, getClearAlpha: function () {
                return l
            }, setClearAlpha: function (e) {
                l = e, d(s, l)
            }, render: function (n, r) {
                let p = !1, f = !0 === r.isScene ? r.background : null;
                f && f.isTexture && (f = t.get(f));
                const m = e.xr, g = m.getSession && m.getSession();
                g && "additive" === g.environmentBlendMode && (f = null), null === f ? d(s, l) : f && f.isColor && (d(f, 1), p = !0), (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), f && (f.isCubeTexture || f.mapping === ec) ? (void 0 === o && (o = new fd(new gd(1, 1, 1), new xd({
                    name: "BackgroundCubeMaterial",
                    uniforms: vd(Fd.cube.uniforms),
                    vertexShader: Fd.cube.vertexShader,
                    fragmentShader: Fd.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), o.geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }, Object.defineProperty(o.material, "envMap", {
                    get: function () {
                        return this.uniforms.envMap.value
                    }
                }), i.update(o)), o.material.uniforms.envMap.value = f, o.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, c === f && h === f.version && u === e.toneMapping || (o.material.needsUpdate = !0, c = f, h = f.version, u = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : f && f.isTexture && (void 0 === a && (a = new fd(new Bd(2, 2), new xd({
                    name: "BackgroundMaterial",
                    uniforms: vd(Fd.background.uniforms),
                    vertexShader: Fd.background.vertexShader,
                    fragmentShader: Fd.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
                    get: function () {
                        return this.uniforms.t2D.value
                    }
                }), i.update(a)), a.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), a.material.uniforms.uvTransform.value.copy(f.matrix), c === f && h === f.version && u === e.toneMapping || (a.material.needsUpdate = !0, c = f, h = f.version, u = e.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null))
            }
        }
    }

    function zd(e, t, n, i) {
        const r = e.getParameter(34921), s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
            a = i.isWebGL2 || null !== s, o = {}, l = d(null);
        let c = l;

        function h(t) {
            return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t)
        }

        function u(t) {
            return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t)
        }

        function d(e) {
            const t = [], n = [], i = [];
            for (let e = 0; e < r; e++) t[e] = 0, n[e] = 0, i[e] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: t,
                enabledAttributes: n,
                attributeDivisors: i,
                object: e,
                attributes: {},
                index: null
            }
        }

        function p() {
            const e = c.newAttributes;
            for (let t = 0, n = e.length; t < n; t++) e[t] = 0
        }

        function f(e) {
            m(e, 0)
        }

        function m(n, r) {
            const s = c.newAttributes, a = c.enabledAttributes, o = c.attributeDivisors;
            if (s[n] = 1, 0 === a[n] && (e.enableVertexAttribArray(n), a[n] = 1), o[n] !== r) {
                (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r
            }
        }

        function g() {
            const t = c.newAttributes, n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
        }

        function v(t, n, r, s, a, o) {
            !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, s, a, o) : e.vertexAttribIPointer(t, n, r, a, o)
        }

        function _() {
            y(), c !== l && (c = l, h(c.object))
        }

        function y() {
            l.geometry = null, l.program = null, l.wireframe = !1
        }

        return {
            setup: function (r, l, u, _, y) {
                let x = !1;
                if (a) {
                    const t = function (t, n, r) {
                        const a = !0 === r.wireframe;
                        let l = o[t.id];
                        void 0 === l && (l = {}, o[t.id] = l);
                        let c = l[n.id];
                        void 0 === c && (c = {}, l[n.id] = c);
                        let h = c[a];
                        void 0 === h && (h = d(i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[a] = h);
                        return h
                    }(_, u, l);
                    c !== t && (c = t, h(c.object)), x = function (e, t) {
                        const n = c.attributes, i = e.attributes;
                        let r = 0;
                        for (const e in i) {
                            const t = n[e], s = i[e];
                            if (void 0 === t) return !0;
                            if (t.attribute !== s) return !0;
                            if (t.data !== s.data) return !0;
                            r++
                        }
                        return c.attributesNum !== r || c.index !== t
                    }(_, y), x && function (e, t) {
                        const n = {}, i = e.attributes;
                        let r = 0;
                        for (const e in i) {
                            const t = i[e], s = {};
                            s.attribute = t, t.data && (s.data = t.data), n[e] = s, r++
                        }
                        c.attributes = n, c.attributesNum = r, c.index = t
                    }(_, y)
                } else {
                    const e = !0 === l.wireframe;
                    c.geometry === _.id && c.program === u.id && c.wireframe === e || (c.geometry = _.id, c.program = u.id, c.wireframe = e, x = !0)
                }
                !0 === r.isInstancedMesh && (x = !0), null !== y && n.update(y, 34963), x && (!function (r, s, a, o) {
                    if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                    p();
                    const l = o.attributes, c = a.getAttributes(), h = s.defaultAttributeValues;
                    for (const t in c) {
                        const i = c[t];
                        if (i.location >= 0) {
                            let s = l[t];
                            if (void 0 === s && ("instanceMatrix" === t && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === t && r.instanceColor && (s = r.instanceColor)), void 0 !== s) {
                                const t = s.normalized, a = s.itemSize, l = n.get(s);
                                if (void 0 === l) continue;
                                const c = l.buffer, h = l.type, u = l.bytesPerElement;
                                if (s.isInterleavedBufferAttribute) {
                                    const n = s.data, l = n.stride, d = s.offset;
                                    if (n && n.isInstancedInterleavedBuffer) {
                                        for (let e = 0; e < i.locationSize; e++) m(i.location + e, n.meshPerAttribute);
                                        !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                    } else for (let e = 0; e < i.locationSize; e++) f(i.location + e);
                                    e.bindBuffer(34962, c);
                                    for (let e = 0; e < i.locationSize; e++) v(i.location + e, a / i.locationSize, h, t, l * u, (d + a / i.locationSize * e) * u)
                                } else {
                                    if (s.isInstancedBufferAttribute) {
                                        for (let e = 0; e < i.locationSize; e++) m(i.location + e, s.meshPerAttribute);
                                        !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                    } else for (let e = 0; e < i.locationSize; e++) f(i.location + e);
                                    e.bindBuffer(34962, c);
                                    for (let e = 0; e < i.locationSize; e++) v(i.location + e, a / i.locationSize, h, t, a * u, a / i.locationSize * e * u)
                                }
                            } else if (void 0 !== h) {
                                const n = h[t];
                                if (void 0 !== n) switch (n.length) {
                                    case 2:
                                        e.vertexAttrib2fv(i.location, n);
                                        break;
                                    case 3:
                                        e.vertexAttrib3fv(i.location, n);
                                        break;
                                    case 4:
                                        e.vertexAttrib4fv(i.location, n);
                                        break;
                                    default:
                                        e.vertexAttrib1fv(i.location, n)
                                }
                            }
                        }
                    }
                    g()
                }(r, l, u, _), null !== y && e.bindBuffer(34963, n.get(y).buffer))
            }, reset: _, resetDefaultState: y, dispose: function () {
                _();
                for (const e in o) {
                    const t = o[e];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n) u(n[e].object), delete n[e];
                        delete t[e]
                    }
                    delete o[e]
                }
            }, releaseStatesOfGeometry: function (e) {
                if (void 0 === o[e.id]) return;
                const t = o[e.id];
                for (const e in t) {
                    const n = t[e];
                    for (const e in n) u(n[e].object), delete n[e];
                    delete t[e]
                }
                delete o[e.id]
            }, releaseStatesOfProgram: function (e) {
                for (const t in o) {
                    const n = o[t];
                    if (void 0 === n[e.id]) continue;
                    const i = n[e.id];
                    for (const e in i) u(i[e].object), delete i[e];
                    delete n[e.id]
                }
            }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: g
        }
    }

    function Gd(e, t, n, i) {
        const r = i.isWebGL2;
        let s;
        this.setMode = function (e) {
            s = e
        }, this.render = function (t, i) {
            e.drawArrays(s, t, i), n.update(i, s, 1)
        }, this.renderInstances = function (i, a, o) {
            if (0 === o) return;
            let l, c;
            if (r) l = e, c = "drawArraysInstanced"; else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[c](s, i, a, o), n.update(a, s, o)
        }
    }

    function Vd(e, t, n) {
        let i;

        function r(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }

        const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
        let a = void 0 !== n.precision ? n.precision : "highp";
        const o = r(a);
        o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
        const l = s || t.has("WEBGL_draw_buffers"), c = !0 === n.logarithmicDepthBuffer, h = e.getParameter(34930),
            u = e.getParameter(35660), d = e.getParameter(3379), p = e.getParameter(34076), f = e.getParameter(34921),
            m = e.getParameter(36347), g = e.getParameter(36348), v = e.getParameter(36349), _ = u > 0,
            y = s || t.has("OES_texture_float");
        return {
            isWebGL2: s,
            drawBuffers: l,
            getMaxAnisotropy: function () {
                if (void 0 !== i) return i;
                if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                    const n = t.get("EXT_texture_filter_anisotropic");
                    i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else i = 0;
                return i
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: m,
            maxVaryings: g,
            maxFragmentUniforms: v,
            vertexTextures: _,
            floatFragmentTextures: y,
            floatVertexTextures: _ && y,
            maxSamples: s ? e.getParameter(36183) : 0
        }
    }

    function Wd(e) {
        const t = this;
        let n = null, i = 0, r = !1, s = !1;
        const a = new Rd, o = new th, l = {value: null, needsUpdate: !1};

        function c() {
            l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
        }

        function h(e, n, i, r) {
            const s = null !== e ? e.length : 0;
            let c = null;
            if (0 !== s) {
                if (c = l.value, !0 !== r || null === c) {
                    const t = i + 4 * s, r = n.matrixWorldInverse;
                    o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
                    for (let t = 0, n = i; t !== s; ++t, n += 4) a.copy(e[t]).applyMatrix4(r, o), a.normal.toArray(c, n), c[n + 3] = a.constant
                }
                l.value = c, l.needsUpdate = !0
            }
            return t.numPlanes = s, t.numIntersection = 0, c
        }

        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, s) {
            const a = 0 !== e.length || t || 0 !== i || r;
            return r = t, n = h(e, s, 0), i = e.length, a
        }, this.beginShadows = function () {
            s = !0, h(null)
        }, this.endShadows = function () {
            s = !1, c()
        }, this.setState = function (t, a, o) {
            const u = t.clippingPlanes, d = t.clipIntersection, p = t.clipShadows, f = e.get(t);
            if (!r || null === u || 0 === u.length || s && !p) s ? h(null) : c(); else {
                const e = s ? 0 : i, t = 4 * e;
                let r = f.clippingState || null;
                l.value = r, r = h(u, a, t, o);
                for (let e = 0; e !== t; ++e) r[e] = n[e];
                f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
            }
        }
    }

    function jd(e) {
        let t = new WeakMap;

        function n(e, t) {
            return 303 === t ? e.mapping = Zl : 304 === t && (e.mapping = Ql), e
        }

        function i(e) {
            const n = e.target;
            n.removeEventListener("dispose", i);
            const r = t.get(n);
            void 0 !== r && (t.delete(n), r.dispose())
        }

        return {
            get: function (r) {
                if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                    const s = r.mapping;
                    if (303 === s || 304 === s) {
                        if (t.has(r)) {
                            return n(t.get(r).texture, r.mapping)
                        }
                        {
                            const s = r.image;
                            if (s && s.height > 0) {
                                const a = e.getRenderTarget(), o = new Md(s.height / 2);
                                return o.fromEquirectangularTexture(e, r), t.set(r, o), e.setRenderTarget(a), r.addEventListener("dispose", i), n(o.texture, r.mapping)
                            }
                            return null
                        }
                    }
                }
                return r
            }, dispose: function () {
                t = new WeakMap
            }
        }
    }

    Fd.physical = {
        uniforms: _d([Fd.standard.uniforms, {
            clearcoat: {value: 0},
            clearcoatMap: {value: null},
            clearcoatRoughness: {value: 0},
            clearcoatRoughnessMap: {value: null},
            clearcoatNormalScale: {value: new eh(1, 1)},
            clearcoatNormalMap: {value: null},
            sheen: {value: 0},
            sheenTint: {value: new Nu(0)},
            sheenRoughness: {value: 0},
            transmission: {value: 0},
            transmissionMap: {value: null},
            transmissionSamplerSize: {value: new eh},
            transmissionSamplerMap: {value: null},
            thickness: {value: 0},
            thicknessMap: {value: null},
            attenuationDistance: {value: 0},
            attenuationTint: {value: new Nu(0)},
            specularIntensity: {value: 0},
            specularIntensityMap: {value: null},
            specularTint: {value: new Nu(1, 1, 1)},
            specularTintMap: {value: null}
        }]), vertexShader: kd.meshphysical_vert, fragmentShader: kd.meshphysical_frag
    };

    class $d extends bd {
        constructor(e = -1, t = 1, n = 1, i = -1, r = .1, s = 2e3) {
            super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
        }

        copy(e, t) {
            return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        }

        setViewOffset(e, t, n, i, r, s) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
        }

        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }

        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
            let r = n - e, s = n + e, a = i + t, o = i - t;
            if (null !== this.view && this.view.enabled) {
                const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += e * this.view.offsetX, s = r + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }

        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
        }
    }

    $d.prototype.isOrthographicCamera = !0;

    class Xd extends xd {
        constructor(e) {
            super(e), this.type = "RawShaderMaterial"
        }
    }

    Xd.prototype.isRawShaderMaterial = !0;
    const qd = Math.pow(2, 8), Yd = [.125, .215, .35, .446, .526, .582], Kd = 5 + Yd.length, Jd = 20,
        Zd = {[Ic]: 0, [Oc]: 1, [Nc]: 2, 3004: 3, 3005: 4, 3006: 5, [Dc]: 6}, Qd = new $d, {
            _lodPlanes: ep,
            _sizeLods: tp,
            _sigmas: np
        } = hp(), ip = new Nu;
    let rp = null;
    const sp = (1 + Math.sqrt(5)) / 2, ap = 1 / sp,
        op = [new ph(1, 1, 1), new ph(-1, 1, 1), new ph(1, 1, -1), new ph(-1, 1, -1), new ph(0, sp, ap), new ph(0, sp, -ap), new ph(ap, 0, sp), new ph(-ap, 0, sp), new ph(sp, ap, 0), new ph(-sp, ap, 0)];

    class lp {
        constructor(e) {
            this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = function (e) {
                const t = new Float32Array(e), n = new ph(0, 1, 0);
                return new Xd({
                    name: "SphericalGaussianBlur",
                    defines: {n: e},
                    uniforms: {
                        envMap: {value: null},
                        samples: {value: 1},
                        weights: {value: t},
                        latitudinal: {value: !1},
                        dTheta: {value: 0},
                        mipInt: {value: 0},
                        poleAxis: {value: n},
                        inputEncoding: {value: Zd[3e3]},
                        outputEncoding: {value: Zd[3e3]}
                    },
                    vertexShader: mp(),
                    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${gp()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }(Jd), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
        }

        fromScene(e, t = 0, n = .1, i = 100) {
            rp = this._renderer.getRenderTarget();
            const r = this._allocateTargets();
            return this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
        }

        fromEquirectangular(e) {
            return this._fromTexture(e)
        }

        fromCubemap(e) {
            return this._fromTexture(e)
        }

        compileCubemapShader() {
            null === this._cubemapShader && (this._cubemapShader = fp(), this._compileMaterial(this._cubemapShader))
        }

        compileEquirectangularShader() {
            null === this._equirectShader && (this._equirectShader = pp(), this._compileMaterial(this._equirectShader))
        }

        dispose() {
            this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
            for (let e = 0; e < ep.length; e++) ep[e].dispose()
        }

        _cleanup(e) {
            this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(rp), e.scissorTest = !1, dp(e, 0, 0, e.width, e.height)
        }

        _fromTexture(e) {
            rp = this._renderer.getRenderTarget();
            const t = this._allocateTargets(e);
            return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
        }

        _allocateTargets(e) {
            const t = {
                magFilter: rc,
                minFilter: rc,
                generateMipmaps: !1,
                type: cc,
                format: 1023,
                encoding: cp(e) ? e.encoding : Nc,
                depthBuffer: !1
            }, n = up(t);
            return n.depthBuffer = !e, this._pingPongRenderTarget = up(t), n
        }

        _compileMaterial(e) {
            const t = new fd(ep[0], e);
            this._renderer.compile(t, Qd)
        }

        _sceneToCubeUV(e, t, n, i) {
            const r = new wd(90, 1, t, n), s = [1, -1, 1, 1, 1, 1], a = [1, 1, 1, -1, -1, -1], o = this._renderer,
                l = o.autoClear, c = o.outputEncoding, h = o.toneMapping;
            o.getClearColor(ip), o.toneMapping = 0, o.outputEncoding = Ic, o.autoClear = !1;
            const u = new Bu({name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1}), d = new fd(new gd, u);
            let p = !1;
            const f = e.background;
            f ? f.isColor && (u.color.copy(f), e.background = null, p = !0) : (u.color.copy(ip), p = !0);
            for (let t = 0; t < 6; t++) {
                const n = t % 3;
                0 == n ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0)) : 1 == n ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t])), dp(i, n * qd, t > 2 ? qd : 0, qd, qd), o.setRenderTarget(i), p && o.render(d, r), o.render(e, r)
            }
            d.geometry.dispose(), d.material.dispose(), o.toneMapping = h, o.outputEncoding = c, o.autoClear = l, e.background = f
        }

        _setEncoding(e, t) {
            !0 === this._renderer.capabilities.isWebGL2 && t.format === gc && t.type === cc && t.encoding === Oc ? e.value = Zd[3e3] : e.value = Zd[t.encoding]
        }

        _textureToCubeUV(e, t) {
            const n = this._renderer;
            e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = fp()) : null == this._equirectShader && (this._equirectShader = pp());
            const i = e.isCubeTexture ? this._cubemapShader : this._equirectShader, r = new fd(ep[0], i),
                s = i.uniforms;
            s.envMap.value = e, e.isCubeTexture || s.texelSize.value.set(1 / e.image.width, 1 / e.image.height), this._setEncoding(s.inputEncoding, e), this._setEncoding(s.outputEncoding, t.texture), dp(t, 0, 0, 3 * qd, 2 * qd), n.setRenderTarget(t), n.render(r, Qd)
        }

        _applyPMREM(e) {
            const t = this._renderer, n = t.autoClear;
            t.autoClear = !1;
            for (let t = 1; t < Kd; t++) {
                const n = Math.sqrt(np[t] * np[t] - np[t - 1] * np[t - 1]), i = op[(t - 1) % op.length];
                this._blur(e, t - 1, t, n, i)
            }
            t.autoClear = n
        }

        _blur(e, t, n, i, r) {
            const s = this._pingPongRenderTarget;
            this._halfBlur(e, s, t, n, i, "latitudinal", r), this._halfBlur(s, e, n, n, i, "longitudinal", r)
        }

        _halfBlur(e, t, n, i, r, s, a) {
            const o = this._renderer, l = this._blurMaterial;
            "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
            const c = new fd(ep[i], l), h = l.uniforms, u = tp[n] - 1,
                d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39, p = r / d,
                f = isFinite(r) ? 1 + Math.floor(3 * p) : Jd;
            f > Jd && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
            const m = [];
            let g = 0;
            for (let e = 0; e < Jd; ++e) {
                const t = e / p, n = Math.exp(-t * t / 2);
                m.push(n), 0 == e ? g += n : e < f && (g += 2 * n)
            }
            for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
            h.envMap.value = e.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = 8 - n, this._setEncoding(h.inputEncoding, e.texture), this._setEncoding(h.outputEncoding, e.texture);
            const v = tp[i];
            dp(t, 3 * Math.max(0, qd - 2 * v), (0 === i ? 0 : 2 * qd) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), o.setRenderTarget(t), o.render(c, Qd)
        }
    }

    function cp(e) {
        return void 0 !== e && e.type === cc && (e.encoding === Ic || e.encoding === Oc || e.encoding === Dc)
    }

    function hp() {
        const e = [], t = [], n = [];
        let i = 8;
        for (let r = 0; r < Kd; r++) {
            const s = Math.pow(2, i);
            t.push(s);
            let a = 1 / s;
            r > 4 ? a = Yd[r - 8 + 4 - 1] : 0 == r && (a = 0), n.push(a);
            const o = 1 / (s - 1), l = -o / 2, c = 1 + o / 2, h = [l, l, c, l, c, c, l, l, c, c, l, c], u = 6, d = 6,
                p = 3, f = 2, m = 1, g = new Float32Array(p * d * u), v = new Float32Array(f * d * u),
                _ = new Float32Array(m * d * u);
            for (let e = 0; e < u; e++) {
                const t = e % 3 * 2 / 3 - 1, n = e > 2 ? 0 : -1,
                    i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                g.set(i, p * d * e), v.set(h, f * d * e);
                const r = [e, e, e, e, e, e];
                _.set(r, m * d * e)
            }
            const y = new Ku;
            y.setAttribute("position", new Fu(g, p)), y.setAttribute("uv", new Fu(v, f)), y.setAttribute("faceIndex", new Fu(_, m)), e.push(y), i > 4 && i--
        }
        return {_lodPlanes: e, _sizeLods: t, _sigmas: n}
    }

    function up(e) {
        const t = new hh(3 * qd, 3 * qd, e);
        return t.texture.mapping = ec, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
    }

    function dp(e, t, n, i, r) {
        e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
    }

    function pp() {
        const e = new eh(1, 1);
        return new Xd({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {value: null},
                texelSize: {value: e},
                inputEncoding: {value: Zd[3e3]},
                outputEncoding: {value: Zd[3e3]}
            },
            vertexShader: mp(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${gp()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function fp() {
        return new Xd({
            name: "CubemapToCubeUV",
            uniforms: {envMap: {value: null}, inputEncoding: {value: Zd[3e3]}, outputEncoding: {value: Zd[3e3]}},
            vertexShader: mp(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${gp()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function mp() {
        return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
    }

    function gp() {
        return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
    }

    function vp(e) {
        let t = new WeakMap, n = null;

        function i(e) {
            const n = e.target;
            n.removeEventListener("dispose", i);
            const r = t.get(n);
            void 0 !== r && (t.delete(n), r.dispose())
        }

        return {
            get: function (r) {
                if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                    const s = r.mapping, a = 303 === s || 304 === s, o = s === Zl || s === Ql;
                    if (a || o) {
                        if (t.has(r)) return t.get(r).texture;
                        {
                            const s = r.image;
                            if (a && s && s.height > 0 || o && s && function (e) {
                                let t = 0;
                                const n = 6;
                                for (let i = 0; i < n; i++) void 0 !== e[i] && t++;
                                return t === n
                            }(s)) {
                                const s = e.getRenderTarget();
                                null === n && (n = new lp(e));
                                const o = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                return t.set(r, o), e.setRenderTarget(s), r.addEventListener("dispose", i), o.texture
                            }
                            return null
                        }
                    }
                }
                return r
            }, dispose: function () {
                t = new WeakMap, null !== n && (n.dispose(), n = null)
            }
        }
    }

    function _p(e) {
        const t = {};

        function n(n) {
            if (void 0 !== t[n]) return t[n];
            let i;
            switch (n) {
                case"WEBGL_depth_texture":
                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case"EXT_texture_filter_anisotropic":
                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case"WEBGL_compressed_texture_s3tc":
                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case"WEBGL_compressed_texture_pvrtc":
                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = e.getExtension(n)
            }
            return t[n] = i, i
        }

        return {
            has: function (e) {
                return null !== n(e)
            }, init: function (e) {
                e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float")
            }, get: function (e) {
                const t = n(e);
                return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
            }
        }
    }

    function yp(e, t, n, i) {
        const r = {}, s = new WeakMap;

        function a(e) {
            const o = e.target;
            null !== o.index && t.remove(o.index);
            for (const e in o.attributes) t.remove(o.attributes[e]);
            o.removeEventListener("dispose", a), delete r[o.id];
            const l = s.get(o);
            l && (t.remove(l), s.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
        }

        function o(e) {
            const n = [], i = e.index, r = e.attributes.position;
            let a = 0;
            if (null !== i) {
                const e = i.array;
                a = i.version;
                for (let t = 0, i = e.length; t < i; t += 3) {
                    const i = e[t + 0], r = e[t + 1], s = e[t + 2];
                    n.push(i, r, r, s, s, i)
                }
            } else {
                const e = r.array;
                a = r.version;
                for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                    const e = t + 0, i = t + 1, r = t + 2;
                    n.push(e, i, i, r, r, e)
                }
            }
            const o = new (nh(n) > 65535 ? zu : Hu)(n, 1);
            o.version = a;
            const l = s.get(e);
            l && t.remove(l), s.set(e, o)
        }

        return {
            get: function (e, t) {
                return !0 === r[t.id] || (t.addEventListener("dispose", a), r[t.id] = !0, n.memory.geometries++), t
            }, update: function (e) {
                const n = e.attributes;
                for (const e in n) t.update(n[e], 34962);
                const i = e.morphAttributes;
                for (const e in i) {
                    const n = i[e];
                    for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962)
                }
            }, getWireframeAttribute: function (e) {
                const t = s.get(e);
                if (t) {
                    const n = e.index;
                    null !== n && t.version < n.version && o(e)
                } else o(e);
                return s.get(e)
            }
        }
    }

    function xp(e, t, n, i) {
        const r = i.isWebGL2;
        let s, a, o;
        this.setMode = function (e) {
            s = e
        }, this.setIndex = function (e) {
            a = e.type, o = e.bytesPerElement
        }, this.render = function (t, i) {
            e.drawElements(s, i, a, t * o), n.update(i, s, 1)
        }, this.renderInstances = function (i, l, c) {
            if (0 === c) return;
            let h, u;
            if (r) h = e, u = "drawElementsInstanced"; else if (h = t.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[u](s, l, a, i * o, c), n.update(l, s, c)
        }
    }

    function bp(e) {
        const t = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
        return {
            memory: {geometries: 0, textures: 0}, render: t, programs: null, autoReset: !0, reset: function () {
                t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
            }, update: function (e, n, i) {
                switch (t.calls++, n) {
                    case 4:
                        t.triangles += i * (e / 3);
                        break;
                    case 1:
                        t.lines += i * (e / 2);
                        break;
                    case 3:
                        t.lines += i * (e - 1);
                        break;
                    case 2:
                        t.lines += i * e;
                        break;
                    case 0:
                        t.points += i * e;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                }
            }
        }
    }

    class wp extends oh {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = rc, this.minFilter = rc, this.wrapR = nc, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }
    }

    function Tp(e, t) {
        return e[0] - t[0]
    }

    function Sp(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function Ep(e, t) {
        let n = 1;
        const i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
        i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), e.divideScalar(n)
    }

    function Mp(e, t, n) {
        const i = {}, r = new Float32Array(8), s = new WeakMap, a = new ph, o = [];
        for (let e = 0; e < 8; e++) o[e] = [e, 0];
        return {
            update: function (l, c, h, u) {
                const d = l.morphTargetInfluences;
                if (!0 === t.isWebGL2) {
                    const i = c.morphAttributes.position.length;
                    let r = s.get(c);
                    if (void 0 === r || r.count !== i) {
                        void 0 !== r && r.texture.dispose();
                        const e = void 0 !== c.morphAttributes.normal, n = c.morphAttributes.position,
                            o = c.morphAttributes.normal || [], l = !0 === e ? 2 : 1;
                        let h = c.attributes.position.count * l, u = 1;
                        h > t.maxTextureSize && (u = Math.ceil(h / t.maxTextureSize), h = t.maxTextureSize);
                        const d = new Float32Array(h * u * 4 * i), p = new wp(d, h, u, i);
                        p.format = gc, p.type = dc;
                        const f = 4 * l;
                        for (let t = 0; t < i; t++) {
                            const i = n[t], r = o[t], s = h * u * 4 * t;
                            for (let t = 0; t < i.count; t++) {
                                a.fromBufferAttribute(i, t), !0 === i.normalized && Ep(a, i);
                                const n = t * f;
                                d[s + n + 0] = a.x, d[s + n + 1] = a.y, d[s + n + 2] = a.z, d[s + n + 3] = 0, !0 === e && (a.fromBufferAttribute(r, t), !0 === r.normalized && Ep(a, r), d[s + n + 4] = a.x, d[s + n + 5] = a.y, d[s + n + 6] = a.z, d[s + n + 7] = 0)
                            }
                        }
                        r = {count: i, texture: p, size: new eh(h, u)}, s.set(c, r)
                    }
                    let o = 0;
                    for (let e = 0; e < d.length; e++) o += d[e];
                    const l = c.morphTargetsRelative ? 1 : 1 - o;
                    u.getUniforms().setValue(e, "morphTargetBaseInfluence", l), u.getUniforms().setValue(e, "morphTargetInfluences", d), u.getUniforms().setValue(e, "morphTargetsTexture", r.texture, n), u.getUniforms().setValue(e, "morphTargetsTextureSize", r.size)
                } else {
                    const t = void 0 === d ? 0 : d.length;
                    let n = i[c.id];
                    if (void 0 === n || n.length !== t) {
                        n = [];
                        for (let e = 0; e < t; e++) n[e] = [e, 0];
                        i[c.id] = n
                    }
                    for (let e = 0; e < t; e++) {
                        const t = n[e];
                        t[0] = e, t[1] = d[e]
                    }
                    n.sort(Sp);
                    for (let e = 0; e < 8; e++) e < t && n[e][1] ? (o[e][0] = n[e][0], o[e][1] = n[e][1]) : (o[e][0] = Number.MAX_SAFE_INTEGER, o[e][1] = 0);
                    o.sort(Tp);
                    const s = c.morphAttributes.position, a = c.morphAttributes.normal;
                    let l = 0;
                    for (let e = 0; e < 8; e++) {
                        const t = o[e], n = t[0], i = t[1];
                        n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + e) !== s[n] && c.setAttribute("morphTarget" + e, s[n]), a && c.getAttribute("morphNormal" + e) !== a[n] && c.setAttribute("morphNormal" + e, a[n]), r[e] = i, l += i) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), a && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), r[e] = 0)
                    }
                    const h = c.morphTargetsRelative ? 1 : 1 - l;
                    u.getUniforms().setValue(e, "morphTargetBaseInfluence", h), u.getUniforms().setValue(e, "morphTargetInfluences", r)
                }
            }
        }
    }

    function Ap(e, t, n, i) {
        let r = new WeakMap;

        function s(e) {
            const t = e.target;
            t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
        }

        return {
            update: function (e) {
                const a = i.render.frame, o = e.geometry, l = t.get(e, o);
                return r.get(l) !== a && (t.update(l), r.set(l, a)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l
            }, dispose: function () {
                r = new WeakMap
            }
        }
    }

    wp.prototype.isDataTexture2DArray = !0;

    class Lp extends oh {
        constructor(e = null, t = 1, n = 1, i = 1) {
            super(null), this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = rc, this.minFilter = rc, this.wrapR = nc, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }
    }

    Lp.prototype.isDataTexture3D = !0;
    const Cp = new oh, Rp = new wp, Pp = new Lp, Ip = new Ed, Op = [], Dp = [], Np = new Float32Array(16),
        Bp = new Float32Array(9), kp = new Float32Array(4);

    function Up(e, t, n) {
        const i = e[0];
        if (i <= 0 || i > 0) return e;
        const r = t * n;
        let s = Op[r];
        if (void 0 === s && (s = new Float32Array(r), Op[r] = s), 0 !== t) {
            i.toArray(s, 0);
            for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(s, r)
        }
        return s
    }

    function Fp(e, t) {
        if (e.length !== t.length) return !1;
        for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
        return !0
    }

    function Hp(e, t) {
        for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
    }

    function zp(e, t) {
        let n = Dp[t];
        void 0 === n && (n = new Int32Array(t), Dp[t] = n);
        for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
        return n
    }

    function Gp(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
    }

    function Vp(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else {
            if (Fp(n, t)) return;
            e.uniform2fv(this.addr, t), Hp(n, t)
        }
    }

    function Wp(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b); else {
            if (Fp(n, t)) return;
            e.uniform3fv(this.addr, t), Hp(n, t)
        }
    }

    function jp(e, t) {
        const n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else {
            if (Fp(n, t)) return;
            e.uniform4fv(this.addr, t), Hp(n, t)
        }
    }

    function $p(e, t) {
        const n = this.cache, i = t.elements;
        if (void 0 === i) {
            if (Fp(n, t)) return;
            e.uniformMatrix2fv(this.addr, !1, t), Hp(n, t)
        } else {
            if (Fp(n, i)) return;
            kp.set(i), e.uniformMatrix2fv(this.addr, !1, kp), Hp(n, i)
        }
    }

    function Xp(e, t) {
        const n = this.cache, i = t.elements;
        if (void 0 === i) {
            if (Fp(n, t)) return;
            e.uniformMatrix3fv(this.addr, !1, t), Hp(n, t)
        } else {
            if (Fp(n, i)) return;
            Bp.set(i), e.uniformMatrix3fv(this.addr, !1, Bp), Hp(n, i)
        }
    }

    function qp(e, t) {
        const n = this.cache, i = t.elements;
        if (void 0 === i) {
            if (Fp(n, t)) return;
            e.uniformMatrix4fv(this.addr, !1, t), Hp(n, t)
        } else {
            if (Fp(n, i)) return;
            Np.set(i), e.uniformMatrix4fv(this.addr, !1, Np), Hp(n, i)
        }
    }

    function Yp(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
    }

    function Kp(e, t) {
        const n = this.cache;
        Fp(n, t) || (e.uniform2iv(this.addr, t), Hp(n, t))
    }

    function Jp(e, t) {
        const n = this.cache;
        Fp(n, t) || (e.uniform3iv(this.addr, t), Hp(n, t))
    }

    function Zp(e, t) {
        const n = this.cache;
        Fp(n, t) || (e.uniform4iv(this.addr, t), Hp(n, t))
    }

    function Qp(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
    }

    function ef(e, t) {
        const n = this.cache;
        Fp(n, t) || (e.uniform2uiv(this.addr, t), Hp(n, t))
    }

    function tf(e, t) {
        const n = this.cache;
        Fp(n, t) || (e.uniform3uiv(this.addr, t), Hp(n, t))
    }

    function nf(e, t) {
        const n = this.cache;
        Fp(n, t) || (e.uniform4uiv(this.addr, t), Hp(n, t))
    }

    function rf(e, t, n) {
        const i = this.cache, r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || Cp, r)
    }

    function sf(e, t, n) {
        const i = this.cache, r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || Pp, r)
    }

    function af(e, t, n) {
        const i = this.cache, r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || Ip, r)
    }

    function of(e, t, n) {
        const i = this.cache, r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || Rp, r)
    }

    function lf(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function cf(e, t) {
        const n = Up(t, this.size, 2);
        e.uniform2fv(this.addr, n)
    }

    function hf(e, t) {
        const n = Up(t, this.size, 3);
        e.uniform3fv(this.addr, n)
    }

    function uf(e, t) {
        const n = Up(t, this.size, 4);
        e.uniform4fv(this.addr, n)
    }

    function df(e, t) {
        const n = Up(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n)
    }

    function pf(e, t) {
        const n = Up(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n)
    }

    function ff(e, t) {
        const n = Up(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n)
    }

    function mf(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function gf(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function vf(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function _f(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function yf(e, t) {
        e.uniform1uiv(this.addr, t)
    }

    function xf(e, t) {
        e.uniform2uiv(this.addr, t)
    }

    function bf(e, t) {
        e.uniform3uiv(this.addr, t)
    }

    function wf(e, t) {
        e.uniform4uiv(this.addr, t)
    }

    function Tf(e, t, n) {
        const i = t.length, r = zp(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || Cp, r[e])
    }

    function Sf(e, t, n) {
        const i = t.length, r = zp(n, i);
        e.uniform1iv(this.addr, r);
        for (let e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || Ip, r[e])
    }

    function Ef(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) {
            switch (e) {
                case 5126:
                    return Gp;
                case 35664:
                    return Vp;
                case 35665:
                    return Wp;
                case 35666:
                    return jp;
                case 35674:
                    return $p;
                case 35675:
                    return Xp;
                case 35676:
                    return qp;
                case 5124:
                case 35670:
                    return Yp;
                case 35667:
                case 35671:
                    return Kp;
                case 35668:
                case 35672:
                    return Jp;
                case 35669:
                case 35673:
                    return Zp;
                case 5125:
                    return Qp;
                case 36294:
                    return ef;
                case 36295:
                    return tf;
                case 36296:
                    return nf;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return rf;
                case 35679:
                case 36299:
                case 36307:
                    return sf;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return af;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return of
            }
        }(t.type)
    }

    function Mf(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) {
            switch (e) {
                case 5126:
                    return lf;
                case 35664:
                    return cf;
                case 35665:
                    return hf;
                case 35666:
                    return uf;
                case 35674:
                    return df;
                case 35675:
                    return pf;
                case 35676:
                    return ff;
                case 5124:
                case 35670:
                    return mf;
                case 35667:
                case 35671:
                    return gf;
                case 35668:
                case 35672:
                    return vf;
                case 35669:
                case 35673:
                    return _f;
                case 5125:
                    return yf;
                case 36294:
                    return xf;
                case 36295:
                    return bf;
                case 36296:
                    return wf;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Tf;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Sf
            }
        }(t.type)
    }

    function Af(e) {
        this.id = e, this.seq = [], this.map = {}
    }

    Mf.prototype.updateCache = function (e) {
        const t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Hp(t, e)
    }, Af.prototype.setValue = function (e, t, n) {
        const i = this.seq;
        for (let r = 0, s = i.length; r !== s; ++r) {
            const s = i[r];
            s.setValue(e, t[s.id], n)
        }
    };
    const Lf = /(\w+)(\])?(\[|\.)?/g;

    function Cf(e, t) {
        e.seq.push(t), e.map[t.id] = t
    }

    function Rf(e, t, n) {
        const i = e.name, r = i.length;
        for (Lf.lastIndex = 0; ;) {
            const s = Lf.exec(i), a = Lf.lastIndex;
            let o = s[1];
            const l = "]" === s[2], c = s[3];
            if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) {
                Cf(n, void 0 === c ? new Ef(o, e, t) : new Mf(o, e, t));
                break
            }
            {
                let e = n.map[o];
                void 0 === e && (e = new Af(o), Cf(n, e)), n = e
            }
        }
    }

    function Pf(e, t) {
        this.seq = [], this.map = {};
        const n = e.getProgramParameter(t, 35718);
        for (let i = 0; i < n; ++i) {
            const n = e.getActiveUniform(t, i);
            Rf(n, e.getUniformLocation(t, n.name), this)
        }
    }

    function If(e, t, n) {
        const i = e.createShader(t);
        return e.shaderSource(i, n), e.compileShader(i), i
    }

    Pf.prototype.setValue = function (e, t, n, i) {
        const r = this.map[t];
        void 0 !== r && r.setValue(e, n, i)
    }, Pf.prototype.setOptional = function (e, t, n) {
        const i = t[n];
        void 0 !== i && this.setValue(e, n, i)
    }, Pf.upload = function (e, t, n, i) {
        for (let r = 0, s = t.length; r !== s; ++r) {
            const s = t[r], a = n[s.id];
            !1 !== a.needsUpdate && s.setValue(e, a.value, i)
        }
    }, Pf.seqWithValue = function (e, t) {
        const n = [];
        for (let i = 0, r = e.length; i !== r; ++i) {
            const r = e[i];
            r.id in t && n.push(r)
        }
        return n
    };
    let Of = 0;

    function Df(e) {
        switch (e) {
            case Ic:
                return ["Linear", "( value )"];
            case Oc:
                return ["sRGB", "( value )"];
            case Nc:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case Dc:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
                return ["LogLuv", "( value )"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
        }
    }

    function Nf(e, t, n) {
        const i = e.getShaderParameter(t, 35713), r = e.getShaderInfoLog(t).trim();
        return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function (e) {
            const t = e.split("\n");
            for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
            return t.join("\n")
        }(e.getShaderSource(t))
    }

    function Bf(e, t) {
        const n = Df(t);
        return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function kf(e, t) {
        const n = Df(t);
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }

    function Uf(e, t) {
        let n;
        switch (t) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "OptimizedCineon";
                break;
            case 4:
                n = "ACESFilmic";
                break;
            case 5:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function Ff(e) {
        return "" !== e
    }

    function Hf(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
    }

    function zf(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }

    const Gf = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Vf(e) {
        return e.replace(Gf, Wf)
    }

    function Wf(e, t) {
        const n = kd[t];
        if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
        return Vf(n)
    }

    const jf = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        $f = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function Xf(e) {
        return e.replace($f, Yf).replace(jf, qf)
    }

    function qf(e, t, n, i) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Yf(e, t, n, i)
    }

    function Yf(e, t, n, i) {
        let r = "";
        for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
        return r
    }

    function Kf(e) {
        let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
    }

    function Jf(e, t, n, i) {
        const r = e.getContext(), s = n.defines;
        let a = n.vertexShader, o = n.fragmentShader;
        const l = function (e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
        }(n), c = function (e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap) switch (e.envMapMode) {
                case Zl:
                case Ql:
                    t = "ENVMAP_TYPE_CUBE";
                    break;
                case ec:
                case 307:
                    t = "ENVMAP_TYPE_CUBE_UV"
            }
            return t
        }(n), h = function (e) {
            let t = "ENVMAP_MODE_REFLECTION";
            if (e.envMap) switch (e.envMapMode) {
                case Ql:
                case 307:
                    t = "ENVMAP_MODE_REFRACTION"
            }
            return t
        }(n), u = function (e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap) switch (e.combine) {
                case 0:
                    t = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    t = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    t = "ENVMAP_BLENDING_ADD"
            }
            return t
        }(n), d = e.gammaFactor > 0 ? e.gammaFactor : 1, p = n.isWebGL2 ? "" : function (e) {
            return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ff).join("\n")
        }(n), f = function (e) {
            const t = [];
            for (const n in e) {
                const i = e[n];
                !1 !== i && t.push("#define " + n + " " + i)
            }
            return t.join("\n")
        }(s), m = r.createProgram();
        let g, v, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial ? (g = [f].filter(Ff).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(Ff).join("\n"), v.length > 0 && (v += "\n")) : (g = [Kf(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ff).join("\n"), v = [p, Kf(n), "#define SHADER_NAME " + n.shaderName, f, "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? kd.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Uf("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === mc ? "#define OPAQUE" : "", kd.encodings_pars_fragment, n.map ? Bf("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Bf("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Bf("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Bf("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularTintMap ? Bf("specularTintMapTexelToLinear", n.specularTintMapEncoding) : "", n.lightMap ? Bf("lightMapTexelToLinear", n.lightMapEncoding) : "", kf("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ff).join("\n")), a = Vf(a), a = Hf(a, n), a = zf(a, n), o = Vf(o), o = Hf(o, n), o = zf(o, n), a = Xf(a), o = Xf(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === Fc ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Fc ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
        const y = _ + v + o, x = If(r, 35633, _ + g + a), b = If(r, 35632, y);
        if (r.attachShader(m, x), r.attachShader(m, b), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), e.debug.checkShaderErrors) {
            const e = r.getProgramInfoLog(m).trim(), t = r.getShaderInfoLog(x).trim(), n = r.getShaderInfoLog(b).trim();
            let i = !0, s = !0;
            if (!1 === r.getProgramParameter(m, 35714)) {
                i = !1;
                const t = Nf(r, x, "vertex"), n = Nf(r, b, "fragment");
                console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
            } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (s = !1);
            s && (this.diagnostics = {
                runnable: i,
                programLog: e,
                vertexShader: {log: t, prefix: g},
                fragmentShader: {log: n, prefix: v}
            })
        }
        let w, T;
        return r.deleteShader(x), r.deleteShader(b), this.getUniforms = function () {
            return void 0 === w && (w = new Pf(r, m)), w
        }, this.getAttributes = function () {
            return void 0 === T && (T = function (e, t) {
                const n = {}, i = e.getProgramParameter(t, 35721);
                for (let r = 0; r < i; r++) {
                    const i = e.getActiveAttrib(t, r), s = i.name;
                    let a = 1;
                    35674 === i.type && (a = 2), 35675 === i.type && (a = 3), 35676 === i.type && (a = 4), n[s] = {
                        type: i.type,
                        location: e.getAttribLocation(t, s),
                        locationSize: a
                    }
                }
                return n
            }(r, m)), T
        }, this.destroy = function () {
            i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
        }, this.name = n.shaderName, this.id = Of++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = x, this.fragmentShader = b, this
    }

    function Zf(e, t, n, i, r, s, a) {
        const o = [], l = r.isWebGL2, c = r.logarithmicDepthBuffer, h = r.floatVertexTextures, u = r.maxVertexUniforms,
            d = r.vertexTextures;
        let p = r.precision;
        const f = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheen", "transmission", "transmissionMap", "thicknessMap"];

        function g(e) {
            let t;
            return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = Ic, l && e && e.isTexture && e.format === gc && e.type === cc && e.encoding === Oc && (t = Ic), t
        }

        return {
            getParameters: function (s, o, m, v, _) {
                const y = v.fog, x = s.isMeshStandardMaterial ? v.environment : null,
                    b = (s.isMeshStandardMaterial ? n : t).get(s.envMap || x), w = f[s.type],
                    T = _.isSkinnedMesh ? function (e) {
                        const t = e.skeleton.bones;
                        if (h) return 1024;
                        {
                            const e = u, n = Math.floor((e - 20) / 4), i = Math.min(n, t.length);
                            return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i
                        }
                    }(_) : 0;
                let S, E;
                if (null !== s.precision && (p = r.getMaxPrecision(s.precision), p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead.")), w) {
                    const e = Fd[w];
                    S = e.vertexShader, E = e.fragmentShader
                } else S = s.vertexShader, E = s.fragmentShader;
                const M = e.getRenderTarget(), A = s.alphaTest > 0, L = s.clearcoat > 0;
                return {
                    isWebGL2: l,
                    shaderID: w,
                    shaderName: s.type,
                    vertexShader: S,
                    fragmentShader: E,
                    defines: s.defines,
                    isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                    glslVersion: s.glslVersion,
                    precision: p,
                    instancing: !0 === _.isInstancedMesh,
                    instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                    supportsVertexTextures: d,
                    outputEncoding: null !== M ? g(M.texture) : e.outputEncoding,
                    map: !!s.map,
                    mapEncoding: g(s.map),
                    matcap: !!s.matcap,
                    matcapEncoding: g(s.matcap),
                    envMap: !!b,
                    envMapMode: b && b.mapping,
                    envMapEncoding: g(b),
                    envMapCubeUV: !!b && (b.mapping === ec || 307 === b.mapping),
                    lightMap: !!s.lightMap,
                    lightMapEncoding: g(s.lightMap),
                    aoMap: !!s.aoMap,
                    emissiveMap: !!s.emissiveMap,
                    emissiveMapEncoding: g(s.emissiveMap),
                    bumpMap: !!s.bumpMap,
                    normalMap: !!s.normalMap,
                    objectSpaceNormalMap: 1 === s.normalMapType,
                    tangentSpaceNormalMap: 0 === s.normalMapType,
                    clearcoat: L,
                    clearcoatMap: L && !!s.clearcoatMap,
                    clearcoatRoughnessMap: L && !!s.clearcoatRoughnessMap,
                    clearcoatNormalMap: L && !!s.clearcoatNormalMap,
                    displacementMap: !!s.displacementMap,
                    roughnessMap: !!s.roughnessMap,
                    metalnessMap: !!s.metalnessMap,
                    specularMap: !!s.specularMap,
                    specularIntensityMap: !!s.specularIntensityMap,
                    specularTintMap: !!s.specularTintMap,
                    specularTintMapEncoding: g(s.specularTintMap),
                    alphaMap: !!s.alphaMap,
                    alphaTest: A,
                    gradientMap: !!s.gradientMap,
                    sheen: s.sheen > 0,
                    transmission: s.transmission > 0,
                    transmissionMap: !!s.transmissionMap,
                    thicknessMap: !!s.thicknessMap,
                    combine: s.combine,
                    vertexTangents: !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,
                    vertexColors: s.vertexColors,
                    vertexAlphas: !0 === s.vertexColors && !!_.geometry && !!_.geometry.attributes.color && 4 === _.geometry.attributes.color.itemSize,
                    vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularTintMap),
                    uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularTintMap || !s.displacementMap),
                    fog: !!y,
                    useFog: s.fog,
                    fogExp2: y && y.isFogExp2,
                    flatShading: !!s.flatShading,
                    sizeAttenuation: s.sizeAttenuation,
                    logarithmicDepthBuffer: c,
                    skinning: !0 === _.isSkinnedMesh && T > 0,
                    maxBones: T,
                    useVertexTexture: h,
                    morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,
                    morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
                    morphTargetsCount: _.geometry && _.geometry.morphAttributes.position ? _.geometry.morphAttributes.position.length : 0,
                    numDirLights: o.directional.length,
                    numPointLights: o.point.length,
                    numSpotLights: o.spot.length,
                    numRectAreaLights: o.rectArea.length,
                    numHemiLights: o.hemi.length,
                    numDirLightShadows: o.directionalShadowMap.length,
                    numPointLightShadows: o.pointShadowMap.length,
                    numSpotLightShadows: o.spotShadowMap.length,
                    numClippingPlanes: a.numPlanes,
                    numClipIntersection: a.numIntersection,
                    format: s.format,
                    dithering: s.dithering,
                    shadowMapEnabled: e.shadowMap.enabled && m.length > 0,
                    shadowMapType: e.shadowMap.type,
                    toneMapping: s.toneMapped ? e.toneMapping : 0,
                    physicallyCorrectLights: e.physicallyCorrectLights,
                    premultipliedAlpha: s.premultipliedAlpha,
                    doubleSided: 2 === s.side,
                    flipSided: 1 === s.side,
                    depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                    index0AttributeName: s.index0AttributeName,
                    extensionDerivatives: s.extensions && s.extensions.derivatives,
                    extensionFragDepth: s.extensions && s.extensions.fragDepth,
                    extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                    extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: l || i.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: s.customProgramCacheKey()
                }
            }, getProgramCacheKey: function (t) {
                const n = [];
                if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                if (!1 === t.isRawShaderMaterial) {
                    for (let e = 0; e < m.length; e++) n.push(t[m[e]]);
                    n.push(e.outputEncoding), n.push(e.gammaFactor)
                }
                return n.push(t.customProgramCacheKey), n.join()
            }, getUniforms: function (e) {
                const t = f[e.type];
                let n;
                if (t) {
                    const e = Fd[t];
                    n = yd.clone(e.uniforms)
                } else n = e.uniforms;
                return n
            }, acquireProgram: function (t, n) {
                let i;
                for (let e = 0, t = o.length; e < t; e++) {
                    const t = o[e];
                    if (t.cacheKey === n) {
                        i = t, ++i.usedTimes;
                        break
                    }
                }
                return void 0 === i && (i = new Jf(e, n, t, s), o.push(i)), i
            }, releaseProgram: function (e) {
                if (0 == --e.usedTimes) {
                    const t = o.indexOf(e);
                    o[t] = o[o.length - 1], o.pop(), e.destroy()
                }
            }, programs: o
        }
    }

    function Qf() {
        let e = new WeakMap;
        return {
            get: function (t) {
                let n = e.get(t);
                return void 0 === n && (n = {}, e.set(t, n)), n
            }, remove: function (t) {
                e.delete(t)
            }, update: function (t, n, i) {
                e.get(t)[n] = i
            }, dispose: function () {
                e = new WeakMap
            }
        }
    }

    function em(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function tm(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function nm(e) {
        const t = [];
        let n = 0;
        const i = [], r = [], s = [], a = {id: -1};

        function o(i, r, s, o, l, c) {
            let h = t[n];
            const u = e.get(s);
            return void 0 === h ? (h = {
                id: i.id,
                object: i,
                geometry: r,
                material: s,
                program: u.program || a,
                groupOrder: o,
                renderOrder: i.renderOrder,
                z: l,
                group: c
            }, t[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = s, h.program = u.program || a, h.groupOrder = o, h.renderOrder = i.renderOrder, h.z = l, h.group = c), n++, h
        }

        return {
            opaque: i, transmissive: r, transparent: s, init: function () {
                n = 0, i.length = 0, r.length = 0, s.length = 0
            }, push: function (e, t, n, a, l, c) {
                const h = o(e, t, n, a, l, c);
                n.transmission > 0 ? r.push(h) : !0 === n.transparent ? s.push(h) : i.push(h)
            }, unshift: function (e, t, n, a, l, c) {
                const h = o(e, t, n, a, l, c);
                n.transmission > 0 ? r.unshift(h) : !0 === n.transparent ? s.unshift(h) : i.unshift(h)
            }, finish: function () {
                for (let e = n, i = t.length; e < i; e++) {
                    const n = t[e];
                    if (null === n.id) break;
                    n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                }
            }, sort: function (e, t) {
                i.length > 1 && i.sort(e || em), r.length > 1 && r.sort(t || tm), s.length > 1 && s.sort(t || tm)
            }
        }
    }

    function im(e) {
        let t = new WeakMap;
        return {
            get: function (n, i) {
                let r;
                return !1 === t.has(n) ? (r = new nm(e), t.set(n, [r])) : i >= t.get(n).length ? (r = new nm(e), t.get(n).push(r)) : r = t.get(n)[i], r
            }, dispose: function () {
                t = new WeakMap
            }
        }
    }

    function rm() {
        const e = {};
        return {
            get: function (t) {
                if (void 0 !== e[t.id]) return e[t.id];
                let n;
                switch (t.type) {
                    case"DirectionalLight":
                        n = {direction: new ph, color: new Nu};
                        break;
                    case"SpotLight":
                        n = {
                            position: new ph,
                            direction: new ph,
                            color: new Nu,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case"PointLight":
                        n = {position: new ph, color: new Nu, distance: 0, decay: 0};
                        break;
                    case"HemisphereLight":
                        n = {direction: new ph, skyColor: new Nu, groundColor: new Nu};
                        break;
                    case"RectAreaLight":
                        n = {color: new Nu, position: new ph, halfWidth: new ph, halfHeight: new ph}
                }
                return e[t.id] = n, n
            }
        }
    }

    let sm = 0;

    function am(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
    }

    function om(e, t) {
        const n = new rm, i = function () {
            const e = {};
            return {
                get: function (t) {
                    if (void 0 !== e[t.id]) return e[t.id];
                    let n;
                    switch (t.type) {
                        case"DirectionalLight":
                        case"SpotLight":
                            n = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new eh};
                            break;
                        case"PointLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new eh,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                    }
                    return e[t.id] = n, n
                }
            }
        }(), r = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
        for (let e = 0; e < 9; e++) r.probe.push(new ph);
        const s = new ph, a = new Wh, o = new Wh;
        return {
            setup: function (s, a) {
                let o = 0, l = 0, c = 0;
                for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
                let h = 0, u = 0, d = 0, p = 0, f = 0, m = 0, g = 0, v = 0;
                s.sort(am);
                const _ = !0 !== a ? Math.PI : 1;
                for (let e = 0, t = s.length; e < t; e++) {
                    const t = s[e], a = t.color, y = t.intensity, x = t.distance,
                        b = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                    if (t.isAmbientLight) o += a.r * y * _, l += a.g * y * _, c += a.b * y * _; else if (t.isLightProbe) for (let e = 0; e < 9; e++) r.probe[e].addScaledVector(t.sh.coefficients[e], y); else if (t.isDirectionalLight) {
                        const e = n.get(t);
                        if (e.color.copy(t.color).multiplyScalar(t.intensity * _), t.castShadow) {
                            const e = t.shadow, n = i.get(t);
                            n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[h] = n, r.directionalShadowMap[h] = b, r.directionalShadowMatrix[h] = t.shadow.matrix, m++
                        }
                        r.directional[h] = e, h++
                    } else if (t.isSpotLight) {
                        const e = n.get(t);
                        if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(y * _), e.distance = x, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
                            const e = t.shadow, n = i.get(t);
                            n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = b, r.spotShadowMatrix[d] = t.shadow.matrix, v++
                        }
                        r.spot[d] = e, d++
                    } else if (t.isRectAreaLight) {
                        const e = n.get(t);
                        e.color.copy(a).multiplyScalar(y), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[p] = e, p++
                    } else if (t.isPointLight) {
                        const e = n.get(t);
                        if (e.color.copy(t.color).multiplyScalar(t.intensity * _), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                            const e = t.shadow, n = i.get(t);
                            n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = b, r.pointShadowMatrix[u] = t.shadow.matrix, g++
                        }
                        r.point[u] = e, u++
                    } else if (t.isHemisphereLight) {
                        const e = n.get(t);
                        e.skyColor.copy(t.color).multiplyScalar(y * _), e.groundColor.copy(t.groundColor).multiplyScalar(y * _), r.hemi[f] = e, f++
                    }
                }
                p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Ud.LTC_FLOAT_1, r.rectAreaLTC2 = Ud.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Ud.LTC_HALF_1, r.rectAreaLTC2 = Ud.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                const y = r.hash;
                y.directionalLength === h && y.pointLength === u && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === f && y.numDirectionalShadows === m && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = u, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = f, y.numDirectionalShadows = m, y.numPointShadows = g, y.numSpotShadows = v, r.version = sm++)
            }, setupView: function (e, t) {
                let n = 0, i = 0, l = 0, c = 0, h = 0;
                const u = t.matrixWorldInverse;
                for (let t = 0, d = e.length; t < d; t++) {
                    const d = e[t];
                    if (d.isDirectionalLight) {
                        const e = r.directional[n];
                        e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), n++
                    } else if (d.isSpotLight) {
                        const e = r.spot[l];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), l++
                    } else if (d.isRectAreaLight) {
                        const e = r.rectArea[c];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), o.identity(), a.copy(d.matrixWorld), a.premultiply(u), o.extractRotation(a), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++
                    } else if (d.isPointLight) {
                        const e = r.point[i];
                        e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), i++
                    } else if (d.isHemisphereLight) {
                        const e = r.hemi[h];
                        e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), e.direction.normalize(), h++
                    }
                }
            }, state: r
        }
    }

    function lm(e, t) {
        const n = new om(e, t), i = [], r = [];
        return {
            init: function () {
                i.length = 0, r.length = 0
            }, state: {lightsArray: i, shadowsArray: r, lights: n}, setupLights: function (e) {
                n.setup(i, e)
            }, setupLightsView: function (e) {
                n.setupView(i, e)
            }, pushLight: function (e) {
                i.push(e)
            }, pushShadow: function (e) {
                r.push(e)
            }
        }
    }

    function cm(e, t) {
        let n = new WeakMap;
        return {
            get: function (i, r = 0) {
                let s;
                return !1 === n.has(i) ? (s = new lm(e, t), n.set(i, [s])) : r >= n.get(i).length ? (s = new lm(e, t), n.get(i).push(s)) : s = n.get(i)[r], s
            }, dispose: function () {
                n = new WeakMap
            }
        }
    }

    class hm extends Lu {
        constructor(e) {
            super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
        }
    }

    hm.prototype.isMeshDepthMaterial = !0;

    class um extends Lu {
        constructor(e) {
            super(), this.type = "MeshDistanceMaterial", this.referencePosition = new ph, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
        }
    }

    um.prototype.isMeshDistanceMaterial = !0;

    function dm(e, t, n) {
        let i = new Od;
        const r = new eh, s = new eh, a = new ch, o = new hm({depthPacking: 3201}), l = new um, c = {},
            h = n.maxTextureSize, u = {0: 1, 1: 0, 2: 2}, d = new xd({
                uniforms: {
                    shadow_pass: {value: null},
                    resolution: {value: new eh},
                    radius: {value: 4},
                    samples: {value: 8}
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            }), p = d.clone();
        p.defines.HORIZONTAL_PASS = 1;
        const f = new Ku;
        f.setAttribute("position", new Fu(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        const m = new fd(f, d), g = this;

        function v(n, i) {
            const r = t.update(m);
            d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, d.uniforms.samples.value = n.blurSamples, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, p.uniforms.samples.value = n.blurSamples, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, p, m, null)
        }

        function _(t, n, i, r, s, a, h) {
            let d = null;
            const p = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
            if (d = void 0 !== p ? p : !0 === r.isPointLight ? l : o, e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                const e = d.uuid, t = i.uuid;
                let n = c[e];
                void 0 === n && (n = {}, c[e] = n);
                let r = n[t];
                void 0 === r && (r = d.clone(), n[t] = r), d = r
            }
            return d.visible = i.visible, d.wireframe = i.wireframe, d.side = 3 === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], d.alphaMap = i.alphaMap, d.alphaTest = i.alphaTest, d.clipShadows = i.clipShadows, d.clippingPlanes = i.clippingPlanes, d.clipIntersection = i.clipIntersection, d.displacementMap = i.displacementMap, d.displacementScale = i.displacementScale, d.displacementBias = i.displacementBias, d.wireframeLinewidth = i.wireframeLinewidth, d.linewidth = i.linewidth, !0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld), d.nearDistance = s, d.farDistance = a), d
        }

        function y(n, r, s, a, o) {
            if (!1 === n.visible) return;
            if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                const i = t.update(n), r = n.material;
                if (Array.isArray(r)) {
                    const t = i.groups;
                    for (let l = 0, c = t.length; l < c; l++) {
                        const c = t[l], h = r[c.materialIndex];
                        if (h && h.visible) {
                            const t = _(n, 0, h, a, s.near, s.far, o);
                            e.renderBufferDirect(s, null, i, t, n, c)
                        }
                    }
                } else if (r.visible) {
                    const t = _(n, 0, r, a, s.near, s.far, o);
                    e.renderBufferDirect(s, null, i, t, n, null)
                }
            }
            const l = n.children;
            for (let e = 0, t = l.length; e < t; e++) y(l[e], r, s, a, o)
        }

        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (t, n, o) {
            if (!1 === g.enabled) return;
            if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
            if (0 === t.length) return;
            const l = e.getRenderTarget(), c = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), d = e.state;
            d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
            for (let l = 0, c = t.length; l < c; l++) {
                const c = t[l], u = c.shadow;
                if (void 0 === u) {
                    console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                    continue
                }
                if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                r.copy(u.mapSize);
                const p = u.getFrameExtents();
                if (r.multiply(p), s.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x), r.x = s.x * p.x, u.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / p.y), r.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && 3 === this.type) {
                    const e = {minFilter: oc, magFilter: oc, format: gc};
                    u.map = new hh(r.x, r.y, e), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new hh(r.x, r.y, e), u.camera.updateProjectionMatrix()
                }
                if (null === u.map) {
                    const e = {minFilter: rc, magFilter: rc, format: gc};
                    u.map = new hh(r.x, r.y, e), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
                }
                e.setRenderTarget(u.map), e.clear();
                const f = u.getViewportCount();
                for (let e = 0; e < f; e++) {
                    const t = u.getViewport(e);
                    a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), d.viewport(a), u.updateMatrices(c, e), i = u.getFrustum(), y(n, o, u.camera, c, this.type)
                }
                u.isPointLightShadow || 3 !== this.type || v(u, o), u.needsUpdate = !1
            }
            g.needsUpdate = !1, e.setRenderTarget(l, c, u)
        }
    }

    function pm(e, t, n) {
        const i = n.isWebGL2;
        const r = new function () {
            let t = !1;
            const n = new ch;
            let i = null;
            const r = new ch(0, 0, 0, 0);
            return {
                setMask: function (n) {
                    i === n || t || (e.colorMask(n, n, n, n), i = n)
                }, setLocked: function (e) {
                    t = e
                }, setClear: function (t, i, s, a, o) {
                    !0 === o && (t *= a, i *= a, s *= a), n.set(t, i, s, a), !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n))
                }, reset: function () {
                    t = !1, i = null, r.set(-1, 0, 0, 0)
                }
            }
        }, s = new function () {
            let t = !1, n = null, i = null, r = null;
            return {
                setTest: function (e) {
                    e ? k(2929) : U(2929)
                }, setMask: function (i) {
                    n === i || t || (e.depthMask(i), n = i)
                }, setFunc: function (t) {
                    if (i !== t) {
                        if (t) switch (t) {
                            case 0:
                                e.depthFunc(512);
                                break;
                            case 1:
                                e.depthFunc(519);
                                break;
                            case 2:
                                e.depthFunc(513);
                                break;
                            default:
                                e.depthFunc(515);
                                break;
                            case 4:
                                e.depthFunc(514);
                                break;
                            case 5:
                                e.depthFunc(518);
                                break;
                            case 6:
                                e.depthFunc(516);
                                break;
                            case 7:
                                e.depthFunc(517)
                        } else e.depthFunc(515);
                        i = t
                    }
                }, setLocked: function (e) {
                    t = e
                }, setClear: function (t) {
                    r !== t && (e.clearDepth(t), r = t)
                }, reset: function () {
                    t = !1, n = null, i = null, r = null
                }
            }
        }, a = new function () {
            let t = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null;
            return {
                setTest: function (e) {
                    t || (e ? k(2960) : U(2960))
                }, setMask: function (i) {
                    n === i || t || (e.stencilMask(i), n = i)
                }, setFunc: function (t, n, a) {
                    i === t && r === n && s === a || (e.stencilFunc(t, n, a), i = t, r = n, s = a)
                }, setOp: function (t, n, i) {
                    a === t && o === n && l === i || (e.stencilOp(t, n, i), a = t, o = n, l = i)
                }, setLocked: function (e) {
                    t = e
                }, setClear: function (t) {
                    c !== t && (e.clearStencil(t), c = t)
                }, reset: function () {
                    t = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null
                }
            }
        };
        let o = {}, l = null, c = {}, h = null, u = !1, d = null, p = null, f = null, m = null, g = null, v = null,
            _ = null, y = !1, x = null, b = null, w = null, T = null, S = null;
        const E = e.getParameter(35661);
        let M = !1, A = 0;
        const L = e.getParameter(7938);
        -1 !== L.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(L)[1]), M = A >= 1) : -1 !== L.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), M = A >= 2);
        let C = null, R = {};
        const P = e.getParameter(3088), I = e.getParameter(2978), O = (new ch).fromArray(P), D = (new ch).fromArray(I);

        function N(t, n, i) {
            const r = new Uint8Array(4), s = e.createTexture();
            e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
            for (let t = 0; t < i; t++) e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return s
        }

        const B = {};

        function k(t) {
            !0 !== o[t] && (e.enable(t), o[t] = !0)
        }

        function U(t) {
            !1 !== o[t] && (e.disable(t), o[t] = !1)
        }

        B[3553] = N(3553, 3553, 1), B[34067] = N(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), k(2929), s.setFunc(3), G(!1), V(1), k(2884), z(0);
        const F = {[Jl]: 32774, 101: 32778, 102: 32779};
        if (i) F[103] = 32775, F[104] = 32776; else {
            const e = t.get("EXT_blend_minmax");
            null !== e && (F[103] = e.MIN_EXT, F[104] = e.MAX_EXT)
        }
        const H = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
        };

        function z(t, n, i, r, s, a, o, l) {
            if (0 !== t) {
                if (!1 === u && (k(3042), u = !0), 5 === t) s = s || n, a = a || i, o = o || r, n === p && s === g || (e.blendEquationSeparate(F[n], F[s]), p = n, g = s), i === f && r === m && a === v && o === _ || (e.blendFuncSeparate(H[i], H[r], H[a], H[o]), f = i, m = r, v = a, _ = o), d = t, y = null; else if (t !== d || l !== y) {
                    if (p === Jl && g === Jl || (e.blendEquation(32774), p = Jl, g = Jl), l) switch (t) {
                        case 1:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(1, 1);
                            break;
                        case 3:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            e.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    } else switch (t) {
                        case 1:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(770, 1);
                            break;
                        case 3:
                            e.blendFunc(0, 769);
                            break;
                        case 4:
                            e.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                    f = null, m = null, v = null, _ = null, d = t, y = l
                }
            } else !0 === u && (U(3042), u = !1)
        }

        function G(t) {
            x !== t && (t ? e.frontFace(2304) : e.frontFace(2305), x = t)
        }

        function V(t) {
            0 !== t ? (k(2884), t !== b && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : U(2884), b = t
        }

        function W(t, n, i) {
            t ? (k(32823), T === n && S === i || (e.polygonOffset(n, i), T = n, S = i)) : U(32823)
        }

        function j(t) {
            void 0 === t && (t = 33984 + E - 1), C !== t && (e.activeTexture(t), C = t)
        }

        return {
            buffers: {color: r, depth: s, stencil: a}, enable: k, disable: U, bindFramebuffer: function (t, n) {
                return null === n && null !== l && (n = l), c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, i && (36009 === t && (c[36160] = n), 36160 === t && (c[36009] = n)), !0)
            }, bindXRFramebuffer: function (t) {
                t !== l && (e.bindFramebuffer(36160, t), l = t)
            }, useProgram: function (t) {
                return h !== t && (e.useProgram(t), h = t, !0)
            }, setBlending: z, setMaterial: function (e, t) {
                2 === e.side ? U(2884) : k(2884);
                let n = 1 === e.side;
                t && (n = !n), G(n), 1 === e.blending && !1 === e.transparent ? z(0) : z(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), r.setMask(e.colorWrite);
                const i = e.stencilWrite;
                a.setTest(i), i && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), W(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? k(32926) : U(32926)
            }, setFlipSided: G, setCullFace: V, setLineWidth: function (t) {
                t !== w && (M && e.lineWidth(t), w = t)
            }, setPolygonOffset: W, setScissorTest: function (e) {
                e ? k(3089) : U(3089)
            }, activeTexture: j, bindTexture: function (t, n) {
                null === C && j();
                let i = R[C];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                }, R[C] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || B[t]), i.type = t, i.texture = n)
            }, unbindTexture: function () {
                const t = R[C];
                void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
            }, compressedTexImage2D: function () {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }, texImage2D: function () {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }, texImage3D: function () {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }, scissor: function (t) {
                !1 === O.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), O.copy(t))
            }, viewport: function (t) {
                !1 === D.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), D.copy(t))
            }, reset: function () {
                e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === i && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), o = {}, C = null, R = {}, l = null, c = {}, h = null, u = !1, d = null, p = null, f = null, m = null, g = null, v = null, _ = null, y = !1, x = null, b = null, w = null, T = null, S = null, O.set(0, 0, e.canvas.width, e.canvas.height), D.set(0, 0, e.canvas.width, e.canvas.height), r.reset(), s.reset(), a.reset()
            }
        }
    }

    function fm(e, t, n, i, r, s, a) {
        const o = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, h = r.maxTextureSize, u = r.maxSamples,
            d = new WeakMap;
        let p, f = !1;
        try {
            f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (e) {
        }

        function m(e, t) {
            return f ? new OffscreenCanvas(e, t) : ih("canvas")
        }

        function g(e, t, n, i) {
            let r = 1;
            if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const i = t ? Zc : Math.floor, s = i(r * e.width), a = i(r * e.height);
                    void 0 === p && (p = m(s, a));
                    const o = n ? m(s, a) : p;
                    o.width = s, o.height = a;
                    return o.getContext("2d").drawImage(e, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + a + ")."), o
                }
                return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
            }
            return e
        }

        function v(e) {
            return Kc(e.width) && Kc(e.height)
        }

        function _(e, t) {
            return e.generateMipmaps && t && e.minFilter !== rc && e.minFilter !== oc
        }

        function y(t, n, r, s, a = 1) {
            e.generateMipmap(t);
            i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, a))
        }

        function x(n, i, r, s) {
            if (!1 === o) return i;
            if (null !== n) {
                if (void 0 !== e[n]) return e[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            let a = i;
            return 6403 === i && (5126 === r && (a = 33326), 5131 === r && (a = 33325), 5121 === r && (a = 33321)), 6407 === i && (5126 === r && (a = 34837), 5131 === r && (a = 34843), 5121 === r && (a = 32849)), 6408 === i && (5126 === r && (a = 34836), 5131 === r && (a = 34842), 5121 === r && (a = s === Oc ? 35907 : 32856)), 33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"), a
        }

        function b(e) {
            return e === rc || e === sc || e === ac ? 9728 : 9729
        }

        function w(t) {
            const n = t.target;
            n.removeEventListener("dispose", w), function (t) {
                const n = i.get(t);
                if (void 0 === n.__webglInit) return;
                e.deleteTexture(n.__webglTexture), i.remove(t)
            }(n), n.isVideoTexture && d.delete(n), a.memory.textures--
        }

        function T(t) {
            const n = t.target;
            n.removeEventListener("dispose", T), function (t) {
                const n = t.texture, r = i.get(t), s = i.get(n);
                if (!t) return;
                void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), a.memory.textures--);
                t.depthTexture && t.depthTexture.dispose();
                if (t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++) e.deleteFramebuffer(r.__webglFramebuffer[t]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]); else e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && e.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                if (t.isWebGLMultipleRenderTargets) for (let t = 0, r = n.length; t < r; t++) {
                    const r = i.get(n[t]);
                    r.__webglTexture && (e.deleteTexture(r.__webglTexture), a.memory.textures--), i.remove(n[t])
                }
                i.remove(n), i.remove(t)
            }(n)
        }

        let S = 0;

        function E(e, t) {
            const r = i.get(e);
            if (e.isVideoTexture && function (e) {
                const t = a.render.frame;
                d.get(e) !== t && (d.set(e, t), e.update())
            }(e), e.version > 0 && r.__version !== e.version) {
                const n = e.image;
                if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
                    if (!1 !== n.complete) return void P(r, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture)
        }

        function M(t, r) {
            const a = i.get(t);
            t.version > 0 && a.__version !== t.version ? function (t, i, r) {
                if (6 !== i.image.length) return;
                R(t, i), n.activeTexture(33984 + r), n.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
                const a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                    l = i.image[0] && i.image[0].isDataTexture, h = [];
                for (let e = 0; e < 6; e++) h[e] = a || l ? l ? i.image[e].image : i.image[e] : g(i.image[e], !1, !0, c);
                const u = h[0], d = v(u) || o, p = s.convert(i.format), f = s.convert(i.type),
                    m = x(i.internalFormat, p, f, i.encoding);
                let b;
                if (C(34067, i, d), a) {
                    for (let e = 0; e < 6; e++) {
                        b = h[e].mipmaps;
                        for (let t = 0; t < b.length; t++) {
                            const r = b[t];
                            i.format !== gc && i.format !== mc ? null !== p ? n.compressedTexImage2D(34069 + e, t, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + e, t, m, r.width, r.height, 0, p, f, r.data)
                        }
                    }
                    t.__maxMipLevel = b.length - 1
                } else {
                    b = i.mipmaps;
                    for (let e = 0; e < 6; e++) if (l) {
                        n.texImage2D(34069 + e, 0, m, h[e].width, h[e].height, 0, p, f, h[e].data);
                        for (let t = 0; t < b.length; t++) {
                            const i = b[t].image[e].image;
                            n.texImage2D(34069 + e, t + 1, m, i.width, i.height, 0, p, f, i.data)
                        }
                    } else {
                        n.texImage2D(34069 + e, 0, m, p, f, h[e]);
                        for (let t = 0; t < b.length; t++) {
                            const i = b[t];
                            n.texImage2D(34069 + e, t + 1, m, p, f, i.image[e])
                        }
                    }
                    t.__maxMipLevel = b.length
                }
                _(i, d) && y(34067, i, u.width, u.height);
                t.__version = i.version, i.onUpdate && i.onUpdate(i)
            }(a, t, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture))
        }

        const A = {[tc]: 10497, [nc]: 33071, [ic]: 33648},
            L = {[rc]: 9728, [sc]: 9984, [ac]: 9986, [oc]: 9729, 1007: 9985, [lc]: 9987};

        function C(n, s, a) {
            if (a ? (e.texParameteri(n, 10242, A[s.wrapS]), e.texParameteri(n, 10243, A[s.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, A[s.wrapR]), e.texParameteri(n, 10240, L[s.magFilter]), e.texParameteri(n, 10241, L[s.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), s.wrapS === nc && s.wrapT === nc || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, b(s.magFilter)), e.texParameteri(n, 10241, b(s.minFilter)), s.minFilter !== rc && s.minFilter !== oc && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                const a = t.get("EXT_texture_filter_anisotropic");
                if (s.type === dc && !1 === t.has("OES_texture_float_linear")) return;
                if (!1 === o && s.type === pc && !1 === t.has("OES_texture_half_float_linear")) return;
                (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
            }
        }

        function R(t, n) {
            void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", w), t.__webglTexture = e.createTexture(), a.memory.textures++)
        }

        function P(t, i, r) {
            let a = 3553;
            i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), R(t, i), n.activeTexture(33984 + r), n.bindTexture(a, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
            const l = function (e) {
                return !o && (e.wrapS !== nc || e.wrapT !== nc || e.minFilter !== rc && e.minFilter !== oc)
            }(i) && !1 === v(i.image), c = g(i.image, l, !1, h), u = v(c) || o, d = s.convert(i.format);
            let p, f = s.convert(i.type), m = x(i.internalFormat, d, f, i.encoding);
            C(a, i, u);
            const b = i.mipmaps;
            if (i.isDepthTexture) m = 6402, o ? m = i.type === dc ? 36012 : i.type === uc ? 33190 : i.type === fc ? 35056 : 33189 : i.type === dc && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === vc && 6402 === m && i.type !== hc && i.type !== uc && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = hc, f = s.convert(i.type)), i.format === _c && 6402 === m && (m = 34041, i.type !== fc && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = fc, f = s.convert(i.type))), n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null); else if (i.isDataTexture) if (b.length > 0 && u) {
                for (let e = 0, t = b.length; e < t; e++) p = b[e], n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
                i.generateMipmaps = !1, t.__maxMipLevel = b.length - 1
            } else n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data), t.__maxMipLevel = 0; else if (i.isCompressedTexture) {
                for (let e = 0, t = b.length; e < t; e++) p = b[e], i.format !== gc && i.format !== mc ? null !== d ? n.compressedTexImage2D(3553, e, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
                t.__maxMipLevel = b.length - 1
            } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), t.__maxMipLevel = 0; else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), t.__maxMipLevel = 0; else if (b.length > 0 && u) {
                for (let e = 0, t = b.length; e < t; e++) p = b[e], n.texImage2D(3553, e, m, d, f, p);
                i.generateMipmaps = !1, t.__maxMipLevel = b.length - 1
            } else n.texImage2D(3553, 0, m, d, f, c), t.__maxMipLevel = 0;
            _(i, u) && y(a, i, c.width, c.height), t.__version = i.version, i.onUpdate && i.onUpdate(i)
        }

        function I(t, r, a, o, l) {
            const c = s.convert(a.format), h = s.convert(a.type), u = x(a.internalFormat, c, h, a.encoding);
            32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null), n.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null)
        }

        function O(t, n, i) {
            if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                let r = 33189;
                if (i) {
                    const t = n.depthTexture;
                    t && t.isDepthTexture && (t.type === dc ? r = 36012 : t.type === uc && (r = 33190));
                    const i = N(n);
                    e.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                } else e.renderbufferStorage(36161, r, n.width, n.height);
                e.framebufferRenderbuffer(36160, 36096, 36161, t)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (i) {
                    const t = N(n);
                    e.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height)
                } else e.renderbufferStorage(36161, 34041, n.width, n.height);
                e.framebufferRenderbuffer(36160, 33306, 36161, t)
            } else {
                const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture, r = s.convert(t.format),
                    a = s.convert(t.type), o = x(t.internalFormat, r, a, t.encoding);
                if (i) {
                    const t = N(n);
                    e.renderbufferStorageMultisample(36161, t, o, n.width, n.height)
                } else e.renderbufferStorage(36161, o, n.width, n.height)
            }
            e.bindRenderbuffer(36161, null)
        }

        function D(t) {
            const r = i.get(t), s = !0 === t.isWebGLCubeRenderTarget;
            if (t.depthTexture) {
                if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                !function (t, r) {
                    if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (n.bindFramebuffer(36160, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), E(r.depthTexture, 0);
                    const s = i.get(r.depthTexture).__webglTexture;
                    if (r.depthTexture.format === vc) e.framebufferTexture2D(36160, 36096, 3553, s, 0); else {
                        if (r.depthTexture.format !== _c) throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, s, 0)
                    }
                }(r.__webglFramebuffer, t)
            } else if (s) {
                r.__webglDepthbuffer = [];
                for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), O(r.__webglDepthbuffer[i], t, !1)
            } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), O(r.__webglDepthbuffer, t, !1);
            n.bindFramebuffer(36160, null)
        }

        function N(e) {
            return o && e.isWebGLMultisampleRenderTarget ? Math.min(u, e.samples) : 0
        }

        let B = !1, k = !1;
        this.allocateTextureUnit = function () {
            const e = S;
            return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), S += 1, e
        }, this.resetTextureUnits = function () {
            S = 0
        }, this.setTexture2D = E, this.setTexture2DArray = function (e, t) {
            const r = i.get(e);
            e.version > 0 && r.__version !== e.version ? P(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture))
        }, this.setTexture3D = function (e, t) {
            const r = i.get(e);
            e.version > 0 && r.__version !== e.version ? P(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture))
        }, this.setTextureCube = M, this.setupRenderTarget = function (t) {
            const l = t.texture, c = i.get(t), h = i.get(l);
            t.addEventListener("dispose", T), !0 !== t.isWebGLMultipleRenderTargets && (h.__webglTexture = e.createTexture(), h.__version = l.version, a.memory.textures++);
            const u = !0 === t.isWebGLCubeRenderTarget, d = !0 === t.isWebGLMultipleRenderTargets,
                p = !0 === t.isWebGLMultisampleRenderTarget, f = l.isDataTexture3D || l.isDataTexture2DArray,
                m = v(t) || o;
            if (!o || l.format !== mc || l.type !== dc && l.type !== pc || (l.format = gc, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) {
                c.__webglFramebuffer = [];
                for (let t = 0; t < 6; t++) c.__webglFramebuffer[t] = e.createFramebuffer()
            } else if (c.__webglFramebuffer = e.createFramebuffer(), d) if (r.drawBuffers) {
                const n = t.texture;
                for (let t = 0, r = n.length; t < r; t++) {
                    const r = i.get(n[t]);
                    void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(), a.memory.textures++)
                }
            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (p) if (o) {
                c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                const i = s.convert(l.format), r = s.convert(l.type), a = x(l.internalFormat, i, r, l.encoding),
                    o = N(t);
                e.renderbufferStorageMultisample(36161, o, a, t.width, t.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), O(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null)
            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (u) {
                n.bindTexture(34067, h.__webglTexture), C(34067, l, m);
                for (let e = 0; e < 6; e++) I(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
                _(l, m) && y(34067, l, t.width, t.height), n.unbindTexture()
            } else if (d) {
                const e = t.texture;
                for (let r = 0, s = e.length; r < s; r++) {
                    const s = e[r], a = i.get(s);
                    n.bindTexture(3553, a.__webglTexture), C(3553, s, m), I(c.__webglFramebuffer, t, s, 36064 + r, 3553), _(s, m) && y(3553, s, t.width, t.height)
                }
                n.unbindTexture()
            } else {
                let e = 3553;
                if (f) if (o) {
                    e = l.isDataTexture3D ? 32879 : 35866
                } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                n.bindTexture(e, h.__webglTexture), C(e, l, m), I(c.__webglFramebuffer, t, l, 36064, e), _(l, m) && y(e, l, t.width, t.height, t.depth), n.unbindTexture()
            }
            t.depthBuffer && D(t)
        }, this.updateRenderTargetMipmap = function (e) {
            const t = v(e) || o, r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
            for (let s = 0, a = r.length; s < a; s++) {
                const a = r[s];
                if (_(a, t)) {
                    const t = e.isWebGLCubeRenderTarget ? 34067 : 3553, r = i.get(a).__webglTexture;
                    n.bindTexture(t, r), y(t, a, e.width, e.height), n.unbindTexture()
                }
            }
        }, this.updateMultisampleRenderTarget = function (t) {
            if (t.isWebGLMultisampleRenderTarget) if (o) {
                const r = t.width, s = t.height;
                let a = 16384;
                t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024);
                const o = i.get(t);
                n.bindFramebuffer(36008, o.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, o.__webglFramebuffer), e.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, o.__webglMultisampledFramebuffer)
            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function (e, t) {
            e && e.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), e = e.texture), E(e, t)
        }, this.safeSetTextureCube = function (e, t) {
            e && e.isWebGLCubeRenderTarget && (!1 === k && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), k = !0), e = e.texture), M(e, t)
        }
    }

    function mm(e, t, n) {
        const i = n.isWebGL2;
        return {
            convert: function (e) {
                let n;
                if (e === cc) return 5121;
                if (1017 === e) return 32819;
                if (1018 === e) return 32820;
                if (1019 === e) return 33635;
                if (1010 === e) return 5120;
                if (1011 === e) return 5122;
                if (e === hc) return 5123;
                if (1013 === e) return 5124;
                if (e === uc) return 5125;
                if (e === dc) return 5126;
                if (e === pc) return i ? 5131 : (n = t.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                if (1021 === e) return 6406;
                if (e === mc) return 6407;
                if (e === gc) return 6408;
                if (1024 === e) return 6409;
                if (1025 === e) return 6410;
                if (e === vc) return 6402;
                if (e === _c) return 34041;
                if (1028 === e) return 6403;
                if (1029 === e) return 36244;
                if (1030 === e) return 33319;
                if (1031 === e) return 33320;
                if (1032 === e) return 36248;
                if (1033 === e) return 36249;
                if (e === yc || 33777 === e || 33778 === e || e === xc) {
                    if (n = t.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                    if (e === yc) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === xc) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (e === bc || 35841 === e || e === wc || 35843 === e) {
                    if (n = t.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                    if (e === bc) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === wc) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === e) return n = t.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((e === Tc || e === Sc) && (n = t.get("WEBGL_compressed_texture_etc"), null !== n)) {
                    if (e === Tc) return n.COMPRESSED_RGB8_ETC2;
                    if (e === Sc) return n.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? (n = t.get("WEBGL_compressed_texture_astc"), null !== n ? e : null) : 36492 === e ? (n = t.get("EXT_texture_compression_bptc"), null !== n ? e : null) : e === fc ? i ? 34042 : (n = t.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
        }
    }

    class gm extends wd {
        constructor(e = []) {
            super(), this.cameras = e
        }
    }

    gm.prototype.isArrayCamera = !0;

    class vm extends mu {
        constructor() {
            super(), this.type = "Group"
        }
    }

    vm.prototype.isGroup = !0;
    const _m = {type: "move"};

    class ym {
        constructor() {
            this._targetRay = null, this._grip = null, this._hand = null
        }

        getHandSpace() {
            return null === this._hand && (this._hand = new vm, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {pinching: !1}), this._hand
        }

        getTargetRaySpace() {
            return null === this._targetRay && (this._targetRay = new vm, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ph, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ph), this._targetRay
        }

        getGripSpace() {
            return null === this._grip && (this._grip = new vm, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ph, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ph), this._grip
        }

        dispatchEvent(e) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
        }

        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
        }

        update(e, t, n) {
            let i = null, r = null, s = null;
            const a = this._targetRay, o = this._grip, l = this._hand;
            if (e && "visible-blurred" !== t.session.visibilityState) if (null !== a && (i = t.getPose(e.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(_m))), l && e.hand) {
                s = !0;
                for (const i of e.hand.values()) {
                    const e = t.getJointPose(i, n);
                    if (void 0 === l.joints[i.jointName]) {
                        const e = new vm;
                        e.matrixAutoUpdate = !1, e.visible = !1, l.joints[i.jointName] = e, l.add(e)
                    }
                    const r = l.joints[i.jointName];
                    null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = e.radius), r.visible = null !== e
                }
                const i = l.joints["index-finger-tip"], r = l.joints["thumb-tip"],
                    a = i.position.distanceTo(r.position), o = .02, c = .005;
                l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
            return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
        }
    }

    class xm extends Hc {
        constructor(e, t) {
            super();
            const n = this, i = e.state;
            let r = null, s = 1, a = null, o = "local-floor", l = null, c = null, h = null, u = null, d = null, p = !1,
                f = null, m = null, g = null, v = null, _ = null, y = null;
            const x = [], b = new Map, w = new wd;
            w.layers.enable(1), w.viewport = new ch;
            const T = new wd;
            T.layers.enable(2), T.viewport = new ch;
            const S = [w, T], E = new gm;
            E.layers.enable(1), E.layers.enable(2);
            let M = null, A = null;

            function L(e) {
                const t = b.get(e.inputSource);
                t && t.dispatchEvent({type: e.type, data: e.inputSource})
            }

            function C() {
                b.forEach((function (e, t) {
                    e.disconnect(t)
                })), b.clear(), M = null, A = null, i.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), h && t.deleteFramebuffer(h), f && t.deleteFramebuffer(f), m && t.deleteRenderbuffer(m), g && t.deleteRenderbuffer(g), h = null, f = null, m = null, g = null, d = null, u = null, c = null, r = null, N.stop(), n.isPresenting = !1, n.dispatchEvent({type: "sessionend"})
            }

            function R(e) {
                const t = r.inputSources;
                for (let e = 0; e < x.length; e++) b.set(t[e], x[e]);
                for (let t = 0; t < e.removed.length; t++) {
                    const n = e.removed[t], i = b.get(n);
                    i && (i.dispatchEvent({type: "disconnected", data: n}), b.delete(n))
                }
                for (let t = 0; t < e.added.length; t++) {
                    const n = e.added[t], i = b.get(n);
                    i && i.dispatchEvent({type: "connected", data: n})
                }
            }

            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) {
                let t = x[e];
                return void 0 === t && (t = new ym, x[e] = t), t.getTargetRaySpace()
            }, this.getControllerGrip = function (e) {
                let t = x[e];
                return void 0 === t && (t = new ym, x[e] = t), t.getGripSpace()
            }, this.getHand = function (e) {
                let t = x[e];
                return void 0 === t && (t = new ym, x[e] = t), t.getHandSpace()
            }, this.setFramebufferScaleFactor = function (e) {
                s = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }, this.setReferenceSpaceType = function (e) {
                o = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }, this.getReferenceSpace = function () {
                return a
            }, this.getBaseLayer = function () {
                return null !== u ? u : d
            }, this.getBinding = function () {
                return c
            }, this.getFrame = function () {
                return v
            }, this.getSession = function () {
                return r
            }, this.setSession = async function (e) {
                if (r = e, null !== r) {
                    r.addEventListener("select", L), r.addEventListener("selectstart", L), r.addEventListener("selectend", L), r.addEventListener("squeeze", L), r.addEventListener("squeezestart", L), r.addEventListener("squeezeend", L), r.addEventListener("end", C), r.addEventListener("inputsourceschange", R);
                    const e = t.getContextAttributes();
                    if (!0 !== e.xrCompatible && await t.makeXRCompatible(), void 0 === r.renderState.layers) {
                        const n = {
                            antialias: e.antialias,
                            alpha: e.alpha,
                            depth: e.depth,
                            stencil: e.stencil,
                            framebufferScaleFactor: s
                        };
                        d = new XRWebGLLayer(r, t, n), r.updateRenderState({baseLayer: d})
                    } else if (t instanceof WebGLRenderingContext) {
                        const n = {
                            antialias: !0,
                            alpha: e.alpha,
                            depth: e.depth,
                            stencil: e.stencil,
                            framebufferScaleFactor: s
                        };
                        d = new XRWebGLLayer(r, t, n), r.updateRenderState({layers: [d]})
                    } else {
                        p = e.antialias;
                        let n = null;
                        e.depth && (y = 256, e.stencil && (y |= 1024), _ = e.stencil ? 33306 : 36096, n = e.stencil ? 35056 : 33190);
                        const a = {colorFormat: e.alpha ? 32856 : 32849, depthFormat: n, scaleFactor: s};
                        c = new XRWebGLBinding(r, t), u = c.createProjectionLayer(a), h = t.createFramebuffer(), r.updateRenderState({layers: [u]}), p && (f = t.createFramebuffer(), m = t.createRenderbuffer(), t.bindRenderbuffer(36161, m), t.renderbufferStorageMultisample(36161, 4, 32856, u.textureWidth, u.textureHeight), i.bindFramebuffer(36160, f), t.framebufferRenderbuffer(36160, 36064, 36161, m), t.bindRenderbuffer(36161, null), null !== n && (g = t.createRenderbuffer(), t.bindRenderbuffer(36161, g), t.renderbufferStorageMultisample(36161, 4, n, u.textureWidth, u.textureHeight), t.framebufferRenderbuffer(36160, _, 36161, g), t.bindRenderbuffer(36161, null)), i.bindFramebuffer(36160, null))
                    }
                    a = await r.requestReferenceSpace(o), N.setContext(r), N.start(), n.isPresenting = !0, n.dispatchEvent({type: "sessionstart"})
                }
            };
            const P = new ph, I = new ph;

            function O(e, t) {
                null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
            }

            this.updateCamera = function (e) {
                if (null === r) return;
                E.near = T.near = w.near = e.near, E.far = T.far = w.far = e.far, M === E.near && A === E.far || (r.updateRenderState({
                    depthNear: E.near,
                    depthFar: E.far
                }), M = E.near, A = E.far);
                const t = e.parent, n = E.cameras;
                O(E, t);
                for (let e = 0; e < n.length; e++) O(n[e], t);
                E.matrixWorld.decompose(E.position, E.quaternion, E.scale), e.position.copy(E.position), e.quaternion.copy(E.quaternion), e.scale.copy(E.scale), e.matrix.copy(E.matrix), e.matrixWorld.copy(E.matrixWorld);
                const i = e.children;
                for (let e = 0, t = i.length; e < t; e++) i[e].updateMatrixWorld(!0);
                2 === n.length ? function (e, t, n) {
                    P.setFromMatrixPosition(t.matrixWorld), I.setFromMatrixPosition(n.matrixWorld);
                    const i = P.distanceTo(I), r = t.projectionMatrix.elements, s = n.projectionMatrix.elements,
                        a = r[14] / (r[10] - 1), o = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5],
                        h = (r[8] - 1) / r[0], u = (s[8] + 1) / s[0], d = a * h, p = a * u, f = i / (-h + u),
                        m = f * -h;
                    t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                    const g = a + f, v = o + f, _ = d - m, y = p + (i - m), x = l * o / v * g, b = c * o / v * g;
                    e.projectionMatrix.makePerspective(_, y, x, b, g, v)
                }(E, w, T) : E.projectionMatrix.copy(w.projectionMatrix)
            }, this.getCamera = function () {
                return E
            }, this.getFoveation = function () {
                return null !== u ? u.fixedFoveation : null !== d ? d.fixedFoveation : void 0
            }, this.setFoveation = function (e) {
                null !== u && (u.fixedFoveation = e), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e)
            };
            let D = null;
            const N = new Dd;
            N.setAnimationLoop((function (e, n) {
                if (l = n.getViewerPose(a), v = n, null !== l) {
                    const e = l.views;
                    null !== d && i.bindXRFramebuffer(d.framebuffer);
                    let n = !1;
                    e.length !== E.cameras.length && (E.cameras.length = 0, n = !0);
                    for (let r = 0; r < e.length; r++) {
                        const s = e[r];
                        let a = null;
                        if (null !== d) a = d.getViewport(s); else {
                            const e = c.getViewSubImage(u, s);
                            i.bindXRFramebuffer(h), void 0 !== e.depthStencilTexture && t.framebufferTexture2D(36160, _, 3553, e.depthStencilTexture, 0), t.framebufferTexture2D(36160, 36064, 3553, e.colorTexture, 0), a = e.viewport
                        }
                        const o = S[r];
                        o.matrix.fromArray(s.transform.matrix), o.projectionMatrix.fromArray(s.projectionMatrix), o.viewport.set(a.x, a.y, a.width, a.height), 0 === r && E.matrix.copy(o.matrix), !0 === n && E.cameras.push(o)
                    }
                    p && (i.bindXRFramebuffer(f), null !== y && t.clear(y))
                }
                const s = r.inputSources;
                for (let e = 0; e < x.length; e++) {
                    const t = x[e], i = s[e];
                    t.update(i, n, a)
                }
                if (D && D(e, n), p) {
                    const e = u.textureWidth, n = u.textureHeight;
                    i.bindFramebuffer(36008, f), i.bindFramebuffer(36009, h), t.invalidateFramebuffer(36008, [_]), t.invalidateFramebuffer(36009, [_]), t.blitFramebuffer(0, 0, e, n, 0, 0, e, n, 16384, 9728), t.invalidateFramebuffer(36008, [36064]), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, null), i.bindFramebuffer(36160, f)
                }
                v = null
            })), this.setAnimationLoop = function (e) {
                D = e
            }, this.dispose = function () {
            }
        }
    }

    function bm(e) {
        function t(t, n) {
            t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
            const i = e.get(n).envMap;
            if (i) {
                t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio;
                const r = e.get(i).__maxMipLevel;
                void 0 !== r && (t.maxMipLevel.value = r)
            }
            let r, s;
            n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularTintMap ? r = n.specularTintMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap && (r = n.thicknessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), t.uv2Transform.value.copy(s.matrix))
        }

        function n(t, n) {
            t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, 1 === n.side && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), 1 === n.side && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias);
            e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
        }

        return {
            refreshFogUniforms: function (e, t) {
                e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            }, refreshMaterialUniforms: function (e, i, r, s, a) {
                i.isMeshBasicMaterial ? t(e, i) : i.isMeshLambertMaterial ? (t(e, i), function (e, t) {
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                }(e, i)) : i.isMeshToonMaterial ? (t(e, i), function (e, t) {
                    t.gradientMap && (e.gradientMap.value = t.gradientMap);
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshPhongMaterial ? (t(e, i), function (e, t) {
                    e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshStandardMaterial ? (t(e, i), i.isMeshPhysicalMaterial ? function (e, t, i) {
                    n(e, t), e.ior.value = t.ior, t.sheen > 0 && (e.sheenTint.value.copy(t.sheenTint).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness);
                    t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && e.clearcoatNormalScale.value.negate()));
                    t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationTint.value.copy(t.attenuationTint));
                    e.specularIntensity.value = t.specularIntensity, e.specularTint.value.copy(t.specularTint), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap);
                    t.specularTintMap && (e.specularTintMap.value = t.specularTintMap)
                }(e, i, a) : n(e, i)) : i.isMeshMatcapMaterial ? (t(e, i), function (e, t) {
                    t.matcap && (e.matcap.value = t.matcap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshDepthMaterial ? (t(e, i), function (e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshDistanceMaterial ? (t(e, i), function (e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                    e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                }(e, i)) : i.isMeshNormalMaterial ? (t(e, i), function (e, t) {
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isLineBasicMaterial ? (function (e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                }(e, i), i.isLineDashedMaterial && function (e, t) {
                    e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                }(e, i)) : i.isPointsMaterial ? function (e, t, n, i) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                    let r;
                    t.map ? r = t.map : t.alphaMap && (r = t.alphaMap);
                    void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix))
                }(e, i, r, s) : i.isSpriteMaterial ? function (e, t) {
                    e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                    let n;
                    t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
            }
        }
    }

    function wm(e = {}) {
        const t = void 0 !== e.canvas ? e.canvas : function () {
                const e = ih("canvas");
                return e.style.display = "block", e
            }(), n = void 0 !== e.context ? e.context : null, i = void 0 !== e.alpha && e.alpha,
            r = void 0 === e.depth || e.depth, s = void 0 === e.stencil || e.stencil,
            a = void 0 !== e.antialias && e.antialias, o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            c = void 0 !== e.powerPreference ? e.powerPreference : "default",
            h = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
        let u = null, d = null;
        const p = [], f = [];
        this.domElement = t, this.debug = {checkShaderErrors: !0}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Ic, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
        const m = this;
        let g = !1, v = 0, _ = 0, y = null, x = -1, b = null;
        const w = new ch, T = new ch;
        let S = null, E = t.width, M = t.height, A = 1, L = null, C = null;
        const R = new ch(0, 0, E, M), P = new ch(0, 0, E, M);
        let I = !1;
        const O = [], D = new Od;
        let N = !1, B = !1, k = null;
        const U = new Wh, F = new ph,
            H = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0};

        function z() {
            return null === y ? A : 1
        }

        let G, V, W, j, $, X, q, Y, K, J, Z, Q, ee, te, ne, ie, re, se, ae, oe, le, ce, he, ue = n;

        function de(e, n) {
            for (let i = 0; i < e.length; i++) {
                const r = e[i], s = t.getContext(r, n);
                if (null !== s) return s
            }
            return null
        }

        try {
            const e = {
                alpha: i,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: o,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: h
            };
            if (t.addEventListener("webglcontextlost", me, !1), t.addEventListener("webglcontextrestored", ge, !1), null === ue) {
                const t = ["webgl2", "webgl", "experimental-webgl"];
                if (!0 === m.isWebGL1Renderer && t.shift(), ue = de(t, e), null === ue) throw de(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            void 0 === ue.getShaderPrecisionFormat && (ue.getShaderPrecisionFormat = function () {
                return {rangeMin: 1, rangeMax: 1, precision: 1}
            })
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message), e
        }

        function pe() {
            G = new _p(ue), V = new Vd(ue, G, e), G.init(V), ce = new mm(ue, G, V), W = new pm(ue, G, V), O[0] = 1029, j = new bp(ue), $ = new Qf, X = new fm(ue, G, W, $, V, ce, j), q = new jd(m), Y = new vp(m), K = new Nd(ue, V), he = new zd(ue, G, K, V), J = new yp(ue, K, j, he), Z = new Ap(ue, J, K, j), ae = new Mp(ue, V, X), ie = new Wd($), Q = new Zf(m, q, Y, G, V, he, ie), ee = new bm($), te = new im($), ne = new cm(G, V), se = new Hd(m, q, W, Z, o), re = new dm(m, Z, V), oe = new Gd(ue, G, j, V), le = new xp(ue, G, j, V), j.programs = Q.programs, m.capabilities = V, m.extensions = G, m.properties = $, m.renderLists = te, m.shadowMap = re, m.state = W, m.info = j
        }

        pe();
        const fe = new xm(m, ue);

        function me(e) {
            e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
        }

        function ge() {
            console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
            const e = j.autoReset, t = re.enabled, n = re.autoUpdate, i = re.needsUpdate, r = re.type;
            pe(), j.autoReset = e, re.enabled = t, re.autoUpdate = n, re.needsUpdate = i, re.type = r
        }

        function ve(e) {
            const t = e.target;
            t.removeEventListener("dispose", ve), function (e) {
                (function (e) {
                    const t = $.get(e).programs;
                    void 0 !== t && t.forEach((function (e) {
                        Q.releaseProgram(e)
                    }))
                })(e), $.remove(e)
            }(t)
        }

        this.xr = fe, this.getContext = function () {
            return ue
        }, this.getContextAttributes = function () {
            return ue.getContextAttributes()
        }, this.forceContextLoss = function () {
            const e = G.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function () {
            const e = G.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function () {
            return A
        }, this.setPixelRatio = function (e) {
            void 0 !== e && (A = e, this.setSize(E, M, !1))
        }, this.getSize = function (e) {
            return e.set(E, M)
        }, this.setSize = function (e, n, i) {
            fe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = e, M = n, t.width = Math.floor(e * A), t.height = Math.floor(n * A), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
        }, this.getDrawingBufferSize = function (e) {
            return e.set(E * A, M * A).floor()
        }, this.setDrawingBufferSize = function (e, n, i) {
            E = e, M = n, A = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
        }, this.getCurrentViewport = function (e) {
            return e.copy(w)
        }, this.getViewport = function (e) {
            return e.copy(R)
        }, this.setViewport = function (e, t, n, i) {
            e.isVector4 ? R.set(e.x, e.y, e.z, e.w) : R.set(e, t, n, i), W.viewport(w.copy(R).multiplyScalar(A).floor())
        }, this.getScissor = function (e) {
            return e.copy(P)
        }, this.setScissor = function (e, t, n, i) {
            e.isVector4 ? P.set(e.x, e.y, e.z, e.w) : P.set(e, t, n, i), W.scissor(T.copy(P).multiplyScalar(A).floor())
        }, this.getScissorTest = function () {
            return I
        }, this.setScissorTest = function (e) {
            W.setScissorTest(I = e)
        }, this.setOpaqueSort = function (e) {
            L = e
        }, this.setTransparentSort = function (e) {
            C = e
        }, this.getClearColor = function (e) {
            return e.copy(se.getClearColor())
        }, this.setClearColor = function () {
            se.setClearColor.apply(se, arguments)
        }, this.getClearAlpha = function () {
            return se.getClearAlpha()
        }, this.setClearAlpha = function () {
            se.setClearAlpha.apply(se, arguments)
        }, this.clear = function (e, t, n) {
            let i = 0;
            (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), ue.clear(i)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            t.removeEventListener("webglcontextlost", me, !1), t.removeEventListener("webglcontextrestored", ge, !1), te.dispose(), ne.dispose(), $.dispose(), q.dispose(), Y.dispose(), Z.dispose(), he.dispose(), fe.dispose(), fe.removeEventListener("sessionstart", ye), fe.removeEventListener("sessionend", xe), k && (k.dispose(), k = null), be.stop()
        }, this.renderBufferImmediate = function (e, t) {
            he.initAttributes();
            const n = $.get(e);
            e.hasPositions && !n.position && (n.position = ue.createBuffer()), e.hasNormals && !n.normal && (n.normal = ue.createBuffer()), e.hasUvs && !n.uv && (n.uv = ue.createBuffer()), e.hasColors && !n.color && (n.color = ue.createBuffer());
            const i = t.getAttributes();
            e.hasPositions && (ue.bindBuffer(34962, n.position), ue.bufferData(34962, e.positionArray, 35048), he.enableAttribute(i.position.location), ue.vertexAttribPointer(i.position.location, 3, 5126, !1, 0, 0)), e.hasNormals && (ue.bindBuffer(34962, n.normal), ue.bufferData(34962, e.normalArray, 35048), he.enableAttribute(i.normal.location), ue.vertexAttribPointer(i.normal.location, 3, 5126, !1, 0, 0)), e.hasUvs && (ue.bindBuffer(34962, n.uv), ue.bufferData(34962, e.uvArray, 35048), he.enableAttribute(i.uv.location), ue.vertexAttribPointer(i.uv.location, 2, 5126, !1, 0, 0)), e.hasColors && (ue.bindBuffer(34962, n.color), ue.bufferData(34962, e.colorArray, 35048), he.enableAttribute(i.color.location), ue.vertexAttribPointer(i.color.location, 3, 5126, !1, 0, 0)), he.disableUnusedAttributes(), ue.drawArrays(4, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function (e, t, n, i, r, s) {
            null === t && (t = H);
            const a = r.isMesh && r.matrixWorld.determinant() < 0, o = Le(e, t, n, i, r);
            W.setMaterial(i, a);
            let l = n.index;
            const c = n.attributes.position;
            if (null === l) {
                if (void 0 === c || 0 === c.count) return
            } else if (0 === l.count) return;
            let h, u = 1;
            !0 === i.wireframe && (l = J.getWireframeAttribute(n), u = 2), he.setup(r, i, o, n, l);
            let d = oe;
            null !== l && (h = K.get(l), d = le, d.setIndex(h));
            const p = null !== l ? l.count : c.count, f = n.drawRange.start * u, m = n.drawRange.count * u,
                g = null !== s ? s.start * u : 0, v = null !== s ? s.count * u : 1 / 0, _ = Math.max(f, g),
                y = Math.min(p, f + m, g + v) - 1, x = Math.max(0, y - _ + 1);
            if (0 !== x) {
                if (r.isMesh) !0 === i.wireframe ? (W.setLineWidth(i.wireframeLinewidth * z()), d.setMode(1)) : d.setMode(4); else if (r.isLine) {
                    let e = i.linewidth;
                    void 0 === e && (e = 1), W.setLineWidth(e * z()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                if (r.isInstancedMesh) d.renderInstances(_, x, r.count); else if (n.isInstancedBufferGeometry) {
                    const e = Math.min(n.instanceCount, n._maxInstanceCount);
                    d.renderInstances(_, x, e)
                } else d.render(_, x)
            }
        }, this.compile = function (e, t) {
            d = ne.get(e), d.init(), f.push(d), e.traverseVisible((function (e) {
                e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e))
            })), d.setupLights(m.physicallyCorrectLights), e.traverse((function (t) {
                const n = t.material;
                if (n) if (Array.isArray(n)) for (let i = 0; i < n.length; i++) {
                    Me(n[i], e, t)
                } else Me(n, e, t)
            })), f.pop(), d = null
        };
        let _e = null;

        function ye() {
            be.stop()
        }

        function xe() {
            be.start()
        }

        const be = new Dd;

        function we(e, t, n, i) {
            if (!1 === e.visible) return;
            if (e.layers.test(t.layers)) if (e.isGroup) n = e.renderOrder; else if (e.isLOD) !0 === e.autoUpdate && e.update(t); else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e); else if (e.isSprite) {
                if (!e.frustumCulled || D.intersectsSprite(e)) {
                    i && F.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U);
                    const t = Z.update(e), r = e.material;
                    r.visible && u.push(e, t, r, n, F.z, null)
                }
            } else if (e.isImmediateRenderObject) i && F.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U), u.push(e, null, e.material, n, F.z, null); else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== j.render.frame && (e.skeleton.update(), e.skeleton.frame = j.render.frame), !e.frustumCulled || D.intersectsObject(e))) {
                i && F.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U);
                const t = Z.update(e), r = e.material;
                if (Array.isArray(r)) {
                    const i = t.groups;
                    for (let s = 0, a = i.length; s < a; s++) {
                        const a = i[s], o = r[a.materialIndex];
                        o && o.visible && u.push(e, t, o, n, F.z, a)
                    }
                } else r.visible && u.push(e, t, r, n, F.z, null)
            }
            const r = e.children;
            for (let e = 0, s = r.length; e < s; e++) we(r[e], t, n, i)
        }

        function Te(e, t, n, i) {
            const r = e.opaque, s = e.transmissive, o = e.transparent;
            d.setupLightsView(n), s.length > 0 && function (e, t, n) {
                if (null === k) {
                    const e = !0 === a && !0 === V.isWebGL2;
                    k = new (e ? uh : hh)(1024, 1024, {
                        generateMipmaps: !0,
                        type: null !== ce.convert(pc) ? pc : cc,
                        minFilter: lc,
                        magFilter: rc,
                        wrapS: nc,
                        wrapT: nc
                    })
                }
                const i = m.getRenderTarget();
                m.setRenderTarget(k), m.clear();
                const r = m.toneMapping;
                m.toneMapping = 0, Se(e, t, n), m.toneMapping = r, X.updateMultisampleRenderTarget(k), X.updateRenderTargetMipmap(k), m.setRenderTarget(i)
            }(r, t, n), i && W.viewport(w.copy(i)), r.length > 0 && Se(r, t, n), s.length > 0 && Se(s, t, n), o.length > 0 && Se(o, t, n)
        }

        function Se(e, t, n) {
            const i = !0 === t.isScene ? t.overrideMaterial : null;
            for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r], a = s.object, o = s.geometry, l = null === i ? s.material : i, c = s.group;
                a.layers.test(n.layers) && Ee(a, t, n, o, l, c)
            }
        }

        function Ee(e, t, n, i, r, s) {
            if (e.onBeforeRender(m, t, n, i, r, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(m, t, n, i, e, s), e.isImmediateRenderObject) {
                const s = Le(n, t, i, r, e);
                W.setMaterial(r), he.reset(), function (e, t) {
                    e.render((function (e) {
                        m.renderBufferImmediate(e, t)
                    }))
                }(e, s)
            } else !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, m.renderBufferDirect(n, t, i, r, e, s), r.side = 0, r.needsUpdate = !0, m.renderBufferDirect(n, t, i, r, e, s), r.side = 2) : m.renderBufferDirect(n, t, i, r, e, s);
            e.onAfterRender(m, t, n, i, r, s)
        }

        function Me(e, t, n) {
            !0 !== t.isScene && (t = H);
            const i = $.get(e), r = d.state.lights, s = d.state.shadowsArray, a = r.state.version,
                o = Q.getParameters(e, r.state, s, t, n), l = Q.getProgramCacheKey(o);
            let c = i.programs;
            i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? Y : q).get(e.envMap || i.environment), void 0 === c && (e.addEventListener("dispose", ve), c = new Map, i.programs = c);
            let h = c.get(l);
            if (void 0 !== h) {
                if (i.currentProgram === h && i.lightsStateVersion === a) return Ae(e, o), h
            } else o.uniforms = Q.getUniforms(e), e.onBuild(o, m), e.onBeforeCompile(o, m), h = Q.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
            const u = i.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = ie.uniform), Ae(e, o), i.needsLights = function (e) {
                return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
            }(e), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
            const p = h.getUniforms(), f = Pf.seqWithValue(p.seq, u);
            return i.currentProgram = h, i.uniformsList = f, h
        }

        function Ae(e, t) {
            const n = $.get(e);
            n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents
        }

        function Le(e, t, n, i, r) {
            !0 !== t.isScene && (t = H), X.resetTextureUnits();
            const s = t.fog, a = i.isMeshStandardMaterial ? t.environment : null,
                o = null === y ? m.outputEncoding : y.texture.encoding,
                l = (i.isMeshStandardMaterial ? Y : q).get(i.envMap || a),
                c = !0 === i.vertexColors && !!n && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                h = !!i.normalMap && !!n && !!n.attributes.tangent, u = !!n && !!n.morphAttributes.position,
                p = !!n && !!n.morphAttributes.normal,
                f = n && n.morphAttributes.position ? n.morphAttributes.position.length : 0, g = $.get(i),
                v = d.state.lights;
            if (!0 === N && (!0 === B || e !== b)) {
                const t = e === b && i.id === x;
                ie.setState(i, e, t)
            }
            let _ = !1;
            i.version === g.__version ? g.needsLights && g.lightsStateVersion !== v.state.version || g.outputEncoding !== o || r.isInstancedMesh && !1 === g.instancing ? _ = !0 : r.isInstancedMesh || !0 !== g.instancing ? r.isSkinnedMesh && !1 === g.skinning ? _ = !0 : r.isSkinnedMesh || !0 !== g.skinning ? g.envMap !== l || i.fog && g.fog !== s ? _ = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === ie.numPlanes && g.numIntersection === ie.numIntersection ? (g.vertexAlphas !== c || g.vertexTangents !== h || g.morphTargets !== u || g.morphNormals !== p || !0 === V.isWebGL2 && g.morphTargetsCount !== f) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : (_ = !0, g.__version = i.version);
            let w = g.currentProgram;
            !0 === _ && (w = Me(i, t, r));
            let T = !1, S = !1, E = !1;
            const L = w.getUniforms(), C = g.uniforms;
            if (W.useProgram(w.program) && (T = !0, S = !0, E = !0), i.id !== x && (x = i.id, S = !0), T || b !== e) {
                if (L.setValue(ue, "projectionMatrix", e.projectionMatrix), V.logarithmicDepthBuffer && L.setValue(ue, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), b !== e && (b = e, S = !0, E = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                    const t = L.map.cameraPosition;
                    void 0 !== t && t.setValue(ue, F.setFromMatrixPosition(e.matrixWorld))
                }
                (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && L.setValue(ue, "isOrthographic", !0 === e.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && L.setValue(ue, "viewMatrix", e.matrixWorldInverse)
            }
            if (r.isSkinnedMesh) {
                L.setOptional(ue, r, "bindMatrix"), L.setOptional(ue, r, "bindMatrixInverse");
                const e = r.skeleton;
                e && (V.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), L.setValue(ue, "boneTexture", e.boneTexture, X), L.setValue(ue, "boneTextureSize", e.boneTextureSize)) : L.setOptional(ue, e, "boneMatrices"))
            }
            var R, P;
            return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || ae.update(r, n, i, w), (S || g.receiveShadow !== r.receiveShadow) && (g.receiveShadow = r.receiveShadow, L.setValue(ue, "receiveShadow", r.receiveShadow)), S && (L.setValue(ue, "toneMappingExposure", m.toneMappingExposure), g.needsLights && (P = E, (R = C).ambientLightColor.needsUpdate = P, R.lightProbe.needsUpdate = P, R.directionalLights.needsUpdate = P, R.directionalLightShadows.needsUpdate = P, R.pointLights.needsUpdate = P, R.pointLightShadows.needsUpdate = P, R.spotLights.needsUpdate = P, R.spotLightShadows.needsUpdate = P, R.rectAreaLights.needsUpdate = P, R.hemisphereLights.needsUpdate = P), s && i.fog && ee.refreshFogUniforms(C, s), ee.refreshMaterialUniforms(C, i, A, M, k), Pf.upload(ue, g.uniformsList, C, X)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Pf.upload(ue, g.uniformsList, C, X), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && L.setValue(ue, "center", r.center), L.setValue(ue, "modelViewMatrix", r.modelViewMatrix), L.setValue(ue, "normalMatrix", r.normalMatrix), L.setValue(ue, "modelMatrix", r.matrixWorld), w
        }

        be.setAnimationLoop((function (e) {
            _e && _e(e)
        })), "undefined" != typeof window && be.setContext(window), this.setAnimationLoop = function (e) {
            _e = e, fe.setAnimationLoop(e), null === e ? be.stop() : be.start()
        }, fe.addEventListener("sessionstart", ye), fe.addEventListener("sessionend", xe), this.render = function (e, t) {
            if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!0 === g) return;
            !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === fe.enabled && !0 === fe.isPresenting && (!0 === fe.cameraAutoUpdate && fe.updateCamera(t), t = fe.getCamera()), !0 === e.isScene && e.onBeforeRender(m, e, t, y), d = ne.get(e, f.length), d.init(), f.push(d), U.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), D.setFromProjectionMatrix(U), B = this.localClippingEnabled, N = ie.init(this.clippingPlanes, B, t), u = te.get(e, p.length), u.init(), p.push(u), we(e, t, 0, m.sortObjects), u.finish(), !0 === m.sortObjects && u.sort(L, C), !0 === N && ie.beginShadows();
            const n = d.state.shadowsArray;
            if (re.render(n, e, t), !0 === N && ie.endShadows(), !0 === this.info.autoReset && this.info.reset(), se.render(u, e), d.setupLights(m.physicallyCorrectLights), t.isArrayCamera) {
                const n = t.cameras;
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    Te(u, e, i, i.viewport)
                }
            } else Te(u, e, t);
            null !== y && (X.updateMultisampleRenderTarget(y), X.updateRenderTargetMipmap(y)), !0 === e.isScene && e.onAfterRender(m, e, t), W.buffers.depth.setTest(!0), W.buffers.depth.setMask(!0), W.buffers.color.setMask(!0), W.setPolygonOffset(!1), he.resetDefaultState(), x = -1, b = null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), u = p.length > 0 ? p[p.length - 1] : null
        }, this.getActiveCubeFace = function () {
            return v
        }, this.getActiveMipmapLevel = function () {
            return _
        }, this.getRenderTarget = function () {
            return y
        }, this.setRenderTarget = function (e, t = 0, n = 0) {
            y = e, v = t, _ = n, e && void 0 === $.get(e).__webglFramebuffer && X.setupRenderTarget(e);
            let i = null, r = !1, s = !1;
            if (e) {
                const n = e.texture;
                (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                const a = $.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget ? (i = a[t], r = !0) : i = e.isWebGLMultisampleRenderTarget ? $.get(e).__webglMultisampledFramebuffer : a, w.copy(e.viewport), T.copy(e.scissor), S = e.scissorTest
            } else w.copy(R).multiplyScalar(A).floor(), T.copy(P).multiplyScalar(A).floor(), S = I;
            if (W.bindFramebuffer(36160, i) && V.drawBuffers) {
                let t = !1;
                if (e) if (e.isWebGLMultipleRenderTargets) {
                    const n = e.texture;
                    if (O.length !== n.length || 36064 !== O[0]) {
                        for (let e = 0, t = n.length; e < t; e++) O[e] = 36064 + e;
                        O.length = n.length, t = !0
                    }
                } else 1 === O.length && 36064 === O[0] || (O[0] = 36064, O.length = 1, t = !0); else 1 === O.length && 1029 === O[0] || (O[0] = 1029, O.length = 1, t = !0);
                t && (V.isWebGL2 ? ue.drawBuffers(O) : G.get("WEBGL_draw_buffers").drawBuffersWEBGL(O))
            }
            if (W.viewport(w), W.scissor(T), W.setScissorTest(S), r) {
                const i = $.get(e.texture);
                ue.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n)
            } else if (s) {
                const i = $.get(e.texture), r = t || 0;
                ue.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
            }
            x = -1
        }, this.readRenderTargetPixels = function (e, t, n, i, r, s, a) {
            if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let o = $.get(e).__webglFramebuffer;
            if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
                W.bindFramebuffer(36160, o);
                try {
                    const a = e.texture, o = a.format, l = a.type;
                    if (o !== gc && ce.convert(o) !== ue.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    const c = l === pc && (G.has("EXT_color_buffer_half_float") || V.isWebGL2 && G.has("EXT_color_buffer_float"));
                    if (!(l === cc || ce.convert(l) === ue.getParameter(35738) || l === dc && (V.isWebGL2 || G.has("OES_texture_float") || G.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    36053 === ue.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && ue.readPixels(t, n, i, r, ce.convert(o), ce.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    const e = null !== y ? $.get(y).__webglFramebuffer : null;
                    W.bindFramebuffer(36160, e)
                }
            }
        }, this.copyFramebufferToTexture = function (e, t, n = 0) {
            const i = Math.pow(2, -n), r = Math.floor(t.image.width * i), s = Math.floor(t.image.height * i);
            let a = ce.convert(t.format);
            V.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)), X.setTexture2D(t, 0), ue.copyTexImage2D(3553, n, a, e.x, e.y, r, s, 0), W.unbindTexture()
        }, this.copyTextureToTexture = function (e, t, n, i = 0) {
            const r = t.image.width, s = t.image.height, a = ce.convert(n.format), o = ce.convert(n.type);
            X.setTexture2D(n, 0), ue.pixelStorei(37440, n.flipY), ue.pixelStorei(37441, n.premultiplyAlpha), ue.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? ue.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data) : t.isCompressedTexture ? ue.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : ue.texSubImage2D(3553, i, e.x, e.y, a, o, t.image), 0 === i && n.generateMipmaps && ue.generateMipmap(3553), W.unbindTexture()
        }, this.copyTextureToTexture3D = function (e, t, n, i, r = 0) {
            if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            const s = e.max.x - e.min.x + 1, a = e.max.y - e.min.y + 1, o = e.max.z - e.min.z + 1,
                l = ce.convert(i.format), c = ce.convert(i.type);
            let h;
            if (i.isDataTexture3D) X.setTexture3D(i, 0), h = 32879; else {
                if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                X.setTexture2DArray(i, 0), h = 35866
            }
            ue.pixelStorei(37440, i.flipY), ue.pixelStorei(37441, i.premultiplyAlpha), ue.pixelStorei(3317, i.unpackAlignment);
            const u = ue.getParameter(3314), d = ue.getParameter(32878), p = ue.getParameter(3316),
                f = ue.getParameter(3315), g = ue.getParameter(32877),
                v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
            ue.pixelStorei(3314, v.width), ue.pixelStorei(32878, v.height), ue.pixelStorei(3316, e.min.x), ue.pixelStorei(3315, e.min.y), ue.pixelStorei(32877, e.min.z), n.isDataTexture || n.isDataTexture3D ? ue.texSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, c, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ue.compressedTexSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, v.data)) : ue.texSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, c, v), ue.pixelStorei(3314, u), ue.pixelStorei(32878, d), ue.pixelStorei(3316, p), ue.pixelStorei(3315, f), ue.pixelStorei(32877, g), 0 === r && i.generateMipmaps && ue.generateMipmap(h), W.unbindTexture()
        }, this.initTexture = function (e) {
            X.setTexture2D(e, 0), W.unbindTexture()
        }, this.resetState = function () {
            v = 0, _ = 0, y = null, W.reset(), he.reset()
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
    }

    (class extends wm {
    }).prototype.isWebGL1Renderer = !0;

    class Tm {
        constructor(e, t = 1, n = 1e3) {
            this.name = "", this.color = new Nu(e), this.near = t, this.far = n
        }

        clone() {
            return new Tm(this.color, this.near, this.far)
        }

        toJSON() {
            return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
        }
    }

    Tm.prototype.isFog = !0;

    class Sm extends mu {
        constructor() {
            super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
        }

        copy(e, t) {
            return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        }

        toJSON(e) {
            const t = super.toJSON(e);
            return null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        }
    }

    Sm.prototype.isScene = !0;

    class Em {
        constructor(e, t) {
            this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = kc, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0, this.uuid = $c()
        }

        onUploadCallback() {
        }

        set needsUpdate(e) {
            !0 === e && this.version++
        }

        setUsage(e) {
            return this.usage = e, this
        }

        copy(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
        }

        copyAt(e, t, n) {
            e *= this.stride, n *= t.stride;
            for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
            return this
        }

        set(e, t = 0) {
            return this.array.set(e, t), this
        }

        clone(e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = $c()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                n = new this.constructor(t, this.stride);
            return n.setUsage(this.usage), n
        }

        onUpload(e) {
            return this.onUploadCallback = e, this
        }

        toJSON(e) {
            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = $c()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }

    Em.prototype.isInterleavedBuffer = !0;
    const Mm = new ph;

    class Am {
        constructor(e, t, n, i = !1) {
            this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i
        }

        get count() {
            return this.data.count
        }

        get array() {
            return this.data.array
        }

        set needsUpdate(e) {
            this.data.needsUpdate = e
        }

        applyMatrix4(e) {
            for (let t = 0, n = this.data.count; t < n; t++) Mm.x = this.getX(t), Mm.y = this.getY(t), Mm.z = this.getZ(t), Mm.applyMatrix4(e), this.setXYZ(t, Mm.x, Mm.y, Mm.z);
            return this
        }

        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++) Mm.x = this.getX(t), Mm.y = this.getY(t), Mm.z = this.getZ(t), Mm.applyNormalMatrix(e), this.setXYZ(t, Mm.x, Mm.y, Mm.z);
            return this
        }

        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++) Mm.x = this.getX(t), Mm.y = this.getY(t), Mm.z = this.getZ(t), Mm.transformDirection(e), this.setXYZ(t, Mm.x, Mm.y, Mm.z);
            return this
        }

        setX(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        }

        setY(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        }

        setZ(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        }

        setW(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        }

        getX(e) {
            return this.data.array[e * this.data.stride + this.offset]
        }

        getY(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        }

        getZ(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        }

        getW(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        }

        setXY(e, t, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
        }

        setXYZ(e, t, n, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
        }

        setXYZW(e, t, n, i, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
        }

        clone(e) {
            if (void 0 === e) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                const e = [];
                for (let t = 0; t < this.count; t++) {
                    const n = t * this.data.stride + this.offset;
                    for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                }
                return new Fu(new this.array.constructor(e), this.itemSize, this.normalized)
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Am(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
        }

        toJSON(e) {
            if (void 0 === e) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                const e = [];
                for (let t = 0; t < this.count; t++) {
                    const n = t * this.data.stride + this.offset;
                    for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: e,
                    normalized: this.normalized
                }
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }

    Am.prototype.isInterleavedBufferAttribute = !0;

    class Lm extends Lu {
        constructor(e) {
            super(), this.type = "SpriteMaterial", this.color = new Nu(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
        }
    }

    let Cm;
    Lm.prototype.isSpriteMaterial = !0;
    const Rm = new ph, Pm = new ph, Im = new ph, Om = new eh, Dm = new eh, Nm = new Wh, Bm = new ph, km = new ph,
        Um = new ph, Fm = new eh, Hm = new eh, zm = new eh;

    function Gm(e, t, n, i, r, s) {
        Om.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (Dm.x = s * Om.x - r * Om.y, Dm.y = r * Om.x + s * Om.y) : Dm.copy(Om), e.copy(t), e.x += Dm.x, e.y += Dm.y, e.applyMatrix4(Nm)
    }

    (class extends mu {
        constructor(e) {
            if (super(), this.type = "Sprite", void 0 === Cm) {
                Cm = new Ku;
                const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                    t = new Em(e, 5);
                Cm.setIndex([0, 1, 2, 0, 2, 3]), Cm.setAttribute("position", new Am(t, 3, 0, !1)), Cm.setAttribute("uv", new Am(t, 2, 3, !1))
            }
            this.geometry = Cm, this.material = void 0 !== e ? e : new Lm, this.center = new eh(.5, .5)
        }

        raycast(e, t) {
            null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Pm.setFromMatrixScale(this.matrixWorld), Nm.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Im.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Pm.multiplyScalar(-Im.z);
            const n = this.material.rotation;
            let i, r;
            0 !== n && (r = Math.cos(n), i = Math.sin(n));
            const s = this.center;
            Gm(Bm.set(-.5, -.5, 0), Im, s, Pm, i, r), Gm(km.set(.5, -.5, 0), Im, s, Pm, i, r), Gm(Um.set(.5, .5, 0), Im, s, Pm, i, r), Fm.set(0, 0), Hm.set(1, 0), zm.set(1, 1);
            let a = e.ray.intersectTriangle(Bm, km, Um, !1, Rm);
            if (null === a && (Gm(km.set(-.5, .5, 0), Im, s, Pm, i, r), Hm.set(0, 1), a = e.ray.intersectTriangle(Bm, Um, km, !1, Rm), null === a)) return;
            const o = e.ray.origin.distanceTo(Rm);
            o < e.near || o > e.far || t.push({
                distance: o,
                point: Rm.clone(),
                uv: Mu.getUV(Rm, Bm, km, Um, Fm, Hm, zm, new eh),
                face: null,
                object: this
            })
        }

        copy(e) {
            return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
        }
    }).prototype.isSprite = !0;
    const Vm = new ph, Wm = new ch, jm = new ch, $m = new ph, Xm = new Wh;

    class qm extends fd {
        constructor(e, t) {
            super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Wh, this.bindMatrixInverse = new Wh
        }

        copy(e) {
            return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
        }

        bind(e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
        }

        pose() {
            this.skeleton.pose()
        }

        normalizeSkinWeights() {
            const e = new ch, t = this.geometry.attributes.skinWeight;
            for (let n = 0, i = t.count; n < i; n++) {
                e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                const i = 1 / e.manhattanLength();
                i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        }

        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        }

        boneTransform(e, t) {
            const n = this.skeleton, i = this.geometry;
            Wm.fromBufferAttribute(i.attributes.skinIndex, e), jm.fromBufferAttribute(i.attributes.skinWeight, e), Vm.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
            for (let e = 0; e < 4; e++) {
                const i = jm.getComponent(e);
                if (0 !== i) {
                    const r = Wm.getComponent(e);
                    Xm.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector($m.copy(Vm).applyMatrix4(Xm), i)
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
    }

    qm.prototype.isSkinnedMesh = !0;

    class Ym extends mu {
        constructor() {
            super(), this.type = "Bone"
        }
    }

    Ym.prototype.isBone = !0;

    class Km extends oh {
        constructor(e = null, t = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, h, u) {
            super(null, s, a, o, l, c, i, r, h, u), this.image = {
                data: e,
                width: t,
                height: n
            }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }
    }

    Km.prototype.isDataTexture = !0;
    const Jm = new Wh, Zm = new Wh;

    class Qm {
        constructor(e = [], t = []) {
            this.uuid = $c(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
        }

        init() {
            const e = this.bones, t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Wh)
            }
        }

        calculateInverses() {
            this.boneInverses.length = 0;
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const t = new Wh;
                this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
            }
        }

        pose() {
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const t = this.bones[e];
                t && t.matrixWorld.copy(this.boneInverses[e]).invert()
            }
            for (let e = 0, t = this.bones.length; e < t; e++) {
                const t = this.bones[e];
                t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            }
        }

        update() {
            const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
            for (let i = 0, r = e.length; i < r; i++) {
                const r = e[i] ? e[i].matrixWorld : Zm;
                Jm.multiplyMatrices(r, t[i]), Jm.toArray(n, 16 * i)
            }
            null !== i && (i.needsUpdate = !0)
        }

        clone() {
            return new Qm(this.bones, this.boneInverses)
        }

        computeBoneTexture() {
            let e = Math.sqrt(4 * this.bones.length);
            e = Jc(e), e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            const n = new Km(t, e, e, gc, dc);
            return this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
        }

        getBoneByName(e) {
            for (let t = 0, n = this.bones.length; t < n; t++) {
                const n = this.bones[t];
                if (n.name === e) return n
            }
        }

        dispose() {
            null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
        }

        fromJSON(e, t) {
            this.uuid = e.uuid;
            for (let n = 0, i = e.bones.length; n < i; n++) {
                const i = e.bones[n];
                let r = t[i];
                void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Ym), this.bones.push(r), this.boneInverses.push((new Wh).fromArray(e.boneInverses[n]))
            }
            return this.init(), this
        }

        toJSON() {
            const e = {
                metadata: {version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON"},
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            const t = this.bones, n = this.boneInverses;
            for (let i = 0, r = t.length; i < r; i++) {
                const r = t[i];
                e.bones.push(r.uuid);
                const s = n[i];
                e.boneInverses.push(s.toArray())
            }
            return e
        }
    }

    class eg extends Fu {
        constructor(e, t, n, i = 1) {
            "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.meshPerAttribute = i
        }

        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
        }

        toJSON() {
            const e = super.toJSON();
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }

    eg.prototype.isInstancedBufferAttribute = !0;
    const tg = new Wh, ng = new Wh, ig = [], rg = new fd;
    (class extends fd {
        constructor(e, t, n) {
            super(e, t), this.instanceMatrix = new eg(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
        }

        copy(e) {
            return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
        }

        getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, 3 * e)
        }

        getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, 16 * e)
        }

        raycast(e, t) {
            const n = this.matrixWorld, i = this.count;
            if (rg.geometry = this.geometry, rg.material = this.material, void 0 !== rg.material) for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, tg), ng.multiplyMatrices(n, tg), rg.matrixWorld = ng, rg.raycast(e, ig);
                for (let e = 0, n = ig.length; e < n; e++) {
                    const n = ig[e];
                    n.instanceId = r, n.object = this, t.push(n)
                }
                ig.length = 0
            }
        }

        setColorAt(e, t) {
            null === this.instanceColor && (this.instanceColor = new eg(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
        }

        setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
        }

        updateMorphTargets() {
        }

        dispose() {
            this.dispatchEvent({type: "dispose"})
        }
    }).prototype.isInstancedMesh = !0;

    class sg extends Lu {
        constructor(e) {
            super(), this.type = "LineBasicMaterial", this.color = new Nu(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
        }
    }

    sg.prototype.isLineBasicMaterial = !0;
    const ag = new ph, og = new ph, lg = new Wh, cg = new Vh, hg = new Nh;

    class ug extends mu {
        constructor(e = new Ku, t = new sg) {
            super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
        }

        copy(e) {
            return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
        }

        computeLineDistances() {
            const e = this.geometry;
            if (e.isBufferGeometry) if (null === e.index) {
                const t = e.attributes.position, n = [0];
                for (let e = 1, i = t.count; e < i; e++) ag.fromBufferAttribute(t, e - 1), og.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += ag.distanceTo(og);
                e.setAttribute("lineDistance", new Gu(n, 1))
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }

        raycast(e, t) {
            const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, s = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(), hg.copy(n.boundingSphere), hg.applyMatrix4(i), hg.radius += r, !1 === e.ray.intersectsSphere(hg)) return;
            lg.copy(i).invert(), cg.copy(e.ray).applyMatrix4(lg);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, l = new ph, c = new ph,
                h = new ph, u = new ph, d = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
                const i = n.index, r = n.attributes.position;
                if (null !== i) {
                    for (let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1; n < a; n += d) {
                        const s = i.getX(n), a = i.getX(n + 1);
                        l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a);
                        if (cg.distanceSqToSegment(l, c, u, h) > o) continue;
                        u.applyMatrix4(this.matrixWorld);
                        const d = e.ray.origin.distanceTo(u);
                        d < e.near || d > e.far || t.push({
                            distance: d,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
                        l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
                        if (cg.distanceSqToSegment(l, c, u, h) > o) continue;
                        u.applyMatrix4(this.matrixWorld);
                        const i = e.ray.origin.distanceTo(u);
                        i < e.near || i > e.far || t.push({
                            distance: i,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }

        updateMorphTargets() {
            const e = this.geometry;
            if (e.isBufferGeometry) {
                const t = e.morphAttributes, n = Object.keys(t);
                if (n.length > 0) {
                    const e = t[n[0]];
                    if (void 0 !== e) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    }
                }
            } else {
                const t = e.morphTargets;
                void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }

    ug.prototype.isLine = !0;
    const dg = new ph, pg = new ph;

    class fg extends ug {
        constructor(e, t) {
            super(e, t), this.type = "LineSegments"
        }

        computeLineDistances() {
            const e = this.geometry;
            if (e.isBufferGeometry) if (null === e.index) {
                const t = e.attributes.position, n = [];
                for (let e = 0, i = t.count; e < i; e += 2) dg.fromBufferAttribute(t, e), pg.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + dg.distanceTo(pg);
                e.setAttribute("lineDistance", new Gu(n, 1))
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }
    }

    fg.prototype.isLineSegments = !0;

    class mg extends ug {
        constructor(e, t) {
            super(e, t), this.type = "LineLoop"
        }
    }

    mg.prototype.isLineLoop = !0;

    class gg extends Lu {
        constructor(e) {
            super(), this.type = "PointsMaterial", this.color = new Nu(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
        }
    }

    gg.prototype.isPointsMaterial = !0;
    const vg = new Wh, _g = new Vh, yg = new Nh, xg = new ph;

    class bg extends mu {
        constructor(e = new Ku, t = new gg) {
            super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
        }

        copy(e) {
            return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
        }

        raycast(e, t) {
            const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, s = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(), yg.copy(n.boundingSphere), yg.applyMatrix4(i), yg.radius += r, !1 === e.ray.intersectsSphere(yg)) return;
            vg.copy(i).invert(), _g.copy(e.ray).applyMatrix4(vg);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a;
            if (n.isBufferGeometry) {
                const r = n.index, a = n.attributes.position;
                if (null !== r) {
                    for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                        const s = r.getX(n);
                        xg.fromBufferAttribute(a, s), wg(xg, s, o, i, e, t, this)
                    }
                } else {
                    for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) xg.fromBufferAttribute(a, n), wg(xg, n, o, i, e, t, this)
                }
            } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }

        updateMorphTargets() {
            const e = this.geometry;
            if (e.isBufferGeometry) {
                const t = e.morphAttributes, n = Object.keys(t);
                if (n.length > 0) {
                    const e = t[n[0]];
                    if (void 0 !== e) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    }
                }
            } else {
                const t = e.morphTargets;
                void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }

    function wg(e, t, n, i, r, s, a) {
        const o = _g.distanceSqToPoint(e);
        if (o < n) {
            const n = new ph;
            _g.closestPointToPoint(e, n), n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far) return;
            s.push({distance: l, distanceToRay: Math.sqrt(o), point: n, index: t, face: null, object: a})
        }
    }

    bg.prototype.isPoints = !0;
    (class extends oh {
        constructor(e, t, n, i, r, s, a, o, l) {
            super(e, t, n, i, r, s, a, o, l), this.format = void 0 !== a ? a : mc, this.minFilter = void 0 !== s ? s : oc, this.magFilter = void 0 !== r ? r : oc, this.generateMipmaps = !1;
            const c = this;
            "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() {
                c.needsUpdate = !0, e.requestVideoFrameCallback(t)
            }))
        }

        clone() {
            return new this.constructor(this.image).copy(this)
        }

        update() {
            const e = this.image;
            !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }).prototype.isVideoTexture = !0;

    class Tg extends oh {
        constructor(e, t, n, i, r, s, a, o, l, c, h, u) {
            super(null, s, a, o, l, c, i, r, h, u), this.image = {
                width: t,
                height: n
            }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
        }
    }

    Tg.prototype.isCompressedTexture = !0;
    (class extends oh {
        constructor(e, t, n, i, r, s, a, o, l) {
            super(e, t, n, i, r, s, a, o, l), this.needsUpdate = !0
        }
    }).prototype.isCanvasTexture = !0;
    (class extends oh {
        constructor(e, t, n, i, r, s, a, o, l, c) {
            if ((c = void 0 !== c ? c : vc) !== vc && c !== _c) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && c === vc && (n = hc), void 0 === n && c === _c && (n = fc), super(null, i, r, s, a, o, c, n, l), this.image = {
                width: e,
                height: t
            }, this.magFilter = void 0 !== a ? a : rc, this.minFilter = void 0 !== o ? o : rc, this.flipY = !1, this.generateMipmaps = !1
        }
    }).prototype.isDepthTexture = !0, new ph, new ph, new ph, new Mu;

    class Sg {
        constructor() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        getPoint() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        }

        getPointAt(e, t) {
            const n = this.getUtoTmapping(e);
            return this.getPoint(n, t)
        }

        getPoints(e = 5) {
            const t = [];
            for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return t
        }

        getSpacedPoints(e = 5) {
            const t = [];
            for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
            return t
        }

        getLength() {
            const e = this.getLengths();
            return e[e.length - 1]
        }

        getLengths(e = this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            const t = [];
            let n, i = this.getPoint(0), r = 0;
            t.push(0);
            for (let s = 1; s <= e; s++) n = this.getPoint(s / e), r += n.distanceTo(i), t.push(r), i = n;
            return this.cacheArcLengths = t, t
        }

        updateArcLengths() {
            this.needsUpdate = !0, this.getLengths()
        }

        getUtoTmapping(e, t) {
            const n = this.getLengths();
            let i = 0;
            const r = n.length;
            let s;
            s = t || e * n[r - 1];
            let a, o = 0, l = r - 1;
            for (; o <= l;) if (i = Math.floor(o + (l - o) / 2), a = n[i] - s, a < 0) o = i + 1; else {
                if (!(a > 0)) {
                    l = i;
                    break
                }
                l = i - 1
            }
            if (i = l, n[i] === s) return i / (r - 1);
            const c = n[i];
            return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
        }

        getTangent(e, t) {
            const n = 1e-4;
            let i = e - n, r = e + n;
            i < 0 && (i = 0), r > 1 && (r = 1);
            const s = this.getPoint(i), a = this.getPoint(r), o = t || (s.isVector2 ? new eh : new ph);
            return o.copy(a).sub(s).normalize(), o
        }

        getTangentAt(e, t) {
            const n = this.getUtoTmapping(e);
            return this.getTangent(n, t)
        }

        computeFrenetFrames(e, t) {
            const n = new ph, i = [], r = [], s = [], a = new ph, o = new Wh;
            for (let t = 0; t <= e; t++) {
                const n = t / e;
                i[t] = this.getTangentAt(n, new ph)
            }
            r[0] = new ph, s[0] = new ph;
            let l = Number.MAX_VALUE;
            const c = Math.abs(i[0].x), h = Math.abs(i[0].y), u = Math.abs(i[0].z);
            c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]);
            for (let t = 1; t <= e; t++) {
                if (r[t] = r[t - 1].clone(), s[t] = s[t - 1].clone(), a.crossVectors(i[t - 1], i[t]), a.length() > Number.EPSILON) {
                    a.normalize();
                    const e = Math.acos(Xc(i[t - 1].dot(i[t]), -1, 1));
                    r[t].applyMatrix4(o.makeRotationAxis(a, e))
                }
                s[t].crossVectors(i[t], r[t])
            }
            if (!0 === t) {
                let t = Math.acos(Xc(r[0].dot(r[e]), -1, 1));
                t /= e, i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
                for (let n = 1; n <= e; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)), s[n].crossVectors(i[n], r[n])
            }
            return {tangents: i, normals: r, binormals: s}
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        copy(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }

        toJSON() {
            const e = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
        }

        fromJSON(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }
    }

    class Eg extends Sg {
        constructor(e = 0, t = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
            super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
        }

        getPoint(e, t) {
            const n = t || new eh, i = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(r) < Number.EPSILON;
            for (; r < 0;) r += i;
            for (; r > i;) r -= i;
            r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
            const a = this.aStartAngle + e * r;
            let o = this.aX + this.xRadius * Math.cos(a), l = this.aY + this.yRadius * Math.sin(a);
            if (0 !== this.aRotation) {
                const e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), n = o - this.aX, i = l - this.aY;
                o = n * e - i * t + this.aX, l = n * t + i * e + this.aY
            }
            return n.set(o, l)
        }

        copy(e) {
            return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
        }

        toJSON() {
            const e = super.toJSON();
            return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
        }

        fromJSON(e) {
            return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
        }
    }

    Eg.prototype.isEllipseCurve = !0;

    class Mg extends Eg {
        constructor(e, t, n, i, r, s) {
            super(e, t, n, n, i, r, s), this.type = "ArcCurve"
        }
    }

    function Ag() {
        let e = 0, t = 0, n = 0, i = 0;

        function r(r, s, a, o) {
            e = r, t = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o
        }

        return {
            initCatmullRom: function (e, t, n, i, s) {
                r(t, n, s * (n - e), s * (i - t))
            }, initNonuniformCatmullRom: function (e, t, n, i, s, a, o) {
                let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a,
                    c = (n - t) / a - (i - t) / (a + o) + (i - n) / o;
                l *= a, c *= a, r(t, n, l, c)
            }, calc: function (r) {
                const s = r * r;
                return e + t * r + n * s + i * (s * r)
            }
        }
    }

    Mg.prototype.isArcCurve = !0;
    const Lg = new ph, Cg = new Ag, Rg = new Ag, Pg = new Ag;

    class Ig extends Sg {
        constructor(e = [], t = !1, n = "centripetal", i = .5) {
            super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i
        }

        getPoint(e, t = new ph) {
            const n = t, i = this.points, r = i.length, s = (r - (this.closed ? 0 : 1)) * e;
            let a, o, l = Math.floor(s), c = s - l;
            this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (Lg.subVectors(i[0], i[1]).add(i[0]), a = Lg);
            const h = i[l % r], u = i[(l + 1) % r];
            if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (Lg.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = Lg), "centripetal" === this.curveType || "chordal" === this.curveType) {
                const e = "chordal" === this.curveType ? .5 : .25;
                let t = Math.pow(a.distanceToSquared(h), e), n = Math.pow(h.distanceToSquared(u), e),
                    i = Math.pow(u.distanceToSquared(o), e);
                n < 1e-4 && (n = 1), t < 1e-4 && (t = n), i < 1e-4 && (i = n), Cg.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, t, n, i), Rg.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, t, n, i), Pg.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, t, n, i)
            } else "catmullrom" === this.curveType && (Cg.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), Rg.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), Pg.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
            return n.set(Cg.calc(c), Rg.calc(c), Pg.calc(c)), n
        }

        copy(e) {
            super.copy(e), this.points = [];
            for (let t = 0, n = e.points.length; t < n; t++) {
                const n = e.points[t];
                this.points.push(n.clone())
            }
            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
        }

        toJSON() {
            const e = super.toJSON();
            e.points = [];
            for (let t = 0, n = this.points.length; t < n; t++) {
                const n = this.points[t];
                e.points.push(n.toArray())
            }
            return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
        }

        fromJSON(e) {
            super.fromJSON(e), this.points = [];
            for (let t = 0, n = e.points.length; t < n; t++) {
                const n = e.points[t];
                this.points.push((new ph).fromArray(n))
            }
            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
        }
    }

    function Og(e, t, n, i, r) {
        const s = .5 * (i - t), a = .5 * (r - n), o = e * e;
        return (2 * n - 2 * i + s + a) * (e * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * e + n
    }

    function Dg(e, t, n, i) {
        return function (e, t) {
            const n = 1 - e;
            return n * n * t
        }(e, t) + function (e, t) {
            return 2 * (1 - e) * e * t
        }(e, n) + function (e, t) {
            return e * e * t
        }(e, i)
    }

    function Ng(e, t, n, i, r) {
        return function (e, t) {
            const n = 1 - e;
            return n * n * n * t
        }(e, t) + function (e, t) {
            const n = 1 - e;
            return 3 * n * n * e * t
        }(e, n) + function (e, t) {
            return 3 * (1 - e) * e * e * t
        }(e, i) + function (e, t) {
            return e * e * e * t
        }(e, r)
    }

    Ig.prototype.isCatmullRomCurve3 = !0;

    class Bg extends Sg {
        constructor(e = new eh, t = new eh, n = new eh, i = new eh) {
            super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
        }

        getPoint(e, t = new eh) {
            const n = t, i = this.v0, r = this.v1, s = this.v2, a = this.v3;
            return n.set(Ng(e, i.x, r.x, s.x, a.x), Ng(e, i.y, r.y, s.y, a.y)), n
        }

        copy(e) {
            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
        }

        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
        }

        fromJSON(e) {
            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
        }
    }

    Bg.prototype.isCubicBezierCurve = !0;

    class kg extends Sg {
        constructor(e = new ph, t = new ph, n = new ph, i = new ph) {
            super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
        }

        getPoint(e, t = new ph) {
            const n = t, i = this.v0, r = this.v1, s = this.v2, a = this.v3;
            return n.set(Ng(e, i.x, r.x, s.x, a.x), Ng(e, i.y, r.y, s.y, a.y), Ng(e, i.z, r.z, s.z, a.z)), n
        }

        copy(e) {
            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
        }

        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
        }

        fromJSON(e) {
            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
        }
    }

    kg.prototype.isCubicBezierCurve3 = !0;

    class Ug extends Sg {
        constructor(e = new eh, t = new eh) {
            super(), this.type = "LineCurve", this.v1 = e, this.v2 = t
        }

        getPoint(e, t = new eh) {
            const n = t;
            return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
        }

        getPointAt(e, t) {
            return this.getPoint(e, t)
        }

        getTangent(e, t) {
            const n = t || new eh;
            return n.copy(this.v2).sub(this.v1).normalize(), n
        }

        copy(e) {
            return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }

        toJSON() {
            const e = super.toJSON();
            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }

        fromJSON(e) {
            return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }
    }

    Ug.prototype.isLineCurve = !0;

    class Fg extends Sg {
        constructor(e = new eh, t = new eh, n = new eh) {
            super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
        }

        getPoint(e, t = new eh) {
            const n = t, i = this.v0, r = this.v1, s = this.v2;
            return n.set(Dg(e, i.x, r.x, s.x), Dg(e, i.y, r.y, s.y)), n
        }

        copy(e) {
            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }

        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }

        fromJSON(e) {
            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }
    }

    Fg.prototype.isQuadraticBezierCurve = !0;

    class Hg extends Sg {
        constructor(e = new ph, t = new ph, n = new ph) {
            super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
        }

        getPoint(e, t = new ph) {
            const n = t, i = this.v0, r = this.v1, s = this.v2;
            return n.set(Dg(e, i.x, r.x, s.x), Dg(e, i.y, r.y, s.y), Dg(e, i.z, r.z, s.z)), n
        }

        copy(e) {
            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }

        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }

        fromJSON(e) {
            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }
    }

    Hg.prototype.isQuadraticBezierCurve3 = !0;

    class zg extends Sg {
        constructor(e = []) {
            super(), this.type = "SplineCurve", this.points = e
        }

        getPoint(e, t = new eh) {
            const n = t, i = this.points, r = (i.length - 1) * e, s = Math.floor(r), a = r - s,
                o = i[0 === s ? s : s - 1], l = i[s], c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                h = i[s > i.length - 3 ? i.length - 1 : s + 2];
            return n.set(Og(a, o.x, l.x, c.x, h.x), Og(a, o.y, l.y, c.y, h.y)), n
        }

        copy(e) {
            super.copy(e), this.points = [];
            for (let t = 0, n = e.points.length; t < n; t++) {
                const n = e.points[t];
                this.points.push(n.clone())
            }
            return this
        }

        toJSON() {
            const e = super.toJSON();
            e.points = [];
            for (let t = 0, n = this.points.length; t < n; t++) {
                const n = this.points[t];
                e.points.push(n.toArray())
            }
            return e
        }

        fromJSON(e) {
            super.fromJSON(e), this.points = [];
            for (let t = 0, n = e.points.length; t < n; t++) {
                const n = e.points[t];
                this.points.push((new eh).fromArray(n))
            }
            return this
        }
    }

    zg.prototype.isSplineCurve = !0;
    var Gg = Object.freeze({
        __proto__: null,
        ArcCurve: Mg,
        CatmullRomCurve3: Ig,
        CubicBezierCurve: Bg,
        CubicBezierCurve3: kg,
        EllipseCurve: Eg,
        LineCurve: Ug,
        LineCurve3: class extends Sg {
            constructor(e = new ph, t = new ph) {
                super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t
            }

            getPoint(e, t = new ph) {
                const n = t;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }

            getPointAt(e, t) {
                return this.getPoint(e, t)
            }

            copy(e) {
                return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }

            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }

            fromJSON(e) {
                return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        },
        QuadraticBezierCurve: Fg,
        QuadraticBezierCurve3: Hg,
        SplineCurve: zg
    });

    class Vg extends Sg {
        constructor() {
            super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        add(e) {
            this.curves.push(e)
        }

        closePath() {
            const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Ug(t, e))
        }

        getPoint(e, t) {
            const n = e * this.getLength(), i = this.getCurveLengths();
            let r = 0;
            for (; r < i.length;) {
                if (i[r] >= n) {
                    const e = i[r] - n, s = this.curves[r], a = s.getLength(), o = 0 === a ? 0 : 1 - e / a;
                    return s.getPointAt(o, t)
                }
                r++
            }
            return null
        }

        getLength() {
            const e = this.getCurveLengths();
            return e[e.length - 1]
        }

        updateArcLengths() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        }

        getCurveLengths() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            const e = [];
            let t = 0;
            for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
            return this.cacheLengths = e, e
        }

        getSpacedPoints(e = 40) {
            const t = [];
            for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]), t
        }

        getPoints(e = 12) {
            const t = [];
            let n;
            for (let i = 0, r = this.curves; i < r.length; i++) {
                const s = r[i],
                    a = s && s.isEllipseCurve ? 2 * e : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e,
                    o = s.getPoints(a);
                for (let e = 0; e < o.length; e++) {
                    const i = o[e];
                    n && n.equals(i) || (t.push(i), n = i)
                }
            }
            return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
        }

        copy(e) {
            super.copy(e), this.curves = [];
            for (let t = 0, n = e.curves.length; t < n; t++) {
                const n = e.curves[t];
                this.curves.push(n.clone())
            }
            return this.autoClose = e.autoClose, this
        }

        toJSON() {
            const e = super.toJSON();
            e.autoClose = this.autoClose, e.curves = [];
            for (let t = 0, n = this.curves.length; t < n; t++) {
                const n = this.curves[t];
                e.curves.push(n.toJSON())
            }
            return e
        }

        fromJSON(e) {
            super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
            for (let t = 0, n = e.curves.length; t < n; t++) {
                const n = e.curves[t];
                this.curves.push((new Gg[n.type]).fromJSON(n))
            }
            return this
        }
    }

    class Wg extends Vg {
        constructor(e) {
            super(), this.type = "Path", this.currentPoint = new eh, e && this.setFromPoints(e)
        }

        setFromPoints(e) {
            this.moveTo(e[0].x, e[0].y);
            for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
            return this
        }

        moveTo(e, t) {
            return this.currentPoint.set(e, t), this
        }

        lineTo(e, t) {
            const n = new Ug(this.currentPoint.clone(), new eh(e, t));
            return this.curves.push(n), this.currentPoint.set(e, t), this
        }

        quadraticCurveTo(e, t, n, i) {
            const r = new Fg(this.currentPoint.clone(), new eh(e, t), new eh(n, i));
            return this.curves.push(r), this.currentPoint.set(n, i), this
        }

        bezierCurveTo(e, t, n, i, r, s) {
            const a = new Bg(this.currentPoint.clone(), new eh(e, t), new eh(n, i), new eh(r, s));
            return this.curves.push(a), this.currentPoint.set(r, s), this
        }

        splineThru(e) {
            const t = [this.currentPoint.clone()].concat(e), n = new zg(t);
            return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
        }

        arc(e, t, n, i, r, s) {
            const a = this.currentPoint.x, o = this.currentPoint.y;
            return this.absarc(e + a, t + o, n, i, r, s), this
        }

        absarc(e, t, n, i, r, s) {
            return this.absellipse(e, t, n, n, i, r, s), this
        }

        ellipse(e, t, n, i, r, s, a, o) {
            const l = this.currentPoint.x, c = this.currentPoint.y;
            return this.absellipse(e + l, t + c, n, i, r, s, a, o), this
        }

        absellipse(e, t, n, i, r, s, a, o) {
            const l = new Eg(e, t, n, i, r, s, a, o);
            if (this.curves.length > 0) {
                const e = l.getPoint(0);
                e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
            }
            this.curves.push(l);
            const c = l.getPoint(1);
            return this.currentPoint.copy(c), this
        }

        copy(e) {
            return super.copy(e), this.currentPoint.copy(e.currentPoint), this
        }

        toJSON() {
            const e = super.toJSON();
            return e.currentPoint = this.currentPoint.toArray(), e
        }

        fromJSON(e) {
            return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
        }
    }

    class jg extends Wg {
        constructor(e) {
            super(e), this.uuid = $c(), this.type = "Shape", this.holes = []
        }

        getPointsHoles(e) {
            const t = [];
            for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
            return t
        }

        extractPoints(e) {
            return {shape: this.getPoints(e), holes: this.getPointsHoles(e)}
        }

        copy(e) {
            super.copy(e), this.holes = [];
            for (let t = 0, n = e.holes.length; t < n; t++) {
                const n = e.holes[t];
                this.holes.push(n.clone())
            }
            return this
        }

        toJSON() {
            const e = super.toJSON();
            e.uuid = this.uuid, e.holes = [];
            for (let t = 0, n = this.holes.length; t < n; t++) {
                const n = this.holes[t];
                e.holes.push(n.toJSON())
            }
            return e
        }

        fromJSON(e) {
            super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
            for (let t = 0, n = e.holes.length; t < n; t++) {
                const n = e.holes[t];
                this.holes.push((new Wg).fromJSON(n))
            }
            return this
        }
    }

    const $g = function (e, t, n = 2) {
        const i = t && t.length, r = i ? t[0] * n : e.length;
        let s = Xg(e, 0, r, n, !0);
        const a = [];
        if (!s || s.next === s.prev) return a;
        let o, l, c, h, u, d, p;
        if (i && (s = function (e, t, n, i) {
            const r = [];
            let s, a, o, l, c;
            for (s = 0, a = t.length; s < a; s++) o = t[s] * i, l = s < a - 1 ? t[s + 1] * i : e.length, c = Xg(e, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(rv(c));
            for (r.sort(ev), s = 0; s < r.length; s++) tv(r[s], n), n = qg(n, n.next);
            return n
        }(e, t, s, n)), e.length > 80 * n) {
            o = c = e[0], l = h = e[1];
            for (let t = n; t < r; t += n) u = e[t], d = e[t + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
            p = Math.max(c - o, h - l), p = 0 !== p ? 1 / p : 0
        }
        return Yg(s, a, n, o, l, p), a
    };

    function Xg(e, t, n, i, r) {
        let s, a;
        if (r === function (e, t, n, i) {
            let r = 0;
            for (let s = t, a = n - i; s < n; s += i) r += (e[a] - e[s]) * (e[s + 1] + e[a + 1]), a = s;
            return r
        }(e, t, n, i) > 0) for (s = t; s < n; s += i) a = fv(s, e[s], e[s + 1], a); else for (s = n - i; s >= t; s -= i) a = fv(s, e[s], e[s + 1], a);
        return a && lv(a, a.next) && (mv(a), a = a.next), a
    }

    function qg(e, t) {
        if (!e) return e;
        t || (t = e);
        let n, i = e;
        do {
            if (n = !1, i.steiner || !lv(i, i.next) && 0 !== ov(i.prev, i, i.next)) i = i.next; else {
                if (mv(i), i = t = i.prev, i === i.next) break;
                n = !0
            }
        } while (n || i !== t);
        return t
    }

    function Yg(e, t, n, i, r, s, a) {
        if (!e) return;
        !a && s && function (e, t, n, i) {
            let r = e;
            do {
                null === r.z && (r.z = iv(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
            } while (r !== e);
            r.prevZ.nextZ = null, r.prevZ = null, function (e) {
                let t, n, i, r, s, a, o, l, c = 1;
                do {
                    for (n = e, e = null, s = null, a = 0; n;) {
                        for (a++, i = n, o = 0, t = 0; t < c && (o++, i = i.nextZ, i); t++) ;
                        for (l = c; o > 0 || l > 0 && i;) 0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, o--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : e = r, r.prevZ = s, s = r;
                        n = i
                    }
                    s.nextZ = null, c *= 2
                } while (a > 1)
            }(r)
        }(e, i, r, s);
        let o, l, c = e;
        for (; e.prev !== e.next;) if (o = e.prev, l = e.next, s ? Jg(e, i, r, s) : Kg(e)) t.push(o.i / n), t.push(e.i / n), t.push(l.i / n), mv(e), e = l.next, c = l.next; else if ((e = l) === c) {
            a ? 1 === a ? Yg(e = Zg(qg(e), t, n), t, n, i, r, s, 2) : 2 === a && Qg(e, t, n, i, r, s) : Yg(qg(e), t, n, i, r, s, 1);
            break
        }
    }

    function Kg(e) {
        const t = e.prev, n = e, i = e.next;
        if (ov(t, n, i) >= 0) return !1;
        let r = e.next.next;
        for (; r !== e.prev;) {
            if (sv(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && ov(r.prev, r, r.next) >= 0) return !1;
            r = r.next
        }
        return !0
    }

    function Jg(e, t, n, i) {
        const r = e.prev, s = e, a = e.next;
        if (ov(r, s, a) >= 0) return !1;
        const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x,
            l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y,
            c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x,
            h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y, u = iv(o, l, t, n, i), d = iv(c, h, t, n, i);
        let p = e.prevZ, f = e.nextZ;
        for (; p && p.z >= u && f && f.z <= d;) {
            if (p !== e.prev && p !== e.next && sv(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && ov(p.prev, p, p.next) >= 0) return !1;
            if (p = p.prevZ, f !== e.prev && f !== e.next && sv(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && ov(f.prev, f, f.next) >= 0) return !1;
            f = f.nextZ
        }
        for (; p && p.z >= u;) {
            if (p !== e.prev && p !== e.next && sv(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && ov(p.prev, p, p.next) >= 0) return !1;
            p = p.prevZ
        }
        for (; f && f.z <= d;) {
            if (f !== e.prev && f !== e.next && sv(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && ov(f.prev, f, f.next) >= 0) return !1;
            f = f.nextZ
        }
        return !0
    }

    function Zg(e, t, n) {
        let i = e;
        do {
            const r = i.prev, s = i.next.next;
            !lv(r, s) && cv(r, i, i.next, s) && dv(r, s) && dv(s, r) && (t.push(r.i / n), t.push(i.i / n), t.push(s.i / n), mv(i), mv(i.next), i = e = s), i = i.next
        } while (i !== e);
        return qg(i)
    }

    function Qg(e, t, n, i, r, s) {
        let a = e;
        do {
            let e = a.next.next;
            for (; e !== a.prev;) {
                if (a.i !== e.i && av(a, e)) {
                    let o = pv(a, e);
                    return a = qg(a, a.next), o = qg(o, o.next), Yg(a, t, n, i, r, s), void Yg(o, t, n, i, r, s)
                }
                e = e.next
            }
            a = a.next
        } while (a !== e)
    }

    function ev(e, t) {
        return e.x - t.x
    }

    function tv(e, t) {
        if (t = function (e, t) {
            let n = t;
            const i = e.x, r = e.y;
            let s, a = -1 / 0;
            do {
                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                    const e = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    if (e <= i && e > a) {
                        if (a = e, e === i) {
                            if (r === n.y) return n;
                            if (r === n.next.y) return n.next
                        }
                        s = n.x < n.next.x ? n : n.next
                    }
                }
                n = n.next
            } while (n !== t);
            if (!s) return null;
            if (i === a) return s;
            const o = s, l = s.x, c = s.y;
            let h, u = 1 / 0;
            n = s;
            do {
                i >= n.x && n.x >= l && i !== n.x && sv(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), dv(n, e) && (h < u || h === u && (n.x > s.x || n.x === s.x && nv(s, n))) && (s = n, u = h)), n = n.next
            } while (n !== o);
            return s
        }(e, t), t) {
            const n = pv(t, e);
            qg(t, t.next), qg(n, n.next)
        }
    }

    function nv(e, t) {
        return ov(e.prev, e, t.prev) < 0 && ov(t.next, e, e.next) < 0
    }

    function iv(e, t, n, i, r) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }

    function rv(e) {
        let t = e, n = e;
        do {
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
        } while (t !== e);
        return n
    }

    function sv(e, t, n, i, r, s, a, o) {
        return (r - a) * (t - o) - (e - a) * (s - o) >= 0 && (e - a) * (i - o) - (n - a) * (t - o) >= 0 && (n - a) * (s - o) - (r - a) * (i - o) >= 0
    }

    function av(e, t) {
        return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) {
            let n = e;
            do {
                if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && cv(n, n.next, e, t)) return !0;
                n = n.next
            } while (n !== e);
            return !1
        }(e, t) && (dv(e, t) && dv(t, e) && function (e, t) {
            let n = e, i = !1;
            const r = (e.x + t.x) / 2, s = (e.y + t.y) / 2;
            do {
                n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
            } while (n !== e);
            return i
        }(e, t) && (ov(e.prev, e, t.prev) || ov(e, t.prev, t)) || lv(e, t) && ov(e.prev, e, e.next) > 0 && ov(t.prev, t, t.next) > 0)
    }

    function ov(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
    }

    function lv(e, t) {
        return e.x === t.x && e.y === t.y
    }

    function cv(e, t, n, i) {
        const r = uv(ov(e, t, n)), s = uv(ov(e, t, i)), a = uv(ov(n, i, e)), o = uv(ov(n, i, t));
        return r !== s && a !== o || (!(0 !== r || !hv(e, n, t)) || (!(0 !== s || !hv(e, i, t)) || (!(0 !== a || !hv(n, e, i)) || !(0 !== o || !hv(n, t, i)))))
    }

    function hv(e, t, n) {
        return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
    }

    function uv(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0
    }

    function dv(e, t) {
        return ov(e.prev, e, e.next) < 0 ? ov(e, t, e.next) >= 0 && ov(e, e.prev, t) >= 0 : ov(e, t, e.prev) < 0 || ov(e, e.next, t) < 0
    }

    function pv(e, t) {
        const n = new gv(e.i, e.x, e.y), i = new gv(t.i, t.x, t.y), r = e.next, s = t.prev;
        return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
    }

    function fv(e, t, n, i) {
        const r = new gv(e, t, n);
        return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
    }

    function mv(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }

    function gv(e, t, n) {
        this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }

    class vv {
        static area(e) {
            const t = e.length;
            let n = 0;
            for (let i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
            return .5 * n
        }

        static isClockWise(e) {
            return vv.area(e) < 0
        }

        static triangulateShape(e, t) {
            const n = [], i = [], r = [];
            _v(e), yv(n, e);
            let s = e.length;
            t.forEach(_v);
            for (let e = 0; e < t.length; e++) i.push(s), s += t[e].length, yv(n, t[e]);
            const a = $g(n, i);
            for (let e = 0; e < a.length; e += 3) r.push(a.slice(e, e + 3));
            return r
        }
    }

    function _v(e) {
        const t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop()
    }

    function yv(e, t) {
        for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
    }

    class xv extends Ku {
        constructor(e = new jg([new eh(.5, .5), new eh(-.5, .5), new eh(-.5, -.5), new eh(.5, -.5)]), t = {}) {
            super(), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: e,
                options: t
            }, e = Array.isArray(e) ? e : [e];
            const n = this, i = [], r = [];
            for (let t = 0, n = e.length; t < n; t++) {
                s(e[t])
            }

            function s(e) {
                const s = [], a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                    o = void 0 !== t.steps ? t.steps : 1;
                let l = void 0 !== t.depth ? t.depth : 1, c = void 0 === t.bevelEnabled || t.bevelEnabled,
                    h = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
                    u = void 0 !== t.bevelSize ? t.bevelSize : h - .1, d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                    p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
                const f = t.extrudePath, m = void 0 !== t.UVGenerator ? t.UVGenerator : bv;
                void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount);
                let g, v, _, y, x, b = !1;
                f && (g = f.getSpacedPoints(o), b = !0, c = !1, v = f.computeFrenetFrames(o, !1), _ = new ph, y = new ph, x = new ph), c || (p = 0, h = 0, u = 0, d = 0);
                const w = e.extractPoints(a);
                let T = w.shape;
                const S = w.holes;
                if (!vv.isClockWise(T)) {
                    T = T.reverse();
                    for (let e = 0, t = S.length; e < t; e++) {
                        const t = S[e];
                        vv.isClockWise(t) && (S[e] = t.reverse())
                    }
                }
                const E = vv.triangulateShape(T, S), M = T;
                for (let e = 0, t = S.length; e < t; e++) {
                    const t = S[e];
                    T = T.concat(t)
                }

                function A(e, t, n) {
                    return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                }

                const L = T.length, C = E.length;

                function R(e, t, n) {
                    let i, r, s;
                    const a = e.x - t.x, o = e.y - t.y, l = n.x - e.x, c = n.y - e.y, h = a * a + o * o,
                        u = a * c - o * l;
                    if (Math.abs(u) > Number.EPSILON) {
                        const u = Math.sqrt(h), d = Math.sqrt(l * l + c * c), p = t.x - o / u, f = t.y + a / u,
                            m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (a * c - o * l);
                        i = p + a * m - e.x, r = f + o * m - e.y;
                        const g = i * i + r * r;
                        if (g <= 2) return new eh(i, r);
                        s = Math.sqrt(g / 2)
                    } else {
                        let e = !1;
                        a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(c) && (e = !0), e ? (i = -o, r = a, s = Math.sqrt(h)) : (i = a, r = o, s = Math.sqrt(h / 2))
                    }
                    return new eh(i / s, r / s)
                }

                const P = [];
                for (let e = 0, t = M.length, n = t - 1, i = e + 1; e < t; e++, n++, i++) n === t && (n = 0), i === t && (i = 0), P[e] = R(M[e], M[n], M[i]);
                const I = [];
                let O, D = P.concat();
                for (let e = 0, t = S.length; e < t; e++) {
                    const t = S[e];
                    O = [];
                    for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++, i++, r++) i === n && (i = 0), r === n && (r = 0), O[e] = R(t[e], t[i], t[r]);
                    I.push(O), D = D.concat(O)
                }
                for (let e = 0; e < p; e++) {
                    const t = e / p, n = h * Math.cos(t * Math.PI / 2), i = u * Math.sin(t * Math.PI / 2) + d;
                    for (let e = 0, t = M.length; e < t; e++) {
                        const t = A(M[e], P[e], i);
                        k(t.x, t.y, -n)
                    }
                    for (let e = 0, t = S.length; e < t; e++) {
                        const t = S[e];
                        O = I[e];
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = A(t[e], O[e], i);
                            k(r.x, r.y, -n)
                        }
                    }
                }
                const N = u + d;
                for (let e = 0; e < L; e++) {
                    const t = c ? A(T[e], D[e], N) : T[e];
                    b ? (y.copy(v.normals[0]).multiplyScalar(t.x), _.copy(v.binormals[0]).multiplyScalar(t.y), x.copy(g[0]).add(y).add(_), k(x.x, x.y, x.z)) : k(t.x, t.y, 0)
                }
                for (let e = 1; e <= o; e++) for (let t = 0; t < L; t++) {
                    const n = c ? A(T[t], D[t], N) : T[t];
                    b ? (y.copy(v.normals[e]).multiplyScalar(n.x), _.copy(v.binormals[e]).multiplyScalar(n.y), x.copy(g[e]).add(y).add(_), k(x.x, x.y, x.z)) : k(n.x, n.y, l / o * e)
                }
                for (let e = p - 1; e >= 0; e--) {
                    const t = e / p, n = h * Math.cos(t * Math.PI / 2), i = u * Math.sin(t * Math.PI / 2) + d;
                    for (let e = 0, t = M.length; e < t; e++) {
                        const t = A(M[e], P[e], i);
                        k(t.x, t.y, l + n)
                    }
                    for (let e = 0, t = S.length; e < t; e++) {
                        const t = S[e];
                        O = I[e];
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = A(t[e], O[e], i);
                            b ? k(r.x, r.y + g[o - 1].y, g[o - 1].x + n) : k(r.x, r.y, l + n)
                        }
                    }
                }

                function B(e, t) {
                    let n = e.length;
                    for (; --n >= 0;) {
                        const i = n;
                        let r = n - 1;
                        r < 0 && (r = e.length - 1);
                        for (let e = 0, n = o + 2 * p; e < n; e++) {
                            const n = L * e, s = L * (e + 1);
                            F(t + i + n, t + r + n, t + r + s, t + i + s)
                        }
                    }
                }

                function k(e, t, n) {
                    s.push(e), s.push(t), s.push(n)
                }

                function U(e, t, r) {
                    H(e), H(t), H(r);
                    const s = i.length / 3, a = m.generateTopUV(n, i, s - 3, s - 2, s - 1);
                    z(a[0]), z(a[1]), z(a[2])
                }

                function F(e, t, r, s) {
                    H(e), H(t), H(s), H(t), H(r), H(s);
                    const a = i.length / 3, o = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                    z(o[0]), z(o[1]), z(o[3]), z(o[1]), z(o[2]), z(o[3])
                }

                function H(e) {
                    i.push(s[3 * e + 0]), i.push(s[3 * e + 1]), i.push(s[3 * e + 2])
                }

                function z(e) {
                    r.push(e.x), r.push(e.y)
                }

                !function () {
                    const e = i.length / 3;
                    if (c) {
                        let e = 0, t = L * e;
                        for (let e = 0; e < C; e++) {
                            const n = E[e];
                            U(n[2] + t, n[1] + t, n[0] + t)
                        }
                        e = o + 2 * p, t = L * e;
                        for (let e = 0; e < C; e++) {
                            const n = E[e];
                            U(n[0] + t, n[1] + t, n[2] + t)
                        }
                    } else {
                        for (let e = 0; e < C; e++) {
                            const t = E[e];
                            U(t[2], t[1], t[0])
                        }
                        for (let e = 0; e < C; e++) {
                            const t = E[e];
                            U(t[0] + L * o, t[1] + L * o, t[2] + L * o)
                        }
                    }
                    n.addGroup(e, i.length / 3 - e, 0)
                }(), function () {
                    const e = i.length / 3;
                    let t = 0;
                    B(M, t), t += M.length;
                    for (let e = 0, n = S.length; e < n; e++) {
                        const n = S[e];
                        B(n, t), t += n.length
                    }
                    n.addGroup(e, i.length / 3 - e, 1)
                }()
            }

            this.setAttribute("position", new Gu(i, 3)), this.setAttribute("uv", new Gu(r, 2)), this.computeVertexNormals()
        }

        toJSON() {
            const e = super.toJSON();
            return function (e, t, n) {
                if (n.shapes = [], Array.isArray(e)) for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    n.shapes.push(i.uuid)
                } else n.shapes.push(e.uuid);
                void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON());
                return n
            }(this.parameters.shapes, this.parameters.options, e)
        }

        static fromJSON(e, t) {
            const n = [];
            for (let i = 0, r = e.shapes.length; i < r; i++) {
                const r = t[e.shapes[i]];
                n.push(r)
            }
            const i = e.options.extrudePath;
            return void 0 !== i && (e.options.extrudePath = (new Gg[i.type]).fromJSON(i)), new xv(n, e.options)
        }
    }

    const bv = {
        generateTopUV: function (e, t, n, i, r) {
            const s = t[3 * n], a = t[3 * n + 1], o = t[3 * i], l = t[3 * i + 1], c = t[3 * r], h = t[3 * r + 1];
            return [new eh(s, a), new eh(o, l), new eh(c, h)]
        }, generateSideWallUV: function (e, t, n, i, r, s) {
            const a = t[3 * n], o = t[3 * n + 1], l = t[3 * n + 2], c = t[3 * i], h = t[3 * i + 1], u = t[3 * i + 2],
                d = t[3 * r], p = t[3 * r + 1], f = t[3 * r + 2], m = t[3 * s], g = t[3 * s + 1], v = t[3 * s + 2];
            return Math.abs(o - h) < Math.abs(a - c) ? [new eh(a, 1 - l), new eh(c, 1 - u), new eh(d, 1 - f), new eh(m, 1 - v)] : [new eh(o, 1 - l), new eh(h, 1 - u), new eh(p, 1 - f), new eh(g, 1 - v)]
        }
    };

    class wv extends Ku {
        constructor(e = new jg([new eh(0, .5), new eh(-.5, -.5), new eh(.5, -.5)]), t = 12) {
            super(), this.type = "ShapeGeometry", this.parameters = {shapes: e, curveSegments: t};
            const n = [], i = [], r = [], s = [];
            let a = 0, o = 0;
            if (!1 === Array.isArray(e)) l(e); else for (let t = 0; t < e.length; t++) l(e[t]), this.addGroup(a, o, t), a += o, o = 0;

            function l(e) {
                const a = i.length / 3, l = e.extractPoints(t);
                let c = l.shape;
                const h = l.holes;
                !1 === vv.isClockWise(c) && (c = c.reverse());
                for (let e = 0, t = h.length; e < t; e++) {
                    const t = h[e];
                    !0 === vv.isClockWise(t) && (h[e] = t.reverse())
                }
                const u = vv.triangulateShape(c, h);
                for (let e = 0, t = h.length; e < t; e++) {
                    const t = h[e];
                    c = c.concat(t)
                }
                for (let e = 0, t = c.length; e < t; e++) {
                    const t = c[e];
                    i.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y)
                }
                for (let e = 0, t = u.length; e < t; e++) {
                    const t = u[e], i = t[0] + a, r = t[1] + a, s = t[2] + a;
                    n.push(i, r, s), o += 3
                }
            }

            this.setIndex(n), this.setAttribute("position", new Gu(i, 3)), this.setAttribute("normal", new Gu(r, 3)), this.setAttribute("uv", new Gu(s, 2))
        }

        toJSON() {
            const e = super.toJSON();
            return function (e, t) {
                if (t.shapes = [], Array.isArray(e)) for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    t.shapes.push(i.uuid)
                } else t.shapes.push(e.uuid);
                return t
            }(this.parameters.shapes, e)
        }

        static fromJSON(e, t) {
            const n = [];
            for (let i = 0, r = e.shapes.length; i < r; i++) {
                const r = t[e.shapes[i]];
                n.push(r)
            }
            return new wv(n, e.curveSegments)
        }
    }

    (class extends Lu {
        constructor(e) {
            super(), this.type = "ShadowMaterial", this.color = new Nu(0), this.transparent = !0, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this
        }
    }).prototype.isShadowMaterial = !0;

    class Tv extends Lu {
        constructor(e) {
            super(), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new Nu(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Nu(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new eh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.defines = {STANDARD: ""}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
        }
    }

    Tv.prototype.isMeshStandardMaterial = !0;

    class Sv extends Tv {
        constructor(e) {
            super(), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new eh(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function () {
                    return Xc(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                }, set: function (e) {
                    this.ior = (1 + .4 * e) / (1 - .4 * e)
                }
            }), this.sheenTint = new Nu(0), this.sheenRoughness = 1, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new Nu(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new Nu(1, 1, 1), this.specularTintMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e)
        }

        get sheen() {
            return this._sheen
        }

        set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++, this._sheen = e
        }

        get clearcoat() {
            return this._clearcoat
        }

        set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
        }

        get transmission() {
            return this._transmission
        }

        set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++, this._transmission = e
        }

        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenTint.copy(e.sheenTint), this.sheenRoughness = e.sheenRoughness, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationTint.copy(e.attenuationTint), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularTint.copy(e.specularTint), this.specularTintMap = e.specularTintMap, this
        }
    }

    Sv.prototype.isMeshPhysicalMaterial = !0;
    (class extends Lu {
        constructor(e) {
            super(), this.type = "MeshPhongMaterial", this.color = new Nu(16777215), this.specular = new Nu(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Nu(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new eh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
        }
    }).prototype.isMeshPhongMaterial = !0;
    (class extends Lu {
        constructor(e) {
            super(), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.color = new Nu(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Nu(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new eh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
        }
    }).prototype.isMeshToonMaterial = !0;
    (class extends Lu {
        constructor(e) {
            super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new eh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
        }
    }).prototype.isMeshNormalMaterial = !0;
    (class extends Lu {
        constructor(e) {
            super(), this.type = "MeshLambertMaterial", this.color = new Nu(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Nu(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
        }
    }).prototype.isMeshLambertMaterial = !0;

    class Ev extends Lu {
        constructor(e) {
            super(), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new Nu(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new eh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.defines = {MATCAP: ""}, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this
        }
    }

    Ev.prototype.isMeshMatcapMaterial = !0;
    (class extends sg {
        constructor(e) {
            super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
        }
    }).prototype.isLineDashedMaterial = !0;
    const Mv = {
        arraySlice: function (e, t, n) {
            return Mv.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
        }, convertArray: function (e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        }, isTypedArray: function (e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }, getKeyframeOrder: function (e) {
            const t = e.length, n = new Array(t);
            for (let e = 0; e !== t; ++e) n[e] = e;
            return n.sort((function (t, n) {
                return e[t] - e[n]
            })), n
        }, sortedArray: function (e, t, n) {
            const i = e.length, r = new e.constructor(i);
            for (let s = 0, a = 0; a !== i; ++s) {
                const i = n[s] * t;
                for (let n = 0; n !== t; ++n) r[a++] = e[i + n]
            }
            return r
        }, flattenJSON: function (e, t, n, i) {
            let r = 1, s = e[0];
            for (; void 0 !== s && void 0 === s[i];) s = e[r++];
            if (void 0 === s) return;
            let a = s[i];
            if (void 0 !== a) if (Array.isArray(a)) do {
                a = s[i], void 0 !== a && (t.push(s.time), n.push.apply(n, a)), s = e[r++]
            } while (void 0 !== s); else if (void 0 !== a.toArray) do {
                a = s[i], void 0 !== a && (t.push(s.time), a.toArray(n, n.length)), s = e[r++]
            } while (void 0 !== s); else do {
                a = s[i], void 0 !== a && (t.push(s.time), n.push(a)), s = e[r++]
            } while (void 0 !== s)
        }, subclip: function (e, t, n, i, r = 30) {
            const s = e.clone();
            s.name = t;
            const a = [];
            for (let e = 0; e < s.tracks.length; ++e) {
                const t = s.tracks[e], o = t.getValueSize(), l = [], c = [];
                for (let e = 0; e < t.times.length; ++e) {
                    const s = t.times[e] * r;
                    if (!(s < n || s >= i)) {
                        l.push(t.times[e]);
                        for (let n = 0; n < o; ++n) c.push(t.values[e * o + n])
                    }
                }
                0 !== l.length && (t.times = Mv.convertArray(l, t.times.constructor), t.values = Mv.convertArray(c, t.values.constructor), a.push(t))
            }
            s.tracks = a;
            let o = 1 / 0;
            for (let e = 0; e < s.tracks.length; ++e) o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
            for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * o);
            return s.resetDuration(), s
        }, makeClipAdditive: function (e, t = 0, n = e, i = 30) {
            i <= 0 && (i = 30);
            const r = n.tracks.length, s = t / i;
            for (let t = 0; t < r; ++t) {
                const i = n.tracks[t], r = i.ValueTypeName;
                if ("bool" === r || "string" === r) continue;
                const a = e.tracks.find((function (e) {
                    return e.name === i.name && e.ValueTypeName === r
                }));
                if (void 0 === a) continue;
                let o = 0;
                const l = i.getValueSize();
                i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                let c = 0;
                const h = a.getValueSize();
                a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                const u = i.times.length - 1;
                let d;
                if (s <= i.times[0]) {
                    const e = o, t = l - o;
                    d = Mv.arraySlice(i.values, e, t)
                } else if (s >= i.times[u]) {
                    const e = u * l + o, t = e + l - o;
                    d = Mv.arraySlice(i.values, e, t)
                } else {
                    const e = i.createInterpolant(), t = o, n = l - o;
                    e.evaluate(s), d = Mv.arraySlice(e.resultBuffer, t, n)
                }
                if ("quaternion" === r) {
                    (new dh).fromArray(d).normalize().conjugate().toArray(d)
                }
                const p = a.times.length;
                for (let e = 0; e < p; ++e) {
                    const t = e * h + c;
                    if ("quaternion" === r) dh.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t); else {
                        const e = h - 2 * c;
                        for (let n = 0; n < e; ++n) a.values[t + n] -= d[n]
                    }
                }
            }
            return e.blendMode = 2501, e
        }
    };

    class Av {
        constructor(e, t, n, i) {
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
        }

        evaluate(e) {
            const t = this.parameterPositions;
            let n = this._cachedIndex, i = t[n], r = t[n - 1];
            e:{
                t:{
                    let s;
                    n:{
                        i:if (!(e < i)) {
                            for (let s = n + 2; ;) {
                                if (void 0 === i) {
                                    if (e < r) break i;
                                    return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
                                }
                                if (n === s) break;
                                if (r = i, i = t[++n], e < i) break t
                            }
                            s = t.length;
                            break n
                        }
                        if (e >= r) break e;
                        {
                            const a = t[1];
                            e < a && (n = 2, r = a);
                            for (let s = n - 2; ;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                if (n === s) break;
                                if (i = r, r = t[--n - 1], e >= r) break t
                            }
                            s = n, n = 0
                        }
                    }
                    for (; n < s;) {
                        const i = n + s >>> 1;
                        e < t[i] ? s = i : n = i + 1
                    }
                    if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                    if (void 0 === i) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, e)
                }
                this._cachedIndex = n, this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, e, i)
        }

        getSettings_() {
            return this.settings || this.DefaultSettings_
        }

        copySampleValue_(e) {
            const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i;
            for (let e = 0; e !== i; ++e) t[e] = n[r + e];
            return t
        }

        interpolate_() {
            throw new Error("call to abstract method")
        }

        intervalChanged_() {
        }
    }

    Av.prototype.beforeStart_ = Av.prototype.copySampleValue_, Av.prototype.afterEnd_ = Av.prototype.copySampleValue_;

    class Lv extends Av {
        constructor(e, t, n, i) {
            super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: Lc,
                endingEnd: Lc
            }
        }

        intervalChanged_(e, t, n) {
            const i = this.parameterPositions;
            let r = e - 2, s = e + 1, a = i[r], o = i[s];
            if (void 0 === a) switch (this.getSettings_().endingStart) {
                case Cc:
                    r = e, a = 2 * t - n;
                    break;
                case Rc:
                    r = i.length - 2, a = t + i[r] - i[r + 1];
                    break;
                default:
                    r = e, a = n
            }
            if (void 0 === o) switch (this.getSettings_().endingEnd) {
                case Cc:
                    s = e, o = 2 * n - t;
                    break;
                case Rc:
                    s = 1, o = n + i[1] - i[0];
                    break;
                default:
                    s = e - 1, o = t
            }
            const l = .5 * (n - t), c = this.valueSize;
            this._weightPrev = l / (t - a), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = s * c
        }

        interpolate_(e, t, n, i) {
            const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a,
                c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext,
                p = (n - t) / (i - t), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p,
                v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, _ = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                y = d * m - d * f;
            for (let e = 0; e !== a; ++e) r[e] = g * s[c + e] + v * s[l + e] + _ * s[o + e] + y * s[h + e];
            return r
        }
    }

    class Cv extends Av {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }

        interpolate_(e, t, n, i) {
            const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a,
                c = (n - t) / (i - t), h = 1 - c;
            for (let e = 0; e !== a; ++e) r[e] = s[l + e] * h + s[o + e] * c;
            return r
        }
    }

    class Rv extends Av {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }

        interpolate_(e) {
            return this.copySampleValue_(e - 1)
        }
    }

    class Pv {
        constructor(e, t, n, i) {
            if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = Mv.convertArray(t, this.TimeBufferType), this.values = Mv.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
        }

        static toJSON(e) {
            const t = e.constructor;
            let n;
            if (t.toJSON !== this.toJSON) n = t.toJSON(e); else {
                n = {name: e.name, times: Mv.convertArray(e.times, Array), values: Mv.convertArray(e.values, Array)};
                const t = e.getInterpolation();
                t !== e.DefaultInterpolation && (n.interpolation = t)
            }
            return n.type = e.ValueTypeName, n
        }

        InterpolantFactoryMethodDiscrete(e) {
            return new Rv(this.times, this.values, this.getValueSize(), e)
        }

        InterpolantFactoryMethodLinear(e) {
            return new Cv(this.times, this.values, this.getValueSize(), e)
        }

        InterpolantFactoryMethodSmooth(e) {
            return new Lv(this.times, this.values, this.getValueSize(), e)
        }

        setInterpolation(e) {
            let t;
            switch (e) {
                case Ec:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Mc:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case Ac:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation) throw new Error(t);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", t), this
            }
            return this.createInterpolant = t, this
        }

        getInterpolation() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return Ec;
                case this.InterpolantFactoryMethodLinear:
                    return Mc;
                case this.InterpolantFactoryMethodSmooth:
                    return Ac
            }
        }

        getValueSize() {
            return this.values.length / this.times.length
        }

        shift(e) {
            if (0 !== e) {
                const t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
            }
            return this
        }

        scale(e) {
            if (1 !== e) {
                const t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
            }
            return this
        }

        trim(e, t) {
            const n = this.times, i = n.length;
            let r = 0, s = i - 1;
            for (; r !== i && n[r] < e;) ++r;
            for (; -1 !== s && n[s] > t;) --s;
            if (++s, 0 !== r || s !== i) {
                r >= s && (s = Math.max(s, 1), r = s - 1);
                const e = this.getValueSize();
                this.times = Mv.arraySlice(n, r, s), this.values = Mv.arraySlice(this.values, r * e, s * e)
            }
            return this
        }

        validate() {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            const n = this.times, i = this.values, r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            let s = null;
            for (let t = 0; t !== r; t++) {
                const i = n[t];
                if ("number" == typeof i && isNaN(i)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i), e = !1;
                    break
                }
                if (null !== s && s > i) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, s), e = !1;
                    break
                }
                s = i
            }
            if (void 0 !== i && Mv.isTypedArray(i)) for (let t = 0, n = i.length; t !== n; ++t) {
                const n = i[t];
                if (isNaN(n)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1;
                    break
                }
            }
            return e
        }

        optimize() {
            const e = Mv.arraySlice(this.times), t = Mv.arraySlice(this.values), n = this.getValueSize(),
                i = this.getInterpolation() === Ac, r = e.length - 1;
            let s = 1;
            for (let a = 1; a < r; ++a) {
                let r = !1;
                const o = e[a];
                if (o !== e[a + 1] && (1 !== a || o !== e[0])) if (i) r = !0; else {
                    const e = a * n, i = e - n, s = e + n;
                    for (let a = 0; a !== n; ++a) {
                        const n = t[e + a];
                        if (n !== t[i + a] || n !== t[s + a]) {
                            r = !0;
                            break
                        }
                    }
                }
                if (r) {
                    if (a !== s) {
                        e[s] = e[a];
                        const i = a * n, r = s * n;
                        for (let e = 0; e !== n; ++e) t[r + e] = t[i + e]
                    }
                    ++s
                }
            }
            if (r > 0) {
                e[s] = e[r];
                for (let e = r * n, i = s * n, a = 0; a !== n; ++a) t[i + a] = t[e + a];
                ++s
            }
            return s !== e.length ? (this.times = Mv.arraySlice(e, 0, s), this.values = Mv.arraySlice(t, 0, s * n)) : (this.times = e, this.values = t), this
        }

        clone() {
            const e = Mv.arraySlice(this.times, 0), t = Mv.arraySlice(this.values, 0),
                n = new (0, this.constructor)(this.name, e, t);
            return n.createInterpolant = this.createInterpolant, n
        }
    }

    Pv.prototype.TimeBufferType = Float32Array, Pv.prototype.ValueBufferType = Float32Array, Pv.prototype.DefaultInterpolation = Mc;

    class Iv extends Pv {
    }

    Iv.prototype.ValueTypeName = "bool", Iv.prototype.ValueBufferType = Array, Iv.prototype.DefaultInterpolation = Ec, Iv.prototype.InterpolantFactoryMethodLinear = void 0, Iv.prototype.InterpolantFactoryMethodSmooth = void 0;

    class Ov extends Pv {
    }

    Ov.prototype.ValueTypeName = "color";

    class Dv extends Pv {
    }

    Dv.prototype.ValueTypeName = "number";

    class Nv extends Av {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }

        interpolate_(e, t, n, i) {
            const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = (n - t) / (i - t);
            let l = e * a;
            for (let e = l + a; l !== e; l += 4) dh.slerpFlat(r, 0, s, l - a, s, l, o);
            return r
        }
    }

    class Bv extends Pv {
        InterpolantFactoryMethodLinear(e) {
            return new Nv(this.times, this.values, this.getValueSize(), e)
        }
    }

    Bv.prototype.ValueTypeName = "quaternion", Bv.prototype.DefaultInterpolation = Mc, Bv.prototype.InterpolantFactoryMethodSmooth = void 0;

    class kv extends Pv {
    }

    kv.prototype.ValueTypeName = "string", kv.prototype.ValueBufferType = Array, kv.prototype.DefaultInterpolation = Ec, kv.prototype.InterpolantFactoryMethodLinear = void 0, kv.prototype.InterpolantFactoryMethodSmooth = void 0;

    class Uv extends Pv {
    }

    Uv.prototype.ValueTypeName = "vector";

    class Fv {
        constructor(e, t = -1, n, i = 2500) {
            this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = $c(), this.duration < 0 && this.resetDuration()
        }

        static parse(e) {
            const t = [], n = e.tracks, i = 1 / (e.fps || 1);
            for (let e = 0, r = n.length; e !== r; ++e) t.push(Hv(n[e]).scale(i));
            const r = new this(e.name, e.duration, t, e.blendMode);
            return r.uuid = e.uuid, r
        }

        static toJSON(e) {
            const t = [], n = e.tracks,
                i = {name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode};
            for (let e = 0, i = n.length; e !== i; ++e) t.push(Pv.toJSON(n[e]));
            return i
        }

        static CreateFromMorphTargetSequence(e, t, n, i) {
            const r = t.length, s = [];
            for (let e = 0; e < r; e++) {
                let a = [], o = [];
                a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
                const l = Mv.getKeyframeOrder(a);
                a = Mv.sortedArray(a, 1, l), o = Mv.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new Dv(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / n))
            }
            return new this(e, -1, s)
        }

        static findByName(e, t) {
            let n = e;
            if (!Array.isArray(e)) {
                const t = e;
                n = t.geometry && t.geometry.animations || t.animations
            }
            for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
            return null
        }

        static CreateClipsFromMorphTargetSequences(e, t, n) {
            const i = {}, r = /^([\w-]*?)([\d]+)$/;
            for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t], s = n.name.match(r);
                if (s && s.length > 1) {
                    const e = s[1];
                    let t = i[e];
                    t || (i[e] = t = []), t.push(n)
                }
            }
            const s = [];
            for (const e in i) s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
            return s
        }

        static parseAnimation(e, t) {
            if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function (e, t, n, i, r) {
                if (0 !== n.length) {
                    const s = [], a = [];
                    Mv.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new e(t, s, a))
                }
            }, i = [], r = e.name || "default", s = e.fps || 30, a = e.blendMode;
            let o = e.length || -1;
            const l = e.hierarchy || [];
            for (let e = 0; e < l.length; e++) {
                const r = l[e].keys;
                if (r && 0 !== r.length) if (r[0].morphTargets) {
                    const e = {};
                    let t;
                    for (t = 0; t < r.length; t++) if (r[t].morphTargets) for (let n = 0; n < r[t].morphTargets.length; n++) e[r[t].morphTargets[n]] = -1;
                    for (const n in e) {
                        const e = [], s = [];
                        for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                            const i = r[t];
                            e.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                        }
                        i.push(new Dv(".morphTargetInfluence[" + n + "]", e, s))
                    }
                    o = e.length * (s || 1)
                } else {
                    const s = ".bones[" + t[e].name + "]";
                    n(Uv, s + ".position", r, "pos", i), n(Bv, s + ".quaternion", r, "rot", i), n(Uv, s + ".scale", r, "scl", i)
                }
            }
            if (0 === i.length) return null;
            return new this(r, o, i, a)
        }

        resetDuration() {
            let e = 0;
            for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                const n = this.tracks[t];
                e = Math.max(e, n.times[n.times.length - 1])
            }
            return this.duration = e, this
        }

        trim() {
            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        }

        validate() {
            let e = !0;
            for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        }

        optimize() {
            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        }

        clone() {
            const e = [];
            for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new this.constructor(this.name, this.duration, e, this.blendMode)
        }

        toJSON() {
            return this.constructor.toJSON(this)
        }
    }

    function Hv(e) {
        if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const t = function (e) {
            switch (e.toLowerCase()) {
                case"scalar":
                case"double":
                case"float":
                case"number":
                case"integer":
                    return Dv;
                case"vector":
                case"vector2":
                case"vector3":
                case"vector4":
                    return Uv;
                case"color":
                    return Ov;
                case"quaternion":
                    return Bv;
                case"bool":
                case"boolean":
                    return Iv;
                case"string":
                    return kv
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            const t = [], n = [];
            Mv.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    }

    const zv = {
        enabled: !1, files: {}, add: function (e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        }, get: function (e) {
            if (!1 !== this.enabled) return this.files[e]
        }, remove: function (e) {
            delete this.files[e]
        }, clear: function () {
            this.files = {}
        }
    };
    const Gv = new class {
        constructor(e, t, n) {
            const i = this;
            let r, s = !1, a = 0, o = 0;
            const l = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
                o++, !1 === s && void 0 !== i.onStart && i.onStart(e, a, o), s = !0
            }, this.itemEnd = function (e) {
                a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (s = !1, void 0 !== i.onLoad && i.onLoad())
            }, this.itemError = function (e) {
                void 0 !== i.onError && i.onError(e)
            }, this.resolveURL = function (e) {
                return r ? r(e) : e
            }, this.setURLModifier = function (e) {
                return r = e, this
            }, this.addHandler = function (e, t) {
                return l.push(e, t), this
            }, this.removeHandler = function (e) {
                const t = l.indexOf(e);
                return -1 !== t && l.splice(t, 2), this
            }, this.getHandler = function (e) {
                for (let t = 0, n = l.length; t < n; t += 2) {
                    const n = l[t], i = l[t + 1];
                    if (n.global && (n.lastIndex = 0), n.test(e)) return i
                }
                return null
            }
        }
    };

    class Vv {
        constructor(e) {
            this.manager = void 0 !== e ? e : Gv, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
        }

        load() {
        }

        loadAsync(e, t) {
            const n = this;
            return new Promise((function (i, r) {
                n.load(e, i, t, r)
            }))
        }

        parse() {
        }

        setCrossOrigin(e) {
            return this.crossOrigin = e, this
        }

        setWithCredentials(e) {
            return this.withCredentials = e, this
        }

        setPath(e) {
            return this.path = e, this
        }

        setResourcePath(e) {
            return this.resourcePath = e, this
        }

        setRequestHeader(e) {
            return this.requestHeader = e, this
        }
    }

    const Wv = {};

    class jv extends Vv {
        constructor(e) {
            super(e)
        }

        load(e, t, n, i) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this, s = zv.get(e);
            if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () {
                t && t(s), r.manager.itemEnd(e)
            }), 0), s;
            if (void 0 !== Wv[e]) return void Wv[e].push({onLoad: t, onProgress: n, onError: i});
            const a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
            let o;
            if (a) {
                const n = a[1], s = !!a[2];
                let o = a[3];
                o = decodeURIComponent(o), s && (o = atob(o));
                try {
                    let i;
                    const s = (this.responseType || "").toLowerCase();
                    switch (s) {
                        case"arraybuffer":
                        case"blob":
                            const e = new Uint8Array(o.length);
                            for (let t = 0; t < o.length; t++) e[t] = o.charCodeAt(t);
                            i = "blob" === s ? new Blob([e.buffer], {type: n}) : e.buffer;
                            break;
                        case"document":
                            const t = new DOMParser;
                            i = t.parseFromString(o, n);
                            break;
                        case"json":
                            i = JSON.parse(o);
                            break;
                        default:
                            i = o
                    }
                    setTimeout((function () {
                        t && t(i), r.manager.itemEnd(e)
                    }), 0)
                } catch (t) {
                    setTimeout((function () {
                        i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }), 0)
                }
            } else {
                Wv[e] = [], Wv[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                }), o = new XMLHttpRequest, o.open("GET", e, !0), o.addEventListener("load", (function (t) {
                    const n = this.response, i = Wv[e];
                    if (delete Wv[e], 200 === this.status || 0 === this.status) {
                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), zv.add(e, n);
                        for (let e = 0, t = i.length; e < t; e++) {
                            const t = i[e];
                            t.onLoad && t.onLoad(n)
                        }
                        r.manager.itemEnd(e)
                    } else {
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            n.onError && n.onError(t)
                        }
                        r.manager.itemError(e), r.manager.itemEnd(e)
                    }
                }), !1), o.addEventListener("progress", (function (t) {
                    const n = Wv[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onProgress && i.onProgress(t)
                    }
                }), !1), o.addEventListener("error", (function (t) {
                    const n = Wv[e];
                    delete Wv[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onError && i.onError(t)
                    }
                    r.manager.itemError(e), r.manager.itemEnd(e)
                }), !1), o.addEventListener("abort", (function (t) {
                    const n = Wv[e];
                    delete Wv[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onError && i.onError(t)
                    }
                    r.manager.itemError(e), r.manager.itemEnd(e)
                }), !1), void 0 !== this.responseType && (o.responseType = this.responseType), void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials), o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (const e in this.requestHeader) o.setRequestHeader(e, this.requestHeader[e]);
                o.send(null)
            }
            return r.manager.itemStart(e), o
        }

        setResponseType(e) {
            return this.responseType = e, this
        }

        setMimeType(e) {
            return this.mimeType = e, this
        }
    }

    class $v extends Vv {
        constructor(e) {
            super(e)
        }

        load(e, t, n, i) {
            void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this, s = zv.get(e);
            if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () {
                t && t(s), r.manager.itemEnd(e)
            }), 0), s;
            const a = ih("img");

            function o() {
                a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), zv.add(e, this), t && t(this), r.manager.itemEnd(e)
            }

            function l(t) {
                a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
            }

            return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a
        }
    }

    class Xv extends Vv {
        constructor(e) {
            super(e)
        }

        load(e, t, n, i) {
            const r = new Ed, s = new $v(this.manager);
            s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
            let a = 0;

            function o(n) {
                s.load(e[n], (function (e) {
                    r.images[n] = e, a++, 6 === a && (r.needsUpdate = !0, t && t(r))
                }), void 0, i)
            }

            for (let t = 0; t < e.length; ++t) o(t);
            return r
        }
    }

    class qv extends Vv {
        constructor(e) {
            super(e)
        }

        load(e, t, n, i) {
            const r = new oh, s = new $v(this.manager);
            return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function (e) {
                r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
            }), n, i), r
        }
    }

    class Yv extends mu {
        constructor(e, t = 1) {
            super(), this.type = "Light", this.color = new Nu(e), this.intensity = t
        }

        dispose() {
        }

        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this
        }

        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
        }
    }

    Yv.prototype.isLight = !0;
    (class extends Yv {
        constructor(e, t, n) {
            super(e, n), this.type = "HemisphereLight", this.position.copy(mu.DefaultUp), this.updateMatrix(), this.groundColor = new Nu(t)
        }

        copy(e) {
            return Yv.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }).prototype.isHemisphereLight = !0;
    const Kv = new Wh, Jv = new ph, Zv = new ph;

    class Qv {
        constructor(e) {
            this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new eh(512, 512), this.map = null, this.mapPass = null, this.matrix = new Wh, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Od, this._frameExtents = new eh(1, 1), this._viewportCount = 1, this._viewports = [new ch(0, 0, 1, 1)]
        }

        getViewportCount() {
            return this._viewportCount
        }

        getFrustum() {
            return this._frustum
        }

        updateMatrices(e) {
            const t = this.camera, n = this.matrix;
            Jv.setFromMatrixPosition(e.matrixWorld), t.position.copy(Jv), Zv.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Zv), t.updateMatrixWorld(), Kv.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Kv), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
        }

        getViewport(e) {
            return this._viewports[e]
        }

        getFrameExtents() {
            return this._frameExtents
        }

        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
        }

        copy(e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        toJSON() {
            const e = {};
            return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }

    class e_ extends Qv {
        constructor() {
            super(new wd(50, 1, .5, 500)), this.focus = 1
        }

        updateMatrices(e) {
            const t = this.camera, n = 2 * Vc * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height,
                r = e.distance || t.far;
            n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
        }

        copy(e) {
            return super.copy(e), this.focus = e.focus, this
        }
    }

    e_.prototype.isSpotLightShadow = !0;

    class t_ extends Yv {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) {
            super(e, t), this.type = "SpotLight", this.position.copy(mu.DefaultUp), this.updateMatrix(), this.target = new mu, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new e_
        }

        get power() {
            return this.intensity * Math.PI
        }

        set power(e) {
            this.intensity = e / Math.PI
        }

        dispose() {
            this.shadow.dispose()
        }

        copy(e) {
            return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }

    t_.prototype.isSpotLight = !0;
    const n_ = new Wh, i_ = new ph, r_ = new ph;

    class s_ extends Qv {
        constructor() {
            super(new wd(90, 1, .5, 500)), this._frameExtents = new eh(4, 2), this._viewportCount = 6, this._viewports = [new ch(2, 1, 1, 1), new ch(0, 1, 1, 1), new ch(3, 1, 1, 1), new ch(1, 1, 1, 1), new ch(3, 0, 1, 1), new ch(1, 0, 1, 1)], this._cubeDirections = [new ph(1, 0, 0), new ph(-1, 0, 0), new ph(0, 0, 1), new ph(0, 0, -1), new ph(0, 1, 0), new ph(0, -1, 0)], this._cubeUps = [new ph(0, 1, 0), new ph(0, 1, 0), new ph(0, 1, 0), new ph(0, 1, 0), new ph(0, 0, 1), new ph(0, 0, -1)]
        }

        updateMatrices(e, t = 0) {
            const n = this.camera, i = this.matrix, r = e.distance || n.far;
            r !== n.far && (n.far = r, n.updateProjectionMatrix()), i_.setFromMatrixPosition(e.matrixWorld), n.position.copy(i_), r_.copy(n.position), r_.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(r_), n.updateMatrixWorld(), i.makeTranslation(-i_.x, -i_.y, -i_.z), n_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(n_)
        }
    }

    s_.prototype.isPointLightShadow = !0;

    class a_ extends Yv {
        constructor(e, t, n = 0, i = 1) {
            super(e, t), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new s_
        }

        get power() {
            return 4 * this.intensity * Math.PI
        }

        set power(e) {
            this.intensity = e / (4 * Math.PI)
        }

        dispose() {
            this.shadow.dispose()
        }

        copy(e) {
            return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }

    a_.prototype.isPointLight = !0;

    class o_ extends Qv {
        constructor() {
            super(new $d(-5, 5, 5, -5, .5, 500))
        }
    }

    o_.prototype.isDirectionalLightShadow = !0;

    class l_ extends Yv {
        constructor(e, t) {
            super(e, t), this.type = "DirectionalLight", this.position.copy(mu.DefaultUp), this.updateMatrix(), this.target = new mu, this.shadow = new o_
        }

        dispose() {
            this.shadow.dispose()
        }

        copy(e) {
            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }

    l_.prototype.isDirectionalLight = !0;
    (class extends Yv {
        constructor(e, t) {
            super(e, t), this.type = "AmbientLight"
        }
    }).prototype.isAmbientLight = !0;
    (class extends Yv {
        constructor(e, t, n = 10, i = 10) {
            super(e, t), this.type = "RectAreaLight", this.width = n, this.height = i
        }

        get power() {
            return this.intensity * this.width * this.height * Math.PI
        }

        set power(e) {
            this.intensity = e / (this.width * this.height * Math.PI)
        }

        copy(e) {
            return super.copy(e), this.width = e.width, this.height = e.height, this
        }

        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.width = this.width, t.object.height = this.height, t
        }
    }).prototype.isRectAreaLight = !0;

    class c_ {
        constructor() {
            this.coefficients = [];
            for (let e = 0; e < 9; e++) this.coefficients.push(new ph)
        }

        set(e) {
            for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
            return this
        }

        zero() {
            for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
            return this
        }

        getAt(e, t) {
            const n = e.x, i = e.y, r = e.z, s = this.coefficients;
            return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * i), t.addScaledVector(s[2], .488603 * r), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], n * i * 1.092548), t.addScaledVector(s[5], i * r * 1.092548), t.addScaledVector(s[6], .315392 * (3 * r * r - 1)), t.addScaledVector(s[7], n * r * 1.092548), t.addScaledVector(s[8], .546274 * (n * n - i * i)), t
        }

        getIrradianceAt(e, t) {
            const n = e.x, i = e.y, r = e.z, s = this.coefficients;
            return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * i), t.addScaledVector(s[2], 1.023328 * r), t.addScaledVector(s[3], 1.023328 * n), t.addScaledVector(s[4], .858086 * n * i), t.addScaledVector(s[5], .858086 * i * r), t.addScaledVector(s[6], .743125 * r * r - .247708), t.addScaledVector(s[7], .858086 * n * r), t.addScaledVector(s[8], .429043 * (n * n - i * i)), t
        }

        add(e) {
            for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
            return this
        }

        addScaledSH(e, t) {
            for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
            return this
        }

        scale(e) {
            for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
            return this
        }

        lerp(e, t) {
            for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
            return this
        }

        equals(e) {
            for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
            return !0
        }

        copy(e) {
            return this.set(e.coefficients)
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        fromArray(e, t = 0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
            return this
        }

        toArray(e = [], t = 0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
            return e
        }

        static getBasisAt(e, t) {
            const n = e.x, i = e.y, r = e.z;
            t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * r, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = .546274 * (n * n - i * i)
        }
    }

    c_.prototype.isSphericalHarmonics3 = !0;

    class h_ extends Yv {
        constructor(e = new c_, t = 1) {
            super(void 0, t), this.sh = e
        }

        copy(e) {
            return super.copy(e), this.sh.copy(e.sh), this
        }

        fromJSON(e) {
            return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
        }

        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.sh = this.sh.toArray(), t
        }
    }

    h_.prototype.isLightProbe = !0;

    class u_ {
        static decodeText(e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            let t = "";
            for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        }

        static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    }

    (class extends Ku {
        constructor() {
            super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
        }

        copy(e) {
            return super.copy(e), this.instanceCount = e.instanceCount, this
        }

        clone() {
            return (new this.constructor).copy(this)
        }

        toJSON() {
            const e = super.toJSON(this);
            return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
        }
    }).prototype.isInstancedBufferGeometry = !0;

    class d_ extends Vv {
        constructor(e) {
            super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {premultiplyAlpha: "none"}
        }

        setOptions(e) {
            return this.options = e, this
        }

        load(e, t, n, i) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            const r = this, s = zv.get(e);
            if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () {
                t && t(s), r.manager.itemEnd(e)
            }), 0), s;
            const a = {};
            a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then((function (e) {
                return e.blob()
            })).then((function (e) {
                return createImageBitmap(e, Object.assign(r.options, {colorSpaceConversion: "none"}))
            })).then((function (n) {
                zv.add(e, n), t && t(n), r.manager.itemEnd(e)
            })).catch((function (t) {
                i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
            })), r.manager.itemStart(e)
        }
    }

    let p_;
    d_.prototype.isImageBitmapLoader = !0;
    const f_ = function () {
        return void 0 === p_ && (p_ = new (window.AudioContext || window.webkitAudioContext)), p_
    };

    class m_ extends Vv {
        constructor(e) {
            super(e)
        }

        load(e, t, n, i) {
            const r = this, s = new jv(this.manager);
            s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function (n) {
                try {
                    const e = n.slice(0);
                    f_().decodeAudioData(e, (function (e) {
                        t(e)
                    }))
                } catch (t) {
                    i ? i(t) : console.error(t), r.manager.itemError(e)
                }
            }), n, i)
        }
    }

    (class extends h_ {
        constructor(e, t, n = 1) {
            super(void 0, n);
            const i = (new Nu).set(e), r = (new Nu).set(t), s = new ph(i.r, i.g, i.b), a = new ph(r.r, r.g, r.b),
                o = Math.sqrt(Math.PI), l = o * Math.sqrt(.75);
            this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
        }
    }).prototype.isHemisphereLightProbe = !0;
    (class extends h_ {
        constructor(e, t = 1) {
            super(void 0, t);
            const n = (new Nu).set(e);
            this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }
    }).prototype.isAmbientLightProbe = !0;

    class g_ {
        constructor(e = !0) {
            this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }

        start() {
            this.startTime = v_(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
        }

        stop() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1
        }

        getElapsedTime() {
            return this.getDelta(), this.elapsedTime
        }

        getDelta() {
            let e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                const t = v_();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    }

    function v_() {
        return ("undefined" == typeof performance ? Date : performance).now()
    }

    class __ {
        constructor(e, t, n) {
            let i, r, s;
            switch (this.binding = e, this.valueSize = n, t) {
                case"quaternion":
                    i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                    break;
                case"string":
                case"bool":
                    i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                    break;
                default:
                    i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
            }
            this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
        }

        accumulate(e, t) {
            const n = this.buffer, i = this.valueSize, r = e * i + i;
            let s = this.cumulativeWeight;
            if (0 === s) {
                for (let e = 0; e !== i; ++e) n[r + e] = n[e];
                s = t
            } else {
                s += t;
                const e = t / s;
                this._mixBufferRegion(n, r, 0, e, i)
            }
            this.cumulativeWeight = s
        }

        accumulateAdditive(e) {
            const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e
        }

        apply(e) {
            const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight,
                s = this.cumulativeWeightAdditive, a = this.binding;
            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                const e = t * this._origIndex;
                this._mixBufferRegion(n, i, e, 1 - r, t)
            }
            s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
            for (let e = t, r = t + t; e !== r; ++e) if (n[e] !== n[e + t]) {
                a.setValue(n, i);
                break
            }
        }

        saveOriginalState() {
            const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
            e.getValue(t, i);
            for (let e = n, r = i; e !== r; ++e) t[e] = t[i + e % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
        }

        restoreOriginalState() {
            const e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        }

        _setAdditiveIdentityNumeric() {
            const e = this._addIndex * this.valueSize, t = e + this.valueSize;
            for (let n = e; n < t; n++) this.buffer[n] = 0
        }

        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
        }

        _setAdditiveIdentityOther() {
            const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
        }

        _select(e, t, n, i, r) {
            if (i >= .5) for (let i = 0; i !== r; ++i) e[t + i] = e[n + i]
        }

        _slerp(e, t, n, i) {
            dh.slerpFlat(e, t, e, t, e, n, i)
        }

        _slerpAdditive(e, t, n, i, r) {
            const s = this._workIndex * r;
            dh.multiplyQuaternionsFlat(e, s, e, t, e, n), dh.slerpFlat(e, t, e, t, e, s, i)
        }

        _lerp(e, t, n, i, r) {
            const s = 1 - i;
            for (let a = 0; a !== r; ++a) {
                const r = t + a;
                e[r] = e[r] * s + e[n + a] * i
            }
        }

        _lerpAdditive(e, t, n, i, r) {
            for (let s = 0; s !== r; ++s) {
                const r = t + s;
                e[r] = e[r] + e[n + s] * i
            }
        }
    }

    const y_ = "\\[\\]\\.:\\/", x_ = new RegExp("[\\[\\]\\.:\\/]", "g"), b_ = "[^\\[\\]\\.:\\/]",
        w_ = "[^" + y_.replace("\\.", "") + "]", T_ = /((?:WC+[\/:])*)/.source.replace("WC", b_),
        S_ = /(WCOD+)?/.source.replace("WCOD", w_), E_ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", b_),
        M_ = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", b_), A_ = new RegExp("^" + T_ + S_ + E_ + M_ + "$"),
        L_ = ["material", "materials", "bones"];

    class C_ {
        constructor(e, t, n) {
            this.path = t, this.parsedPath = n || C_.parseTrackName(t), this.node = C_.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }

        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new C_.Composite(e, t, n) : new C_(e, t, n)
        }

        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(x_, "")
        }

        static parseTrackName(e) {
            const t = A_.exec(e);
            if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6]},
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                const e = n.nodeName.substring(i + 1);
                -1 !== L_.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
            }
            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        }

        static findNode(e, t) {
            if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (void 0 !== n) return n
            }
            if (e.children) {
                const n = function (e) {
                    for (let i = 0; i < e.length; i++) {
                        const r = e[i];
                        if (r.name === t || r.uuid === t) return r;
                        const s = n(r.children);
                        if (s) return s
                    }
                    return null
                }, i = n(e.children);
                if (i) return i
            }
            return null
        }

        _getValue_unavailable() {
        }

        _setValue_unavailable() {
        }

        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName]
        }

        _getValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
        }

        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }

        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t)
        }

        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }

        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
        }

        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }

        _setValue_array(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
        }

        _setValue_array_setNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }

        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }

        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }

        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
        }

        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }

        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }

        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
        }

        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
        }

        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t)
        }

        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t)
        }

        bind() {
            let e = this.node;
            const t = this.parsedPath, n = t.objectName, i = t.propertyName;
            let r = t.propertyIndex;
            if (e || (e = C_.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (n) {
                let i = t.objectIndex;
                switch (n) {
                    case"materials":
                        if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case"bones":
                        if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (let t = 0; t < e.length; t++) if (e[t].name === i) {
                            i = t;
                            break
                        }
                        break;
                    default:
                        if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[n]
                }
                if (void 0 !== i) {
                    if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    e = e[i]
                }
            }
            const s = e[i];
            if (void 0 === s) {
                const n = t.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
            }
            let a = this.Versioning.None;
            this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                    if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                }
                o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
        }

        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }

    C_.Composite = class {
        constructor(e, t, n) {
            const i = n || C_.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, i)
        }

        getValue(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
            void 0 !== i && i.getValue(e, t)
        }

        setValue(e, t) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
        }

        bind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
        }

        unbind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
        }
    }, C_.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    }, C_.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    }, C_.prototype.GetterByBindingType = [C_.prototype._getValue_direct, C_.prototype._getValue_array, C_.prototype._getValue_arrayElement, C_.prototype._getValue_toArray], C_.prototype.SetterByBindingTypeAndVersioning = [[C_.prototype._setValue_direct, C_.prototype._setValue_direct_setNeedsUpdate, C_.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [C_.prototype._setValue_array, C_.prototype._setValue_array_setNeedsUpdate, C_.prototype._setValue_array_setMatrixWorldNeedsUpdate], [C_.prototype._setValue_arrayElement, C_.prototype._setValue_arrayElement_setNeedsUpdate, C_.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [C_.prototype._setValue_fromArray, C_.prototype._setValue_fromArray_setNeedsUpdate, C_.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

    class R_ {
        constructor(e, t, n = null, i = t.blendMode) {
            this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
            const r = t.tracks, s = r.length, a = new Array(s), o = {endingStart: Lc, endingEnd: Lc};
            for (let e = 0; e !== s; ++e) {
                const t = r[e].createInterpolant(null);
                a[e] = t, t.settings = o
            }
            this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
        }

        play() {
            return this._mixer._activateAction(this), this
        }

        stop() {
            return this._mixer._deactivateAction(this), this.reset()
        }

        reset() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        }

        isRunning() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        }

        isScheduled() {
            return this._mixer._isActiveAction(this)
        }

        startAt(e) {
            return this._startTime = e, this
        }

        setLoop(e, t) {
            return this.loop = e, this.repetitions = t, this
        }

        setEffectiveWeight(e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
        }

        getEffectiveWeight() {
            return this._effectiveWeight
        }

        fadeIn(e) {
            return this._scheduleFading(e, 0, 1)
        }

        fadeOut(e) {
            return this._scheduleFading(e, 1, 0)
        }

        crossFadeFrom(e, t, n) {
            if (e.fadeOut(t), this.fadeIn(t), n) {
                const n = this._clip.duration, i = e._clip.duration, r = i / n, s = n / i;
                e.warp(1, r, t), this.warp(s, 1, t)
            }
            return this
        }

        crossFadeTo(e, t, n) {
            return e.crossFadeFrom(this, t, n)
        }

        stopFading() {
            const e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        }

        setEffectiveTimeScale(e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
        }

        getEffectiveTimeScale() {
            return this._effectiveTimeScale
        }

        setDuration(e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping()
        }

        syncWith(e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
        }

        halt(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        }

        warp(e, t, n) {
            const i = this._mixer, r = i.time, s = this.timeScale;
            let a = this._timeScaleInterpolant;
            null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
            const o = a.parameterPositions, l = a.sampleValues;
            return o[0] = r, o[1] = r + n, l[0] = e / s, l[1] = t / s, this
        }

        stopWarping() {
            const e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        }

        getMixer() {
            return this._mixer
        }

        getClip() {
            return this._clip
        }

        getRoot() {
            return this._localRoot || this._mixer._root
        }

        _update(e, t, n, i) {
            if (!this.enabled) return void this._updateWeight(e);
            const r = this._startTime;
            if (null !== r) {
                const i = (e - r) * n;
                if (i < 0 || 0 === n) return;
                this._startTime = null, t = n * i
            }
            t *= this._updateTimeScale(e);
            const s = this._updateTime(t), a = this._updateWeight(e);
            if (a > 0) {
                const e = this._interpolants, t = this._propertyBindings;
                if (2501 === this.blendMode) for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(s), t[n].accumulateAdditive(a); else for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(s), t[n].accumulate(i, a)
            }
        }

        _updateWeight(e) {
            let t = 0;
            if (this.enabled) {
                t = this.weight;
                const n = this._weightInterpolant;
                if (null !== n) {
                    const i = n.evaluate(e)[0];
                    t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t, t
        }

        _updateTimeScale(e) {
            let t = 0;
            if (!this.paused) {
                t = this.timeScale;
                const n = this._timeScaleInterpolant;
                if (null !== n) {
                    t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                }
            }
            return this._effectiveTimeScale = t, t
        }

        _updateTime(e) {
            const t = this._clip.duration, n = this.loop;
            let i = this.time + e, r = this._loopCount;
            const s = 2202 === n;
            if (0 === e) return -1 === r ? i : s && 1 == (1 & r) ? t - i : i;
            if (2200 === n) {
                -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                e:{
                    if (i >= t) i = t; else {
                        if (!(i < 0)) {
                            this.time = i;
                            break e
                        }
                        i = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= t || i < 0) {
                    const n = Math.floor(i / t);
                    i -= t * n, r += Math.abs(n);
                    const a = this.repetitions - r;
                    if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    }); else {
                        if (1 === a) {
                            const t = e < 0;
                            this._setEndings(t, !t, s)
                        } else this._setEndings(!1, !1, s);
                        this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: n
                        })
                    }
                } else this.time = i;
                if (s && 1 == (1 & r)) return t - i
            }
            return i
        }

        _setEndings(e, t, n) {
            const i = this._interpolantSettings;
            n ? (i.endingStart = Cc, i.endingEnd = Cc) : (i.endingStart = e ? this.zeroSlopeAtStart ? Cc : Lc : Rc, i.endingEnd = t ? this.zeroSlopeAtEnd ? Cc : Lc : Rc)
        }

        _scheduleFading(e, t, n) {
            const i = this._mixer, r = i.time;
            let s = this._weightInterpolant;
            null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
            const a = s.parameterPositions, o = s.sampleValues;
            return a[0] = r, o[0] = t, a[1] = r + e, o[1] = n, this
        }
    }

    class P_ extends Hc {
        constructor(e) {
            super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }

        _bindAction(e, t) {
            const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, s = e._propertyBindings,
                a = e._interpolants, o = n.uuid, l = this._bindingsByRootAndName;
            let c = l[o];
            void 0 === c && (c = {}, l[o] = c);
            for (let e = 0; e !== r; ++e) {
                const r = i[e], l = r.name;
                let h = c[l];
                if (void 0 !== h) s[e] = h; else {
                    if (h = s[e], void 0 !== h) {
                        null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l));
                        continue
                    }
                    const i = t && t._propertyBindings[e].binding.parsedPath;
                    h = new __(C_.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[e] = h
                }
                a[e].resultBuffer = h.buffer
            }
        }

        _activateAction(e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    const t = (e._localRoot || this._root).uuid, n = e._clip.uuid, i = this._actionsByClip[n];
                    this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t)
                }
                const t = e._propertyBindings;
                for (let e = 0, n = t.length; e !== n; ++e) {
                    const n = t[e];
                    0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                }
                this._lendAction(e)
            }
        }

        _deactivateAction(e) {
            if (this._isActiveAction(e)) {
                const t = e._propertyBindings;
                for (let e = 0, n = t.length; e !== n; ++e) {
                    const n = t[e];
                    0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                }
                this._takeBackAction(e)
            }
        }

        _initMemoryManager() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            const e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    }, get inUse() {
                        return e._nActiveActions
                    }
                }, bindings: {
                    get total() {
                        return e._bindings.length
                    }, get inUse() {
                        return e._nActiveBindings
                    }
                }, controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    }, get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        }

        _isActiveAction(e) {
            const t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
        }

        _addInactiveAction(e, t, n) {
            const i = this._actions, r = this._actionsByClip;
            let s = r[t];
            if (void 0 === s) s = {knownActions: [e], actionByRoot: {}}, e._byClipCacheIndex = 0, r[t] = s; else {
                const t = s.knownActions;
                e._byClipCacheIndex = t.length, t.push(e)
            }
            e._cacheIndex = i.length, i.push(e), s.actionByRoot[n] = e
        }

        _removeInactiveAction(e) {
            const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
            n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
            const r = e._clip.uuid, s = this._actionsByClip, a = s[r], o = a.knownActions, l = o[o.length - 1],
                c = e._byClipCacheIndex;
            l._byClipCacheIndex = c, o[c] = l, o.pop(), e._byClipCacheIndex = null;
            delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(e)
        }

        _removeInactiveBindingsForAction(e) {
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
                const n = t[e];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        }

        _lendAction(e) {
            const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i];
            e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
        }

        _takeBackAction(e) {
            const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i];
            e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
        }

        _addInactiveBinding(e, t, n) {
            const i = this._bindingsByRootAndName, r = this._bindings;
            let s = i[t];
            void 0 === s && (s = {}, i[t] = s), s[n] = e, e._cacheIndex = r.length, r.push(e)
        }

        _removeInactiveBinding(e) {
            const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, s = this._bindingsByRootAndName,
                a = s[i], o = t[t.length - 1], l = e._cacheIndex;
            o._cacheIndex = l, t[l] = o, t.pop(), delete a[r], 0 === Object.keys(a).length && delete s[i]
        }

        _lendBinding(e) {
            const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i];
            e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
        }

        _takeBackBinding(e) {
            const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i];
            e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
        }

        _lendControlInterpolant() {
            const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
            let n = e[t];
            return void 0 === n && (n = new Cv(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
        }

        _takeBackControlInterpolant(e) {
            const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i];
            e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
        }

        clipAction(e, t, n) {
            const i = t || this._root, r = i.uuid;
            let s = "string" == typeof e ? Fv.findByName(i, e) : e;
            const a = null !== s ? s.uuid : e, o = this._actionsByClip[a];
            let l = null;
            if (void 0 === n && (n = null !== s ? s.blendMode : Pc), void 0 !== o) {
                const e = o.actionByRoot[r];
                if (void 0 !== e && e.blendMode === n) return e;
                l = o.knownActions[0], null === s && (s = l._clip)
            }
            if (null === s) return null;
            const c = new R_(this, s, t, n);
            return this._bindAction(c, l), this._addInactiveAction(c, a, r), c
        }

        existingAction(e, t) {
            const n = t || this._root, i = n.uuid, r = "string" == typeof e ? Fv.findByName(n, e) : e,
                s = r ? r.uuid : e, a = this._actionsByClip[s];
            return void 0 !== a && a.actionByRoot[i] || null
        }

        stopAllAction() {
            const e = this._actions;
            for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
            return this
        }

        update(e) {
            e *= this.timeScale;
            const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e),
                s = this._accuIndex ^= 1;
            for (let a = 0; a !== n; ++a) {
                t[a]._update(i, e, r, s)
            }
            const a = this._bindings, o = this._nActiveBindings;
            for (let e = 0; e !== o; ++e) a[e].apply(s);
            return this
        }

        setTime(e) {
            this.time = 0;
            for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
            return this.update(e)
        }

        getRoot() {
            return this._root
        }

        uncacheClip(e) {
            const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n];
            if (void 0 !== r) {
                const e = r.knownActions;
                for (let n = 0, i = e.length; n !== i; ++n) {
                    const i = e[n];
                    this._deactivateAction(i);
                    const r = i._cacheIndex, s = t[t.length - 1];
                    i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, t[r] = s, t.pop(), this._removeInactiveBindingsForAction(i)
                }
                delete i[n]
            }
        }

        uncacheRoot(e) {
            const t = e.uuid, n = this._actionsByClip;
            for (const e in n) {
                const i = n[e].actionByRoot[t];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            const i = this._bindingsByRootAndName[t];
            if (void 0 !== i) for (const e in i) {
                const t = i[e];
                t.restoreOriginalState(), this._removeInactiveBinding(t)
            }
        }

        uncacheAction(e, t) {
            const n = this.existingAction(e, t);
            null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
        }
    }

    P_.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
    (class extends Em {
        constructor(e, t, n = 1) {
            super(e, t), this.meshPerAttribute = n
        }

        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
        }

        clone(e) {
            const t = super.clone(e);
            return t.meshPerAttribute = this.meshPerAttribute, t
        }

        toJSON(e) {
            const t = super.toJSON(e);
            return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
        }
    }).prototype.isInstancedInterleavedBuffer = !0;

    function I_(e, t) {
        return e.distance - t.distance
    }

    function O_(e, t, n, i) {
        if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i) {
            const i = e.children;
            for (let e = 0, r = i.length; e < r; e++) O_(i[e], t, n, !0)
        }
    }

    (class extends mu {
        constructor(e) {
            super(), this.material = e, this.render = function () {
            }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
        }
    }).prototype.isImmediateRenderObject = !0;
    const D_ = new ph, N_ = new Wh, B_ = new Wh;

    function k_(e) {
        const t = [];
        e && e.isBone && t.push(e);
        for (let n = 0; n < e.children.length; n++) t.push.apply(t, k_(e.children[n]));
        return t
    }

    const U_ = new Float32Array(1);
    new Int32Array(U_.buffer), Sg.create = function (e, t) {
        return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Sg.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
    }, Wg.prototype.fromPoints = function (e) {
        return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
    }, class extends fg {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
            n = new Nu(n), i = new Nu(i);
            const r = t / 2, s = e / t, a = e / 2, o = [], l = [];
            for (let e = 0, c = 0, h = -a; e <= t; e++, h += s) {
                o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
                const t = e === r ? n : i;
                t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3
            }
            const c = new Ku;
            c.setAttribute("position", new Gu(o, 3)), c.setAttribute("color", new Gu(l, 3));
            super(c, new sg({vertexColors: !0, toneMapped: !1})), this.type = "GridHelper"
        }
    }.prototype.setColors = function () {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, class extends fg {
        constructor(e) {
            const t = k_(e), n = new Ku, i = [], r = [], s = new Nu(0, 0, 1), a = new Nu(0, 1, 0);
            for (let e = 0; e < t.length; e++) {
                const n = t[e];
                n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
            }
            n.setAttribute("position", new Gu(i, 3)), n.setAttribute("color", new Gu(r, 3));
            super(n, new sg({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0
            })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
        }

        updateMatrixWorld(e) {
            const t = this.bones, n = this.geometry, i = n.getAttribute("position");
            B_.copy(this.root.matrixWorld).invert();
            for (let e = 0, n = 0; e < t.length; e++) {
                const r = t[e];
                r.parent && r.parent.isBone && (N_.multiplyMatrices(B_, r.matrixWorld), D_.setFromMatrixPosition(N_), i.setXYZ(n, D_.x, D_.y, D_.z), N_.multiplyMatrices(B_, r.parent.matrixWorld), D_.setFromMatrixPosition(N_), i.setXYZ(n + 1, D_.x, D_.y, D_.z), n += 2)
            }
            n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
        }
    }.prototype.update = function () {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Vv.prototype.extractUrlBase = function (e) {
        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), u_.extractUrlBase(e)
    }, Vv.Handlers = {
        add: function () {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        }, get: function () {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    }, gh.prototype.center = function (e) {
        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, gh.prototype.empty = function () {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
    }, gh.prototype.isIntersectionBox = function (e) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
    }, gh.prototype.isIntersectionSphere = function (e) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
    }, gh.prototype.size = function (e) {
        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
    }, Nh.prototype.empty = function () {
        return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
    }, Od.prototype.setFromMatrix = function (e) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
    }, th.prototype.flattenToArrayOffset = function (e, t) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
    }, th.prototype.multiplyVector3 = function (e) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
    }, th.prototype.multiplyVector3Array = function () {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
    }, th.prototype.applyToBufferAttribute = function (e) {
        return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
    }, th.prototype.applyToVector3Array = function () {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
    }, th.prototype.getInverse = function (e) {
        return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
    }, Wh.prototype.extractPosition = function (e) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
    }, Wh.prototype.flattenToArrayOffset = function (e, t) {
        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
    }, Wh.prototype.getPosition = function () {
        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new ph).setFromMatrixColumn(this, 3)
    }, Wh.prototype.setRotationFromQuaternion = function (e) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
    }, Wh.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
    }, Wh.prototype.multiplyVector3 = function (e) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
    }, Wh.prototype.multiplyVector4 = function (e) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
    }, Wh.prototype.multiplyVector3Array = function () {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
    }, Wh.prototype.rotateAxis = function (e) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
    }, Wh.prototype.crossVector = function (e) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
    }, Wh.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.")
    }, Wh.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.")
    }, Wh.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.")
    }, Wh.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.")
    }, Wh.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
    }, Wh.prototype.applyToBufferAttribute = function (e) {
        return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
    }, Wh.prototype.applyToVector3Array = function () {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
    }, Wh.prototype.makeFrustum = function (e, t, n, i, r, s) {
        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, s)
    }, Wh.prototype.getInverse = function (e) {
        return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
    }, Rd.prototype.isIntersectionLine = function (e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, dh.prototype.multiplyVector3 = function (e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
    }, dh.prototype.inverse = function () {
        return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
    }, Vh.prototype.isIntersectionBox = function (e) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
    }, Vh.prototype.isIntersectionPlane = function (e) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
    }, Vh.prototype.isIntersectionSphere = function (e) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
    }, Mu.prototype.area = function () {
        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
    }, Mu.prototype.barycoordFromPoint = function (e, t) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
    }, Mu.prototype.midpoint = function (e) {
        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
    }, Mu.prototypenormal = function (e) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
    }, Mu.prototype.plane = function (e) {
        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
    }, Mu.barycoordFromPoint = function (e, t, n, i, r) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Mu.getBarycoord(e, t, n, i, r)
    }, Mu.normal = function (e, t, n, i) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Mu.getNormal(e, t, n, i)
    }, jg.prototype.extractAllPoints = function (e) {
        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
    }, jg.prototype.extrude = function (e) {
        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new xv(this, e)
    }, jg.prototype.makeGeometry = function (e) {
        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new wv(this, e)
    }, eh.prototype.fromAttribute = function (e, t, n) {
        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
    }, eh.prototype.distanceToManhattan = function (e) {
        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
    }, eh.prototype.lengthManhattan = function () {
        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }, ph.prototype.setEulerFromRotationMatrix = function () {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
    }, ph.prototype.setEulerFromQuaternion = function () {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
    }, ph.prototype.getPositionFromMatrix = function (e) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
    }, ph.prototype.getScaleFromMatrix = function (e) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
    }, ph.prototype.getColumnFromMatrix = function (e, t) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
    }, ph.prototype.applyProjection = function (e) {
        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
    }, ph.prototype.fromAttribute = function (e, t, n) {
        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
    }, ph.prototype.distanceToManhattan = function (e) {
        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
    }, ph.prototype.lengthManhattan = function () {
        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }, ch.prototype.fromAttribute = function (e, t, n) {
        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
    }, ch.prototype.lengthManhattan = function () {
        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }, mu.prototype.getChildByName = function (e) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
    }, mu.prototype.renderDepth = function () {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
    }, mu.prototype.translate = function (e, t) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
    }, mu.prototype.getWorldRotation = function () {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
    }, mu.prototype.applyMatrix = function (e) {
        return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
    }, Object.defineProperties(mu.prototype, {
        eulerOrder: {
            get: function () {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            }, set: function (e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        }, useQuaternion: {
            get: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }, set: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), fd.prototype.setDrawMode = function () {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
    }, Object.defineProperties(fd.prototype, {
        drawMode: {
            get: function () {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
            }, set: function () {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }), qm.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, wd.prototype.setLens = function (e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(Yv.prototype, {
        onlyShadow: {
            set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        }, shadowCameraFov: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        }, shadowCameraLeft: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        }, shadowCameraRight: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        }, shadowCameraTop: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        }, shadowCameraBottom: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        }, shadowCameraNear: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        }, shadowCameraFar: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        }, shadowCameraVisible: {
            set: function () {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        }, shadowBias: {
            set: function (e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        }, shadowDarkness: {
            set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        }, shadowMapWidth: {
            set: function (e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        }, shadowMapHeight: {
            set: function (e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(Fu.prototype, {
        length: {
            get: function () {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        }, dynamic: {
            get: function () {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Uc
            }, set: function () {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Uc)
            }
        }
    }), Fu.prototype.setDynamic = function (e) {
        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Uc : kc), this
    }, Fu.prototype.copyIndicesArray = function () {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
    }, Fu.prototype.setArray = function () {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }, Ku.prototype.addIndex = function (e) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
    }, Ku.prototype.addAttribute = function (e, t) {
        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new Fu(arguments[1], arguments[2])))
    }, Ku.prototype.addDrawCall = function (e, t, n) {
        void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
    }, Ku.prototype.clearDrawCalls = function () {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
    }, Ku.prototype.computeOffsets = function () {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
    }, Ku.prototype.removeAttribute = function (e) {
        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
    }, Ku.prototype.applyMatrix = function (e) {
        return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
    }, Object.defineProperties(Ku.prototype, {
        drawcalls: {
            get: function () {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        }, offsets: {
            get: function () {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Em.prototype.setDynamic = function (e) {
        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Uc : kc), this
    }, Em.prototype.setArray = function () {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }, xv.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
    }, xv.prototype.addShapeList = function () {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
    }, xv.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
    }, Sm.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.")
    }, Object.defineProperties(Lu.prototype, {
        wrapAround: {
            get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }, set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        }, overdraw: {
            get: function () {
                console.warn("THREE.Material: .overdraw has been removed.")
            }, set: function () {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        }, wrapRGB: {
            get: function () {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new Nu
            }
        }, shading: {
            get: function () {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            }, set: function (e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
            }
        }, stencilMask: {
            get: function () {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
            }, set: function (e) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
            }
        }, vertexTangents: {
            get: function () {
                console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
            }, set: function () {
                console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
            }
        }
    }), Object.defineProperties(xd.prototype, {
        derivatives: {
            get: function () {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            }, set: function (e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), wm.prototype.clearTarget = function (e, t, n, i) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i)
    },wm.prototype.animate = function (e) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
    },wm.prototype.getCurrentRenderTarget = function () {
        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
    },wm.prototype.getMaxAnisotropy = function () {
        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
    },wm.prototype.getPrecision = function () {
        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
    },wm.prototype.resetGLState = function () {
        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
    },wm.prototype.supportsFloatTextures = function () {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
    },wm.prototype.supportsHalfFloatTextures = function () {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
    },wm.prototype.supportsStandardDerivatives = function () {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
    },wm.prototype.supportsCompressedTextureS3TC = function () {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
    },wm.prototype.supportsCompressedTexturePVRTC = function () {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
    },wm.prototype.supportsBlendMinMax = function () {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
    },wm.prototype.supportsVertexTextures = function () {
        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
    },wm.prototype.supportsInstancedArrays = function () {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
    },wm.prototype.enableScissorTest = function (e) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
    },wm.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
    },wm.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
    },wm.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
    },wm.prototype.updateShadowMap = function () {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
    },wm.prototype.setFaceCulling = function () {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
    },wm.prototype.allocTextureUnit = function () {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
    },wm.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
    },wm.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
    },wm.prototype.setTextureCube = function () {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
    },wm.prototype.getActiveMipMapLevel = function () {
        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
    },Object.defineProperties(wm.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled
            }, set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        }, shadowMapType: {
            get: function () {
                return this.shadowMap.type
            }, set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        }, shadowMapCullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }, context: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
            }
        }, vr: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
            }
        }, gammaInput: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        }, gammaOutput: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
            }, set: function (e) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? Oc : Ic
            }
        }, toneMappingWhitePoint: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
            }
        }
    }),Object.defineProperties(dm.prototype, {
        cullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        }, renderReverseSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        }, renderSingleSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),Object.defineProperties(hh.prototype, {
        wrapS: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        }, wrapT: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        }, magFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        }, minFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        }, anisotropy: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        }, offset: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        }, repeat: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        }, format: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        }, type: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        }, generateMipmaps: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }),class extends mu {
        constructor(e) {
            super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
        }

        getOutput() {
            return this.gain
        }

        setNodeSource(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
        }

        setMediaElementSource(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
        }

        setMediaStreamSource(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
        }

        setBuffer(e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
        }

        play(e = 0) {
            if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
            if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
            this._startedAt = this.context.currentTime + e;
            const t = this.context.createBufferSource();
            return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
        }

        pause() {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }

        stop() {
            if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }

        connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this._connected = !0, this
        }

        disconnect() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this._connected = !1, this
        }

        getFilters() {
            return this.filters
        }

        setFilters(e) {
            return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
        }

        setDetune(e) {
            if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        }

        getDetune() {
            return this.detune
        }

        getFilter() {
            return this.getFilters()[0]
        }

        setFilter(e) {
            return this.setFilters(e ? [e] : [])
        }

        setPlaybackRate(e) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }

        getPlaybackRate() {
            return this.playbackRate
        }

        onEnded() {
            this.isPlaying = !1
        }

        getLoop() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        }

        setLoop(e) {
            if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }

        setLoopStart(e) {
            return this.loopStart = e, this
        }

        setLoopEnd(e) {
            return this.loopEnd = e, this
        }

        getVolume() {
            return this.gain.gain.value
        }

        setVolume(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        }
    }.prototype.load = function (e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const t = this;
        return (new m_).load(e, (function (e) {
            t.setBuffer(e)
        })), this
    },Sd.prototype.updateCubeMap = function (e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
    },Sd.prototype.clear = function (e, t, n, i) {
        return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, i)
    },sh.crossOrigin = void 0,sh.loadTexture = function (e, t, n, i) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const r = new qv;
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(e, n, void 0, i);
        return t && (s.mapping = t), s
    },sh.loadTextureCube = function (e, t, n, i) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const r = new Xv;
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(e, n, void 0, i);
        return t && (s.mapping = t), s
    },sh.loadCompressedTexture = function () {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    },sh.loadCompressedTextureCube = function () {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    },"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: "133"}})),"undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "133"),$l.use([ql, Kl, function ({
                                                                                                                                                                                                                                                                                                                                   swiper: e,
                                                                                                                                                                                                                                                                                                                                   extendParams: t,
                                                                                                                                                                                                                                                                                                                                   on: n,
                                                                                                                                                                                                                                                                                                                                   emit: i
                                                                                                                                                                                                                                                                                                                               }) {
        const r = tl(), s = il();

        function a(t) {
            if (!e.enabled) return;
            const {rtlTranslate: n} = e;
            let a = t;
            a.originalEvent && (a = a.originalEvent);
            const o = a.keyCode || a.charCode, l = e.params.keyboard.pageUpDown, c = l && 33 === o, h = l && 34 === o,
                u = 37 === o, d = 39 === o, p = 38 === o, f = 40 === o;
            if (!e.allowSlideNext && (e.isHorizontal() && d || e.isVertical() && f || h)) return !1;
            if (!e.allowSlidePrev && (e.isHorizontal() && u || e.isVertical() && p || c)) return !1;
            if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || r.activeElement && r.activeElement.nodeName && ("input" === r.activeElement.nodeName.toLowerCase() || "textarea" === r.activeElement.nodeName.toLowerCase()))) {
                if (e.params.keyboard.onlyInViewport && (c || h || u || d || p || f)) {
                    let t = !1;
                    if (e.$el.parents(`.${e.params.slideClass}`).length > 0 && 0 === e.$el.parents(`.${e.params.slideActiveClass}`).length) return;
                    const i = e.$el, r = i[0].clientWidth, a = i[0].clientHeight, o = s.innerWidth, l = s.innerHeight,
                        c = e.$el.offset();
                    n && (c.left -= e.$el[0].scrollLeft);
                    const h = [[c.left, c.top], [c.left + r, c.top], [c.left, c.top + a], [c.left + r, c.top + a]];
                    for (let e = 0; e < h.length; e += 1) {
                        const n = h[e];
                        if (n[0] >= 0 && n[0] <= o && n[1] >= 0 && n[1] <= l) {
                            if (0 === n[0] && 0 === n[1]) continue;
                            t = !0
                        }
                    }
                    if (!t) return
                }
                e.isHorizontal() ? ((c || h || u || d) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((h || d) && !n || (c || u) && n) && e.slideNext(), ((c || u) && !n || (h || d) && n) && e.slidePrev()) : ((c || h || p || f) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (h || f) && e.slideNext(), (c || p) && e.slidePrev()), i("keyPress", o)
            }
        }

        function o() {
            e.keyboard.enabled || (ol(r).on("keydown", a), e.keyboard.enabled = !0)
        }

        function l() {
            e.keyboard.enabled && (ol(r).off("keydown", a), e.keyboard.enabled = !1)
        }

        e.keyboard = {enabled: !1}, t({keyboard: {enabled: !1, onlyInViewport: !0, pageUpDown: !0}}), n("init", (() => {
            e.params.keyboard.enabled && o()
        })), n("destroy", (() => {
            e.keyboard.enabled && l()
        })), Object.assign(e.keyboard, {enable: o, disable: l})
    }]);
    const F_ = {
        centeredSlides: !0,
        slideToClickedSlide: !0,
        slidesPerView: "auto",
        grabCursor: !0,
        preloadImages: !1,
        keyboard: {enabled: !0, onlyInViewport: !0}
    };
    var H_, z_, G_;

    function V_(e) {
        for (let t = 0; t < e.slides.length; t++) e.slides[t].toggleAttribute("inert", t !== e.activeIndex)
    }

    !function (e) {
        e.NAVIGATION_PREVIOUS = ".swiper-button-prev", e.NAVIGATION_NEXT = ".swiper-button-next", e.PAGINATION = ".swiper-pagination"
    }(H_ || (H_ = {}));

    class W_ extends Hc {
        constructor(e, t = {}) {
            super();
            const n = e.querySelector(H_.NAVIGATION_PREVIOUS), i = e.querySelector(H_.NAVIGATION_NEXT),
                r = e.querySelector(H_.PAGINATION);
            this.settings = {...F_, ...t, navigation: {nextEl: i, prevEl: n}, pagination: {el: r, clickable: !0}}
        }
    }

    !function (e) {
        e.CAROUSEL = "data-carousel"
    }(z_ || (z_ = {})), $l.use([ql, Kl]);

    class j_ extends W_ {
        constructor(e, t = {}) {
            super(e, t), this.onActiveIndexChange = () => {
                V_(this.swiper)
            }, this.swiper = new $l(e, this.settings), this.addEventListeners(), V_(this.swiper)
        }

        addEventListeners() {
            this.swiper.on("activeIndexChange", this.onActiveIndexChange)
        }

        removeEventListeners() {
            this.swiper.off("activeIndexChange", this.onActiveIndexChange)
        }

        dispose() {
            this.removeEventListeners()
        }
    }

    !function (e) {
        e.CONTROLLER = "data-clipboard-controls", e.INPUT = "data-clipboard-input"
    }(G_ || (G_ = {}));

    class $_ {
        constructor(e) {
            this.button = e, this.onClick = () => {
                this.input && function (e, t) {
                    e.value = window.location.href, e.select(), e.setSelectionRange(0, e.value.length);
                    try {
                        document.execCommand("copy") || console.warn("failed to copy")
                    } catch (e) {
                        console.warn("failed to copy")
                    }
                    e.setSelectionRange(0, 0), t.focus()
                }(this.input, this.button)
            };
            const t = e.dataset.clipboardControls, n = `[${G_.INPUT}=${t}]`, i = document.querySelector(n);
            i && (this.input = i, e.addEventListener("click", this.onClick))
        }

        dispose() {
            this.button.removeEventListener("click", this.onClick)
        }
    }

    const X_ = document.getElementById("scroller");
    var q_, Y_;
    const K_ = window.navigator.userAgent.toLowerCase(), J_ = K_.indexOf("android") > -1,
        Z_ = !!(null === (q_ = K_.match(/android\s([0-9.]*)/i)) || void 0 === q_ ? void 0 : q_[1]),
        Q_ = "xr" in navigator && window.self.XRSession && (null === (Y_ = navigator.xr) || void 0 === Y_ ? void 0 : Y_.isSessionSupported),
        ey = Q_ && "requestHitTestSource" in window.self.XRSession.prototype,
        ty = Q_ && "domOverlayState" in window.self.XRSession.prototype;

    async function ny() {
        return !(!(Q_ && ey && ty) || (!J_ || !Z_) && J_) && await navigator.xr.isSessionSupported("immersive-ar")
    }

    var iy, ry;
    !function (e) {
        e.HAS_JS = "has-js", e.SUPPORTS_XR = "supports-xr", e.SUPPORTS_SHARE = "supports-share", e.HAS_SCROLL_BAR = "has-scroll-bar-visible", e.IS_IOS = "is-ios"
    }(iy || (iy = {})), function (e) {
        e.VH = "--vh", e.SLIDE_VH = "--slide-vh", e.SCROLLBAR_WIDTH = "--scrollbar-width"
    }(ry || (ry = {}));

    function sy(e) {
        document.body.classList.toggle(iy.SUPPORTS_XR, e);
        const t = e ? Dr.SUPPORTED : Dr.UNSUPPORTED;
        Br(Or.CAPABILITIES, {label: "WebXR", action: t})
    }

    class ay {
        constructor() {
            this.previousWindowHeight = 0, document.body.classList.add(iy.HAS_JS), document.body.classList.toggle(iy.IS_IOS, /iPhone|iPad|iPod/i.test(navigator.userAgent)), document.body.classList.toggle(iy.SUPPORTS_SHARE, !!navigator.share), ny().then(sy)
        }

        resize() {
            const {innerWidth: e, innerHeight: t} = window, n = `${t}px`, i = t < this.previousWindowHeight,
                r = Math.abs(t - this.previousWindowHeight);
            (i || r > 80 || e >= 1024) && (document.body.style.setProperty(ry.SLIDE_VH, n), this.previousWindowHeight = t);
            const s = X_.clientWidth, a = document.body.scrollWidth > s;
            document.body.classList.toggle(iy.HAS_SCROLL_BAR, a);
            const o = e - s;
            document.body.style.setProperty(ry.SCROLLBAR_WIDTH, `${o}px`)
        }
    }

    class oy {
        constructor(e) {
            this.element = e, this.onClick = async () => {
                Br(this.category, {action: this.action, label: this.label, nonInteraction: !1})
            };
            const t = this.element.dataset;
            this.category = t.gtmCategory, this.action = t.gtmAction, this.label = t.gtmLabel, this.element.addEventListener("click", this.onClick)
        }

        dispose() {
            this.element.removeEventListener("click", this.onClick)
        }
    }

    class ly {
        constructor(e) {
            this.selector = e, this.setLocale = e => {
                const t = e.target, n = new URL(window.location.origin), i = new URLSearchParams(n.searchParams),
                    r = window.location.pathname;
                i.append("hl", t.value), window.history.replaceState({}, "", `${r}?${i}`), location.reload()
            }, this.addEventListeners()
        }

        addEventListeners() {
            this.selector.addEventListener("change", this.setLocale)
        }

        removeEventListeners() {
            this.selector.removeEventListener("change", this.setLocale)
        }
    }

    var cy;
    !function (e) {
        e.OVERLAY = "data-overlay", e.TOGGLE = "data-overlay-toggle"
    }(cy || (cy = {}));

    class hy {
        constructor(e) {
            this.overlay = e, this.onClick = () => {
                this.overlay.open = !this.overlay.open
            }, this.onClose = () => {
                this.overlay.open = !1
            }, this.identifier = e.dataset.overlay, this.buttons = document.querySelectorAll(`[${cy.TOGGLE}="${this.identifier}"]`), this.addEventListeners()
        }

        addEventListeners() {
            this.overlay.addEventListener(kr.CLOSE_REQUESTED, this.onClose);
            for (let e = 0; e < this.buttons.length; e++) this.buttons[e].addEventListener("click", this.onClick)
        }

        removeEventListeners() {
            this.overlay.removeEventListener(kr.CLOSE_REQUESTED, this.onClose);
            for (let e = 0; e < this.buttons.length; e++) this.buttons[e].removeEventListener("click", this.onClick)
        }
    }

    const uy = "active";

    class dy {
        constructor(e) {
            this.listItems = e, this._activeIndex = 0, this.items = bi.utils.toArray(e), this.activeIndex = 0
        }

        get activeIndex() {
            return this._activeIndex
        }

        set activeIndex(e) {
            (function (e, t, n, i = !0) {
                const r = Math.min(t, n), s = Math.max(t, n);
                return i ? e >= r && e <= s : e > r && e < s
            })(e, 0, this.items.length) && (this.items[this._activeIndex].classList.remove(uy), this._activeIndex = e, this.items[e].classList.add(uy))
        }
    }

    var py, fy, my, gy, vy;
    !function (e) {
        e.PLAY_STATE = "play-state", e.CHAPTER_SEEK = "chapter-seek", e.STEP = "step"
    }(py || (py = {})), function (e) {
        e.PLAY = "[data-podcast-play]", e.CHAPTER_SEEK = "[data-podcast-chapter-seek]", e.STEP = "[data-podcast-step]", e.SEEK = "[data-podcast-seek]"
    }(fy || (fy = {})), function (e) {
        e.NEXT = "next", e.PREVIOUS = "previous"
    }(my || (my = {}));

    class _y extends Hc {
        constructor() {
            super(...arguments), this.buttons = {
                play: document.querySelectorAll(fy.PLAY),
                chapterSeek: document.querySelectorAll(fy.CHAPTER_SEEK),
                step: document.querySelectorAll(fy.STEP),
                seek: document.querySelectorAll(fy.SEEK)
            }, this.onPlayState = () => {
                this.dispatchEvent({type: py.PLAY_STATE})
            }, this.onChapterSeek = e => {
                const t = e.currentTarget.dataset.podcastChapterSeek;
                this.dispatchEvent({type: py.CHAPTER_SEEK, direction: t})
            }, this.onStep = e => {
                const t = e.currentTarget.dataset.podcastStep;
                this.dispatchEvent({type: py.STEP, direction: t})
            }
        }

        addEventListeners() {
            for (let e = 0; e < this.buttons.play.length; e++) this.buttons.play[e].addEventListener("click", this.onPlayState);
            for (let e = 0; e < this.buttons.chapterSeek.length; e++) this.buttons.chapterSeek[e].addEventListener("click", this.onChapterSeek);
            for (let e = 0; e < this.buttons.step.length; e++) this.buttons.step[e].addEventListener("click", this.onStep)
        }

        removeEventListeners() {
            for (let e = 0; e < this.buttons.play.length; e++) this.buttons.play[e].removeEventListener("click", this.onPlayState);
            for (let e = 0; e < this.buttons.chapterSeek.length; e++) this.buttons.chapterSeek[e].removeEventListener("click", this.onChapterSeek);
            for (let e = 0; e < this.buttons.step.length; e++) this.buttons.step[e].removeEventListener("click", this.onStep)
        }

        updatePlayState(e) {
            for (let t = 0; t < this.buttons.play.length; t++) this.buttons.play[t].classList.toggle("playing", !e)
        }

        dispose() {
            this.removeEventListeners()
        }
    }

    !function (e) {
        e.TRACK = ".progress-bar__track", e.HANDLE = ".progress-bar__handle", e.HANDLE_TRANSFORM = ".progress-bar__handle-transform", e.BAR = ".progress-bar__fill", e.BUFFER = ".progress-bar__buffer", e.POI = ".progress-bar__poi"
    }(gy || (gy = {})), function (e) {
        e.REQUEST_SEEK = "request-seek"
    }(vy || (vy = {}));

    class yy extends Hc {
        constructor(e) {
            super(), this.element = e, this.pointerDown = !1, this.handleTransform = this.element.querySelector(gy.HANDLE_TRANSFORM), this.handle = this.element.querySelector(gy.HANDLE), this.track = this.element.querySelector(gy.TRACK), this.bar = this.element.querySelector(gy.BAR), this.buffer = this.element.querySelector(gy.BUFFER), this.pointsOfInterest = this.element.querySelectorAll(gy.POI), this.onTrackPointerDown = e => {
                this.pointerDown = !0, this.seekToPointer(e.x)
            }, this.onPointerMove = e => {
                this.pointerDown && this.seekToPointer(e.x)
            }, this.onPointerUp = () => {
                this.pointerDown = !1
            }, this.bcr = e.getBoundingClientRect(), this.addEventListeners()
        }

        seekToPointer(e) {
            const {left: t, width: n} = this.bcr, i = (e - t) / n;
            this.dispatchEvent({type: vy.REQUEST_SEEK, x: i})
        }

        setTransform(e, t) {
            this.handleTransform && (this.handleTransform.style.transform = `translateX(${100 * e}%)`), this.bar && (this.bar.style.transform = `scaleX(${e})`), this.buffer && (this.buffer.style.transform = `scaleX(${t})`)
        }

        addEventListeners() {
            this.element.addEventListener("pointerdown", this.onTrackPointerDown), window.addEventListener("pointermove", this.onPointerMove), window.addEventListener("pointerup", this.onPointerUp)
        }

        removeEventListeners() {
            this.element.removeEventListener("pointerdown", this.onTrackPointerDown), window.removeEventListener("pointermove", this.onPointerMove), window.removeEventListener("pointerup", this.onPointerUp)
        }

        update(e, t) {
            !function (e, t) {
                const n = t.toFixed(2);
                e.setAttribute("aria-valuenow", `${n}`)
            }(this.element, e), this.setTransform(e, t)
        }

        resize() {
            this.bcr = this.element.getBoundingClientRect()
        }

        dispose() {
            this.removeEventListeners()
        }
    }

    function xy(e) {
        const t = Math.floor(e / 60), n = Math.floor(e % 60);
        return `${t}:${n >= 10 ? "" : "0"}${n}`
    }

    var by;
    !function (e) {
        e.AUDIO = "audio", e.TRACK = "track", e.CHAPTERS = ".podcast__chapters", e.PROGRESS_BAR = "[data-progress-bar]", e.CURRENT_TIME = "[data-podcast-current-time]", e.TOTAL_TIME = "[data-podcast-total-time]"
    }(by || (by = {}));

    class wy {
        constructor(e) {
            this.overlay = e, this.audio = this.overlay.querySelector(by.AUDIO), this.vtt = this.audio.querySelector(by.TRACK), this.currentTimeElement = this.overlay.querySelector(by.CURRENT_TIME), this.totalTimeElement = this.overlay.querySelector(by.TOTAL_TIME), this.controls = new _y, this.chapterReachedFlags = new Array(Nr.length).fill(!1), this.vttCues = [], this.reachedEndOnce = !1, this.onLoaded = () => {
                this.cueListToArray()
            }, this.onOpen = () => {
                this.resize(), this.audio.play()
            }, this.onClose = () => {
                this.audio.pause()
            }, this.onEnded = () => {
                this.reachedEndOnce || (Br(Or.PODCAST, {action: Dr.REACHED_END}), this.reachedEndOnce = !0)
            }, this.onSeekRequest = e => {
                this.audio.currentTime = this.audio.duration * e.x
            }, this.onTimeUpdate = () => {
                const {currentTime: e, duration: t} = this.audio, n = this.audio.currentTime / this.audio.duration,
                    i = (r = this.audio).buffered.end(r.buffered.length - 1) / r.duration;
                var r;
                if (this.progressBar.update(n, i), this.currentTimeElement) {
                    const t = xy(e);
                    this.currentTimeElement.dateTime = t, this.currentTimeElement.textContent = t
                }
                if (this.totalTimeElement) {
                    const e = xy(t);
                    this.totalTimeElement.dateTime = e, this.totalTimeElement.textContent = e
                }
            }, this.onCueChange = () => {
                var e;
                if (!this.vtt) return;
                const t = null === (e = this.vtt.track.activeCues) || void 0 === e ? void 0 : e[0];
                if (!(null == t ? void 0 : t.text)) return;
                const n = Number(t.text);
                this.chapterTitles && (this.chapterTitles.activeIndex = n), this.chapterReachedFlags[n] || (Br(Or.PODCAST, {
                    action: Dr.REACHED_CHAPTER,
                    label: Nr[n]
                }), this.chapterReachedFlags[n] = !0)
            }, this.onPlayStateRequest = async () => {
                let e;
                this.audio.paused ? (await this.audio.play(), e = Dr.PLAY) : (this.audio.pause(), e = Dr.PAUSE), Br(Or.PODCAST, {
                    action: e,
                    nonInteraction: !1
                })
            }, this.onPlayState = () => {
                this.controls.updatePlayState(!this.audio.paused)
            }, this.onStep = e => {
                this.stepTo(e.direction)
            }, this.onChapterSeek = e => {
                if (!this.vtt) return;
                const t = e.direction, n = this.activeCueIndex, i = this.vttCues[n],
                    r = Math.abs(i.startTime - this.audio.currentTime), s = t === my.NEXT;
                if (!s && r > 5) this.audio.currentTime = i.startTime; else {
                    const e = n + (s ? 1 : -1),
                        t = (a = 0, o = this.vttCues.length - 1, l = e, Math.min(Math.max(l, a), o)),
                        i = this.vttCues[t];
                    this.audio.currentTime = i.startTime;
                    const r = s ? Dr.SKIP_CHAPTER_FORWARD : Dr.SKIP_CHAPTER_BACKWARD;
                    Br(Or.PODCAST, {action: r, label: Nr[t], nonInteraction: !1})
                }
                var a, o, l;
                this.audio.paused && this.audio.play()
            }, this.onKeyDown = e => {
                switch (e.key) {
                    case"ArrowRight":
                        this.stepTo(my.NEXT);
                        break;
                    case"ArrowLeft":
                        this.stepTo(my.PREVIOUS)
                }
            };
            const t = e.querySelector(by.PROGRESS_BAR);
            this.progressBar = new yy(t);
            const n = e.querySelector(by.CHAPTERS);
            n && n.children.length && (this.chapterTitles = new dy(n.children)), this.addEventListeners()
        }

        get activeCueIndex() {
            var e, t;
            const n = null === (t = null === (e = this.vtt) || void 0 === e ? void 0 : e.track.activeCues) || void 0 === t ? void 0 : t[0];
            return n ? Number(n.text) : this.chapterTitles ? this.chapterTitles.activeIndex + 1 : 0
        }

        resize() {
            this.progressBar.resize()
        }

        dispose() {
            this.controls.dispose(), this.progressBar.dispose(), this.removeEventListeners()
        }

        cueListToArray() {
            var e;
            const t = null === (e = this.vtt) || void 0 === e ? void 0 : e.track.cues;
            if (t) for (let e = 0; e < t.length; e++) {
                const n = t[e];
                this.vttCues.push(n);
                const i = n.startTime / this.audio.duration * 100 + "%";
                this.progressBar.pointsOfInterest[e].style.left = i
            }
        }

        addEventListeners() {
            this.audio.addEventListener("loadedmetadata", this.onLoaded), this.audio.addEventListener("play", this.onPlayState), this.audio.addEventListener("pause", this.onPlayState), this.audio.addEventListener("timeupdate", this.onTimeUpdate), this.audio.addEventListener("ended", this.onEnded), this.overlay.addEventListener(kr.OPEN, this.onOpen), this.overlay.addEventListener(kr.CLOSE, this.onClose), this.overlay.addEventListener("keydown", this.onKeyDown), this.progressBar.addEventListener(vy.REQUEST_SEEK, this.onSeekRequest), this.vtt && this.vtt.addEventListener("cuechange", this.onCueChange), this.controls.addEventListeners(), this.controls.addEventListener(py.STEP, this.onStep), this.controls.addEventListener(py.CHAPTER_SEEK, this.onChapterSeek), this.controls.addEventListener(py.PLAY_STATE, this.onPlayStateRequest)
        }

        removeEventListeners() {
            this.audio.removeEventListener("loadedmetadata", this.onLoaded), this.audio.removeEventListener("play", this.onPlayState), this.audio.removeEventListener("pause", this.onPlayState), this.audio.removeEventListener("timeupdate", this.onTimeUpdate), this.audio.removeEventListener("ended", this.onEnded), this.overlay.removeEventListener(kr.OPEN, this.onOpen), this.overlay.removeEventListener(kr.CLOSE, this.onClose), this.overlay.removeEventListener("keydown", this.onKeyDown), this.progressBar.removeEventListener(vy.REQUEST_SEEK, this.onSeekRequest), this.vtt && this.vtt.removeEventListener("cuechange", this.onCueChange), this.controls.removeEventListeners(), this.controls.removeEventListener(py.STEP, this.onStep), this.controls.removeEventListener(py.CHAPTER_SEEK, this.onChapterSeek), this.controls.removeEventListener(py.PLAY_STATE, this.onPlayStateRequest)
        }

        stepTo(e) {
            const t = e === my.NEXT, n = t ? 1 : -1;
            this.audio.currentTime += 10 * n;
            const i = t ? Dr.JUMP_FORWARD : Dr.JUMP_BACKWARD;
            Br(Or.PODCAST, {action: i, nonInteraction: !1})
        }
    }

    var Ty, Sy;
    !function (e) {
        e.BUTTON = "data-share-button"
    }(Ty || (Ty = {}));

    class Ey {
        constructor(e) {
            this.element = e, this.onClick = async () => {
                try {
                    await navigator.share(this.shareData)
                } catch (e) {
                    console.warn(e)
                }
            }, this.shareData = {
                title: e.dataset.shareTitle,
                text: e.dataset.shareText,
                url: e.dataset.shareUrl
            }, e.addEventListener("click", this.onClick)
        }

        dispose() {
            this.element.addEventListener("click", this.onClick)
        }
    }

    !function (e) {
        e.CONTROLLER = "data-video-controller", e.VIDEO = "data-video-id"
    }(Sy || (Sy = {}));

    class My {
        constructor(e) {
            this.pauseButton = e, this.onButtonClick = async () => {
                this.video && (this.video.paused ? await this.video.play() : this.video.pause())
            }, this.onPlayStateChange = () => {
                this.video && this.pauseButton.classList.toggle("playing", !this.video.paused)
            }, this.id = this.pauseButton.dataset.videoController;
            const t = `[${Sy.VIDEO}=${this.id}]`;
            this.video = document.querySelector(t), this.video ? (this.pauseButton.addEventListener("click", this.onButtonClick), this.video.addEventListener("pause", this.onPlayStateChange), this.video.addEventListener("play", this.onPlayStateChange)) : console.warn("video not found", this.id)
        }

        dispose() {
            var e, t;
            this.pauseButton.removeEventListener("click", this.onButtonClick), null === (e = this.video) || void 0 === e || e.removeEventListener("pause", this.onPlayStateChange), null === (t = this.video) || void 0 === t || t.removeEventListener("play", this.onPlayStateChange)
        }
    }

    const Ay = window.matchMedia("(prefers-reduced-motion: reduce), (update: none), (update: slow)");

    function Ly() {
        return Ay.matches
    }

    class Cy {
        constructor(e) {
            this.element = e, this.onCanPlayThrough = () => {
                this.element.classList.add("canplaythrough")
            }, this.onReducedMotionChange = e => {
                const t = e.matches;
                this.setAutoplay(!t)
            }, this.addEventListeners(), this.documentVisibilityChange()
        }

        documentVisibilityChange() {
            if ("visible" !== document.visibilityState) return;
            Ly() ? this.element.play().then((() => this.element.pause())) : (this.setAutoplay(!0), this.element.play())
        }

        setAutoplay(e) {
            this.element.autoplay = e, this.element.autoplay || this.element.pause()
        }

        addEventListeners() {
            this.element.addEventListener("canplaythrough", this.onCanPlayThrough), Ay.addListener(this.onReducedMotionChange)
        }

        removeEventListeners() {
            this.element.removeEventListener("canplaythrough", this.onCanPlayThrough), Ay.removeListener(this.onReducedMotionChange)
        }

        dispose() {
            this.removeEventListeners()
        }
    }

    function Ry(e) {
        const t = bi.timeline({scrollTrigger: {trigger: e, scroller: X_, scrub: !0}});
        return t.fromTo(e, {alpha: 0}, {alpha: 1, duration: 1}), t.to(e, {duration: 1}), t.to(e, {
            alpha: 0,
            duration: .5
        }), t
    }

    const Py = (e, t) => {
        let n = null;
        return (...i) => {
            null !== n && self.clearTimeout(n), n = self.setTimeout((() => {
                n = null, e(...i)
            }), t)
        }
    };

    class Iy {
        constructor(e, t, n) {
            this._aspect = 0, this._pixelRatio = 0, this.vec2 = new eh, this.maxPixelRatio = 1.5, this.resize(e, t, n)
        }

        get width() {
            return this.vec2.width
        }

        get height() {
            return this.vec2.height
        }

        get aspect() {
            return this._aspect
        }

        get pixelRatio() {
            return this._pixelRatio
        }

        resize(e, t, n) {
            n && (this._pixelRatio = Math.min(n, this.maxPixelRatio)), this.vec2.width = e, this.vec2.height = t, this._aspect = e / t
        }
    }

    const Oy = {antialias: !1, alpha: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", stencil: !1};

    function Dy(e, t, n, i) {
        return new eh(n / e * 2 - 1, -i / t * 2 + 1)
    }

    const Ny = "../assets/webgl/", By = "is-in-xr";
    var ky, Uy, Fy, Hy;
    !function (e) {
        e[e.UP = -1] = "UP", e[e.NONE = 0] = "NONE", e[e.DOWN = 1] = "DOWN"
    }(ky || (ky = {})), function (e) {
        e.ARROW_UP = "ArrowUp", e.ARROW_DOWN = "ArrowDown"
    }(Uy || (Uy = {})), function (e) {
        e.POWER_1_IN_OUT = "power1.inOut", e.POWER_1_OUT = "power1.out", e.POWER_2_IN_OUT = "power2.inOut", e.POWER_2_OUT = "power2.out", e.POWER_3_IN_OUT = "power3.inOut"
    }(Fy || (Fy = {})), function (e) {
        e.POINTER_DOWN = "pointerdown", e.POINTER_MOVE = "pointermove", e.POINTER_UP = "pointerup", e.RESIZE = "resize", e.VISIBILITY_CHANGE = "visibilitychange"
    }(Hy || (Hy = {}));
    const zy = `${Ny}transcoders/basis/`, Gy = `${Ny}transcoders/draco/`,
        Vy = `${Ny}textures/utilities/check-ktx2-support.ktx2`;

    class Wy extends Hc {
        constructor(e) {
            super(), this.boundaries = e
        }

        pointerDown(e) {
            this.dispatchEvent({type: Hy.POINTER_DOWN, pointer: e})
        }

        pointerMove(e) {
            this.dispatchEvent({type: Hy.POINTER_MOVE, pointer: e})
        }

        pointerUp() {
            this.dispatchEvent({type: Hy.POINTER_UP})
        }

        visibilityChange(e) {
            this.dispatchEvent({type: Hy.VISIBILITY_CHANGE, visible: e})
        }

        resize(e) {
            this.dispatchEvent({type: Hy.RESIZE, boundaries: e})
        }
    }

    const jy = new WeakMap;

    class $y extends Vv {
        constructor(e) {
            super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
            }, this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
            }
        }

        setDecoderPath(e) {
            return this.decoderPath = e, this
        }

        setDecoderConfig(e) {
            return this.decoderConfig = e, this
        }

        setWorkerLimit(e) {
            return this.workerLimit = e, this
        }

        load(e, t, n, i) {
            const r = new jv(this.manager);
            r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (e => {
                const n = {
                    attributeIDs: this.defaultAttributeIDs,
                    attributeTypes: this.defaultAttributeTypes,
                    useUniqueIDs: !1
                };
                this.decodeGeometry(e, n).then(t).catch(i)
            }), n, i)
        }

        decodeDracoFile(e, t, n, i) {
            const r = {
                attributeIDs: n || this.defaultAttributeIDs,
                attributeTypes: i || this.defaultAttributeTypes,
                useUniqueIDs: !!n
            };
            this.decodeGeometry(e, r).then(t)
        }

        decodeGeometry(e, t) {
            for (const e in t.attributeTypes) {
                const n = t.attributeTypes[e];
                void 0 !== n.BYTES_PER_ELEMENT && (t.attributeTypes[e] = n.name)
            }
            const n = JSON.stringify(t);
            if (jy.has(e)) {
                const t = jy.get(e);
                if (t.key === n) return t.promise;
                if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
            }
            let i;
            const r = this.workerNextTaskID++, s = e.byteLength,
                a = this._getWorker(r, s).then((n => (i = n, new Promise(((n, s) => {
                    i._callbacks[r] = {resolve: n, reject: s}, i.postMessage({
                        type: "decode",
                        id: r,
                        taskConfig: t,
                        buffer: e
                    }, [e])
                }))))).then((e => this._createGeometry(e.geometry)));
            return a.catch((() => !0)).then((() => {
                i && r && this._releaseTask(i, r)
            })), jy.set(e, {key: n, promise: a}), a
        }

        _createGeometry(e) {
            const t = new Ku;
            e.index && t.setIndex(new Fu(e.index.array, 1));
            for (let n = 0; n < e.attributes.length; n++) {
                const i = e.attributes[n], r = i.name, s = i.array, a = i.itemSize;
                t.setAttribute(r, new Fu(s, a))
            }
            return t
        }

        _loadLibrary(e, t) {
            const n = new jv(this.manager);
            return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, i) => {
                n.load(e, t, void 0, i)
            }))
        }

        preload() {
            return this._initDecoder(), this
        }

        _initDecoder() {
            if (this.decoderPending) return this.decoderPending;
            const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t = [];
            return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                const n = t[0];
                e || (this.decoderConfig.wasmBinary = t[1]);
                const i = Xy.toString(),
                    r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                this.workerSourceURL = URL.createObjectURL(new Blob([r]))
            })), this.decoderPending
        }

        _getWorker(e, t) {
            return this._initDecoder().then((() => {
                if (this.workerPool.length < this.workerLimit) {
                    const e = new Worker(this.workerSourceURL);
                    e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                        type: "init",
                        decoderConfig: this.decoderConfig
                    }), e.onmessage = function (t) {
                        const n = t.data;
                        switch (n.type) {
                            case"decode":
                                e._callbacks[n.id].resolve(n);
                                break;
                            case"error":
                                e._callbacks[n.id].reject(n);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                        }
                    }, this.workerPool.push(e)
                } else this.workerPool.sort((function (e, t) {
                    return e._taskLoad > t._taskLoad ? -1 : 1
                }));
                const n = this.workerPool[this.workerPool.length - 1];
                return n._taskCosts[e] = t, n._taskLoad += t, n
            }))
        }

        _releaseTask(e, t) {
            e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
        }

        debug() {
            console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
        }

        dispose() {
            for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
            return this.workerPool.length = 0, this
        }
    }

    function Xy() {
        let e, t;

        function n(e, t, n, i, r, s) {
            const a = s.num_components(), o = n.num_points() * a, l = o * r.BYTES_PER_ELEMENT, c = function (e, t) {
                switch (t) {
                    case Float32Array:
                        return e.DT_FLOAT32;
                    case Int8Array:
                        return e.DT_INT8;
                    case Int16Array:
                        return e.DT_INT16;
                    case Int32Array:
                        return e.DT_INT32;
                    case Uint8Array:
                        return e.DT_UINT8;
                    case Uint16Array:
                        return e.DT_UINT16;
                    case Uint32Array:
                        return e.DT_UINT32
                }
            }(e, r), h = e._malloc(l);
            t.GetAttributeDataArrayForAllPoints(n, s, c, l, h);
            const u = new r(e.HEAPF32.buffer, h, o).slice();
            return e._free(h), {name: i, array: u, itemSize: a}
        }

        onmessage = function (i) {
            const r = i.data;
            switch (r.type) {
                case"init":
                    e = r.decoderConfig, t = new Promise((function (t) {
                        e.onModuleLoaded = function (e) {
                            t({draco: e})
                        }, DracoDecoderModule(e)
                    }));
                    break;
                case"decode":
                    const i = r.buffer, s = r.taskConfig;
                    t.then((e => {
                        const t = e.draco, a = new t.Decoder, o = new t.DecoderBuffer;
                        o.Init(new Int8Array(i), i.byteLength);
                        try {
                            const e = function (e, t, i, r) {
                                const s = r.attributeIDs, a = r.attributeTypes;
                                let o, l;
                                const c = t.GetEncodedGeometryType(i);
                                if (c === e.TRIANGULAR_MESH) o = new e.Mesh, l = t.DecodeBufferToMesh(i, o); else {
                                    if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                    o = new e.PointCloud, l = t.DecodeBufferToPointCloud(i, o)
                                }
                                if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                const h = {index: null, attributes: []};
                                for (const i in s) {
                                    const l = self[a[i]];
                                    let c, u;
                                    if (r.useUniqueIDs) u = s[i], c = t.GetAttributeByUniqueId(o, u); else {
                                        if (u = t.GetAttributeId(o, e[s[i]]), -1 === u) continue;
                                        c = t.GetAttribute(o, u)
                                    }
                                    h.attributes.push(n(e, t, o, i, l, c))
                                }
                                c === e.TRIANGULAR_MESH && (h.index = function (e, t, n) {
                                    const i = 3 * n.num_faces(), r = 4 * i, s = e._malloc(r);
                                    t.GetTrianglesUInt32Array(n, r, s);
                                    const a = new Uint32Array(e.HEAPF32.buffer, s, i).slice();
                                    return e._free(s), {array: a, itemSize: 1}
                                }(e, t, o));
                                return e.destroy(o), h
                            }(t, a, o, s), i = e.attributes.map((e => e.array.buffer));
                            e.index && i.push(e.index.array.buffer), self.postMessage({
                                type: "decode",
                                id: r.id,
                                geometry: e
                            }, i)
                        } catch (e) {
                            console.error(e), self.postMessage({type: "error", id: r.id, error: e.message})
                        } finally {
                            t.destroy(o), t.destroy(a)
                        }
                    }))
            }
        }
    }

    class qy extends Vv {
        constructor(e) {
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) {
                return new Qy(e)
            })), this.register((function (e) {
                return new rx(e)
            })), this.register((function (e) {
                return new sx(e)
            })), this.register((function (e) {
                return new ex(e)
            })), this.register((function (e) {
                return new tx(e)
            })), this.register((function (e) {
                return new nx(e)
            })), this.register((function (e) {
                return new ix(e)
            })), this.register((function (e) {
                return new Jy(e)
            })), this.register((function (e) {
                return new ax(e)
            }))
        }

        load(e, t, n, i) {
            const r = this;
            let s;
            s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : u_.extractUrlBase(e), this.manager.itemStart(e);
            const a = function (t) {
                i ? i(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e)
            }, o = new jv(this.manager);
            o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function (n) {
                try {
                    r.parse(n, s, (function (n) {
                        t(n), r.manager.itemEnd(e)
                    }), a)
                } catch (e) {
                    a(e)
                }
            }), n, a)
        }

        setDRACOLoader(e) {
            return this.dracoLoader = e, this
        }

        setDDSLoader() {
            throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
        }

        setKTX2Loader(e) {
            return this.ktx2Loader = e, this
        }

        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this
        }

        register(e) {
            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
        }

        unregister(e) {
            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
        }

        parse(e, t, n, i) {
            let r;
            const s = {}, a = {};
            if ("string" == typeof e) r = e; else {
                if (u_.decodeText(new Uint8Array(e, 0, 4)) === ox) {
                    try {
                        s[Ky.KHR_BINARY_GLTF] = new hx(e)
                    } catch (e) {
                        return void (i && i(e))
                    }
                    r = s[Ky.KHR_BINARY_GLTF].content
                } else r = u_.decodeText(new Uint8Array(e))
            }
            const o = JSON.parse(r);
            if (void 0 === o.asset || o.asset.version[0] < 2) return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
            const l = new Wx(o, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for (let e = 0; e < this.pluginCallbacks.length; e++) {
                const t = this.pluginCallbacks[e](l);
                a[t.name] = t, s[t.name] = !0
            }
            if (o.extensionsUsed) for (let e = 0; e < o.extensionsUsed.length; ++e) {
                const t = o.extensionsUsed[e], n = o.extensionsRequired || [];
                switch (t) {
                    case Ky.KHR_MATERIALS_UNLIT:
                        s[t] = new Zy;
                        break;
                    case Ky.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                        s[t] = new fx;
                        break;
                    case Ky.KHR_DRACO_MESH_COMPRESSION:
                        s[t] = new ux(o, this.dracoLoader);
                        break;
                    case Ky.KHR_TEXTURE_TRANSFORM:
                        s[t] = new dx;
                        break;
                    case Ky.KHR_MESH_QUANTIZATION:
                        s[t] = new mx;
                        break;
                    default:
                        n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                }
            }
            l.setExtensions(s), l.setPlugins(a), l.parse(n, i)
        }
    }

    function Yy() {
        let e = {};
        return {
            get: function (t) {
                return e[t]
            }, add: function (t, n) {
                e[t] = n
            }, remove: function (t) {
                delete e[t]
            }, removeAll: function () {
                e = {}
            }
        }
    }

    const Ky = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
    };

    class Jy {
        constructor(e) {
            this.parser = e, this.name = Ky.KHR_LIGHTS_PUNCTUAL, this.cache = {refs: {}, uses: {}}
        }

        _markDefs() {
            const e = this.parser, t = this.parser.json.nodes || [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
            }
        }

        _loadLight(e) {
            const t = this.parser, n = "light:" + e;
            let i = t.cache.get(n);
            if (i) return i;
            const r = t.json, s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
            let a;
            const o = new Nu(16777215);
            void 0 !== s.color && o.fromArray(s.color);
            const l = void 0 !== s.range ? s.range : 0;
            switch (s.type) {
                case"directional":
                    a = new l_(o), a.target.position.set(0, 0, -1), a.add(a.target);
                    break;
                case"point":
                    a = new a_(o), a.distance = l;
                    break;
                case"spot":
                    a = new t_(o), a.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, a.angle = s.spot.outerConeAngle, a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
            }
            return a.position.set(0, 0, 0), a.decay = 2, void 0 !== s.intensity && (a.intensity = s.intensity), a.name = t.createUniqueName(s.name || "light_" + e), i = Promise.resolve(a), t.cache.add(n, i), i
        }

        createNodeAttachment(e) {
            const t = this, n = this.parser, i = n.json.nodes[e],
                r = (i.extensions && i.extensions[this.name] || {}).light;
            return void 0 === r ? null : this._loadLight(r).then((function (e) {
                return n._getNodeRef(t.cache, r, e)
            }))
        }
    }

    class Zy {
        constructor() {
            this.name = Ky.KHR_MATERIALS_UNLIT
        }

        getMaterialType() {
            return Bu
        }

        extendParams(e, t, n) {
            const i = [];
            e.color = new Nu(1, 1, 1), e.opacity = 1;
            const r = t.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    const t = r.baseColorFactor;
                    e.color.fromArray(t), e.opacity = t[3]
                }
                void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture))
            }
            return Promise.all(i)
        }
    }

    class Qy {
        constructor(e) {
            this.parser = e, this.name = Ky.KHR_MATERIALS_CLEARCOAT
        }

        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Sv : null
        }

        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [], s = i.extensions[this.name];
            if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                const e = s.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new eh(e, e)
            }
            return Promise.all(r)
        }
    }

    class ex {
        constructor(e) {
            this.parser = e, this.name = Ky.KHR_MATERIALS_TRANSMISSION
        }

        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Sv : null
        }

        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [], s = i.extensions[this.name];
            return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r)
        }
    }

    class tx {
        constructor(e) {
            this.parser = e, this.name = Ky.KHR_MATERIALS_VOLUME
        }

        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Sv : null
        }

        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [], s = i.extensions[this.name];
            t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 0;
            const a = s.attenuationColor || [1, 1, 1];
            return t.attenuationTint = new Nu(a[0], a[1], a[2]), Promise.all(r)
        }
    }

    class nx {
        constructor(e) {
            this.parser = e, this.name = Ky.KHR_MATERIALS_IOR
        }

        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Sv : null
        }

        extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const i = n.extensions[this.name];
            return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
        }
    }

    class ix {
        constructor(e) {
            this.parser = e, this.name = Ky.KHR_MATERIALS_SPECULAR
        }

        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Sv : null
        }

        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const r = [], s = i.extensions[this.name];
            t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture));
            const a = s.specularColorFactor || [1, 1, 1];
            return t.specularTint = new Nu(a[0], a[1], a[2]), void 0 !== s.specularColorTexture && r.push(n.assignTexture(t, "specularTintMap", s.specularColorTexture).then((function (e) {
                e.encoding = Oc
            }))), Promise.all(r)
        }
    }

    class rx {
        constructor(e) {
            this.parser = e, this.name = Ky.KHR_TEXTURE_BASISU
        }

        loadTexture(e) {
            const t = this.parser, n = t.json, i = n.textures[e];
            if (!i.extensions || !i.extensions[this.name]) return null;
            const r = i.extensions[this.name], s = n.images[r.source], a = t.options.ktx2Loader;
            if (!a) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return t.loadTextureImage(e, s, a)
        }
    }

    class sx {
        constructor(e) {
            this.parser = e, this.name = Ky.EXT_TEXTURE_WEBP, this.isSupported = null
        }

        loadTexture(e) {
            const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const s = r.extensions[t], a = i.images[s.source];
            let o = n.textureLoader;
            if (a.uri) {
                const e = n.options.manager.getHandler(a.uri);
                null !== e && (o = e)
            }
            return this.detectSupport().then((function (r) {
                if (r) return n.loadTextureImage(e, a, o);
                if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(e)
            }))
        }

        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise((function (e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
                    e(1 === t.height)
                }
            }))), this.isSupported
        }
    }

    class ax {
        constructor(e) {
            this.name = Ky.EXT_MESHOPT_COMPRESSION, this.parser = e
        }

        loadBufferView(e) {
            const t = this.parser.json, n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const e = n.extensions[this.name], i = this.parser.getDependency("buffer", e.buffer),
                    r = this.parser.options.meshoptDecoder;
                if (!r || !r.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return Promise.all([i, r.ready]).then((function (t) {
                    const n = e.byteOffset || 0, i = e.byteLength || 0, s = e.count, a = e.byteStride,
                        o = new ArrayBuffer(s * a), l = new Uint8Array(t[0], n, i);
                    return r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter), o
                }))
            }
            return null
        }
    }

    const ox = "glTF", lx = 1313821514, cx = 5130562;

    class hx {
        constructor(e) {
            this.name = Ky.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, 12);
            if (this.header = {
                magic: u_.decodeText(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            }, this.header.magic !== ox) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const n = this.header.length - 12, i = new DataView(e, 12);
            let r = 0;
            for (; r < n;) {
                const t = i.getUint32(r, !0);
                r += 4;
                const n = i.getUint32(r, !0);
                if (r += 4, n === lx) {
                    const n = new Uint8Array(e, 12 + r, t);
                    this.content = u_.decodeText(n)
                } else if (n === cx) {
                    const n = 12 + r;
                    this.body = e.slice(n, n + t)
                }
                r += t
            }
            if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
    }

    class ux {
        constructor(e, t) {
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = Ky.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
        }

        decodePrimitive(e, t) {
            const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView,
                s = e.extensions[this.name].attributes, a = {}, o = {}, l = {};
            for (const e in s) {
                const t = Rx[e] || e.toLowerCase();
                a[t] = s[e]
            }
            for (const t in e.attributes) {
                const i = Rx[t] || t.toLowerCase();
                if (void 0 !== s[t]) {
                    const r = n.accessors[e.attributes[t]], s = Mx[r.componentType];
                    l[i] = s, o[i] = !0 === r.normalized
                }
            }
            return t.getDependency("bufferView", r).then((function (e) {
                return new Promise((function (t) {
                    i.decodeDracoFile(e, (function (e) {
                        for (const t in e.attributes) {
                            const n = e.attributes[t], i = o[t];
                            void 0 !== i && (n.normalized = i)
                        }
                        t(e)
                    }), a, l)
                }))
            }))
        }
    }

    class dx {
        constructor() {
            this.name = Ky.KHR_TEXTURE_TRANSFORM
        }

        extendTexture(e, t) {
            return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
        }
    }

    class px extends Tv {
        constructor(e) {
            super(), this.isGLTFSpecularGlossinessMaterial = !0;
            const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                a = {
                    specular: {value: (new Nu).setHex(16777215)},
                    glossiness: {value: 1},
                    specularMap: {value: null},
                    glossinessMap: {value: null}
                };
            this._extraUniforms = a, this.onBeforeCompile = function (e) {
                for (const t in a) e.uniforms[t] = a[t];
                e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
            }, Object.defineProperties(this, {
                specular: {
                    get: function () {
                        return a.specular.value
                    }, set: function (e) {
                        a.specular.value = e
                    }
                }, specularMap: {
                    get: function () {
                        return a.specularMap.value
                    }, set: function (e) {
                        a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                    }
                }, glossiness: {
                    get: function () {
                        return a.glossiness.value
                    }, set: function (e) {
                        a.glossiness.value = e
                    }
                }, glossinessMap: {
                    get: function () {
                        return a.glossinessMap.value
                    }, set: function (e) {
                        a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                    }
                }
            }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
        }

        copy(e) {
            return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
        }
    }

    class fx {
        constructor() {
            this.name = Ky.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
        }

        getMaterialType() {
            return px
        }

        extendParams(e, t, n) {
            const i = t.extensions[this.name];
            e.color = new Nu(1, 1, 1), e.opacity = 1;
            const r = [];
            if (Array.isArray(i.diffuseFactor)) {
                const t = i.diffuseFactor;
                e.color.fromArray(t), e.opacity = t[3]
            }
            if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture)), e.emissive = new Nu(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new Nu(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                const t = i.specularGlossinessTexture;
                r.push(n.assignTexture(e, "glossinessMap", t)), r.push(n.assignTexture(e, "specularMap", t))
            }
            return Promise.all(r)
        }

        createMaterial(e) {
            const t = new px(e);
            return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = 0, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
        }
    }

    class mx {
        constructor() {
            this.name = Ky.KHR_MESH_QUANTIZATION
        }
    }

    class gx extends Av {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }

        copySampleValue_(e) {
            const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i;
            for (let e = 0; e !== i; e++) t[e] = n[r + e];
            return t
        }
    }

    gx.prototype.beforeStart_ = gx.prototype.copySampleValue_, gx.prototype.afterEnd_ = gx.prototype.copySampleValue_, gx.prototype.interpolate_ = function (e, t, n, i) {
        const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = 2 * a, l = 3 * a, c = i - t,
            h = (n - t) / c, u = h * h, d = u * h, p = e * l, f = p - l, m = -2 * d + 3 * u, g = d - u, v = 1 - m,
            _ = g - u + h;
        for (let e = 0; e !== a; e++) {
            const t = s[f + e + a], n = s[f + e + o] * c, i = s[p + e + a], l = s[p + e] * c;
            r[e] = v * t + _ * n + m * i + g * l
        }
        return r
    };
    const vx = new dh;

    class _x extends gx {
        interpolate_(e, t, n, i) {
            const r = super.interpolate_(e, t, n, i);
            return vx.fromArray(r).normalize().toArray(r), r
        }
    }

    const yx = 0, xx = 1, bx = 2, wx = 3, Tx = 4, Sx = 5, Ex = 6, Mx = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }, Ax = {9728: rc, 9729: oc, 9984: sc, 9985: 1007, 9986: ac, 9987: lc}, Lx = {33071: nc, 33648: ic, 10497: tc},
        Cx = {SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16}, Rx = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }, Px = {scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences"},
        Ix = {CUBICSPLINE: void 0, LINEAR: Mc, STEP: Ec}, Ox = "OPAQUE", Dx = "MASK", Nx = "BLEND";

    function Bx(e, t) {
        return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }

    function kx(e) {
        return void 0 === e.DefaultMaterial && (e.DefaultMaterial = new Tv({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: !1,
            depthTest: !0,
            side: 0
        })), e.DefaultMaterial
    }

    function Ux(e, t, n) {
        for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
    }

    function Fx(e, t) {
        void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
    }

    function Hx(e, t) {
        if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
            const n = t.extras.targetNames;
            if (e.morphTargetInfluences.length === n.length) {
                e.morphTargetDictionary = {};
                for (let t = 0, i = n.length; t < i; t++) e.morphTargetDictionary[n[t]] = t
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
        }
    }

    function zx(e) {
        const t = e.extensions && e.extensions[Ky.KHR_DRACO_MESH_COMPRESSION];
        let n;
        return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Gx(t.attributes) : e.indices + ":" + Gx(e.attributes) + ":" + e.mode, n
    }

    function Gx(e) {
        let t = "";
        const n = Object.keys(e).sort();
        for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
        return t
    }

    function Vx(e) {
        switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }

    class Wx {
        constructor(e = {}, t = {}) {
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Yy, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {refs: {}, uses: {}}, this.lightCache = {
                refs: {},
                uses: {}
            }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new d_(this.options.manager) : this.textureLoader = new qv(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new jv(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }

        setExtensions(e) {
            this.extensions = e
        }

        setPlugins(e) {
            this.plugins = e
        }

        parse(e, t) {
            const n = this, i = this.json, r = this.extensions;
            this.cache.removeAll(), this._invokeAll((function (e) {
                return e._markDefs && e._markDefs()
            })), Promise.all(this._invokeAll((function (e) {
                return e.beforeRoot && e.beforeRoot()
            }))).then((function () {
                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
            })).then((function (t) {
                const s = {
                    scene: t[0][i.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: i.asset,
                    parser: n,
                    userData: {}
                };
                Ux(r, s, i), Fx(s, i), Promise.all(n._invokeAll((function (e) {
                    return e.afterRoot && e.afterRoot(s)
                }))).then((function () {
                    e(s)
                }))
            })).catch(t)
        }

        _markDefs() {
            const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n].joints;
                for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0
            }
            for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
            }
        }

        _addNodeRef(e, t) {
            void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
        }

        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const i = n.clone(), r = (e, t) => {
                const n = this.associations.get(e);
                null != n && this.associations.set(t, n);
                for (const [n, i] of e.children.entries()) r(i, t.children[n])
            };
            return r(n, i), i.name += "_instance_" + e.uses[t]++, i
        }

        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let n = 0; n < t.length; n++) {
                const i = e(t[n]);
                if (i) return i
            }
            return null
        }

        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const r = e(t[i]);
                r && n.push(r)
            }
            return n
        }

        getDependency(e, t) {
            const n = e + ":" + t;
            let i = this.cache.get(n);
            if (!i) {
                switch (e) {
                    case"scene":
                        i = this.loadScene(t);
                        break;
                    case"node":
                        i = this.loadNode(t);
                        break;
                    case"mesh":
                        i = this._invokeOne((function (e) {
                            return e.loadMesh && e.loadMesh(t)
                        }));
                        break;
                    case"accessor":
                        i = this.loadAccessor(t);
                        break;
                    case"bufferView":
                        i = this._invokeOne((function (e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }));
                        break;
                    case"buffer":
                        i = this.loadBuffer(t);
                        break;
                    case"material":
                        i = this._invokeOne((function (e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }));
                        break;
                    case"texture":
                        i = this._invokeOne((function (e) {
                            return e.loadTexture && e.loadTexture(t)
                        }));
                        break;
                    case"skin":
                        i = this.loadSkin(t);
                        break;
                    case"animation":
                        i = this.loadAnimation(t);
                        break;
                    case"camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        throw new Error("Unknown type: " + e)
                }
                this.cache.add(n, i)
            }
            return i
        }

        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this, i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                t = Promise.all(i.map((function (t, i) {
                    return n.getDependency(e, i)
                }))), this.cache.add(e, t)
            }
            return t
        }

        loadBuffer(e) {
            const t = this.json.buffers[e], n = this.fileLoader;
            if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[Ky.KHR_BINARY_GLTF].body);
            const i = this.options;
            return new Promise((function (e, r) {
                n.load(Bx(t.uri, i.path), e, void 0, (function () {
                    r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                }))
            }))
        }

        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then((function (e) {
                const n = t.byteLength || 0, i = t.byteOffset || 0;
                return e.slice(i, i + n)
            }))
        }

        loadAccessor(e) {
            const t = this, n = this.json, i = this.json.accessors[e];
            if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
            const r = [];
            return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function (e) {
                const r = e[0], s = Cx[i.type], a = Mx[i.componentType], o = a.BYTES_PER_ELEMENT, l = o * s,
                    c = i.byteOffset || 0,
                    h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                    u = !0 === i.normalized;
                let d, p;
                if (h && h !== l) {
                    const e = Math.floor(c / h),
                        n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                    let l = t.cache.get(n);
                    l || (d = new a(r, e * h, i.count * h / o), l = new Em(d, h / o), t.cache.add(n, l)), p = new Am(l, s, c % h / o, u)
                } else d = null === r ? new a(i.count * s) : new a(r, c, i.count * s), p = new Fu(d, s, u);
                if (void 0 !== i.sparse) {
                    const t = Cx.SCALAR, n = Mx[i.sparse.indices.componentType], o = i.sparse.indices.byteOffset || 0,
                        l = i.sparse.values.byteOffset || 0, c = new n(e[1], o, i.sparse.count * t),
                        h = new a(e[2], l, i.sparse.count * s);
                    null !== r && (p = new Fu(p.array.slice(), p.itemSize, p.normalized));
                    for (let e = 0, t = c.length; e < t; e++) {
                        const t = c[e];
                        if (p.setX(t, h[e * s]), s >= 2 && p.setY(t, h[e * s + 1]), s >= 3 && p.setZ(t, h[e * s + 2]), s >= 4 && p.setW(t, h[e * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                }
                return p
            }))
        }

        loadTexture(e) {
            const t = this.json, n = this.options, i = t.textures[e], r = t.images[i.source];
            let s = this.textureLoader;
            if (r.uri) {
                const e = n.manager.getHandler(r.uri);
                null !== e && (s = e)
            }
            return this.loadTextureImage(e, r, s)
        }

        loadTextureImage(e, t, n) {
            const i = this, r = this.json, s = this.options, a = r.textures[e],
                o = (t.uri || t.bufferView) + ":" + a.sampler;
            if (this.textureCache[o]) return this.textureCache[o];
            const l = self.URL || self.webkitURL;
            let c = t.uri || "", h = !1;
            if (void 0 !== t.bufferView) c = i.getDependency("bufferView", t.bufferView).then((function (e) {
                h = !0;
                const n = new Blob([e], {type: t.mimeType});
                return c = l.createObjectURL(n), c
            })); else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const u = Promise.resolve(c).then((function (e) {
                return new Promise((function (t, i) {
                    let r = t;
                    !0 === n.isImageBitmapLoader && (r = function (e) {
                        const n = new oh(e);
                        n.needsUpdate = !0, t(n)
                    }), n.load(Bx(e, s.path), r, void 0, i)
                }))
            })).then((function (t) {
                !0 === h && l.revokeObjectURL(c), t.flipY = !1, a.name && (t.name = a.name);
                const n = (r.samplers || {})[a.sampler] || {};
                return t.magFilter = Ax[n.magFilter] || oc, t.minFilter = Ax[n.minFilter] || lc, t.wrapS = Lx[n.wrapS] || tc, t.wrapT = Lx[n.wrapT] || tc, i.associations.set(t, {textures: e}), t
            })).catch((function () {
                return console.error("THREE.GLTFLoader: Couldn't load texture", c), null
            }));
            return this.textureCache[o] = u, u
        }

        assignTexture(e, t, n) {
            const i = this;
            return this.getDependency("texture", n.index).then((function (r) {
                if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), i.extensions[Ky.KHR_TEXTURE_TRANSFORM]) {
                    const e = void 0 !== n.extensions ? n.extensions[Ky.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (e) {
                        const t = i.associations.get(r);
                        r = i.extensions[Ky.KHR_TEXTURE_TRANSFORM].extendTexture(r, e), i.associations.set(r, t)
                    }
                }
                return e[t] = r, r
            }))
        }

        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const i = void 0 === t.attributes.tangent, r = void 0 !== t.attributes.color,
                s = void 0 === t.attributes.normal;
            if (e.isPoints) {
                const e = "PointsMaterial:" + n.uuid;
                let t = this.cache.get(e);
                t || (t = new gg, Lu.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
            } else if (e.isLine) {
                const e = "LineBasicMaterial:" + n.uuid;
                let t = this.cache.get(e);
                t || (t = new sg, Lu.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t
            }
            if (i || r || s) {
                let e = "ClonedMaterial:" + n.uuid + ":";
                n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), s && (e += "flat-shading:");
                let t = this.cache.get(e);
                t || (t = n.clone(), r && (t.vertexColors = !0), s && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
            }
            n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n
        }

        getMaterialType() {
            return Tv
        }

        loadMaterial(e) {
            const t = this, n = this.json, i = this.extensions, r = n.materials[e];
            let s;
            const a = {}, o = r.extensions || {}, l = [];
            if (o[Ky.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                const e = i[Ky.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                s = e.getMaterialType(), l.push(e.extendParams(a, r, t))
            } else if (o[Ky.KHR_MATERIALS_UNLIT]) {
                const e = i[Ky.KHR_MATERIALS_UNLIT];
                s = e.getMaterialType(), l.push(e.extendParams(a, r, t))
            } else {
                const n = r.pbrMetallicRoughness || {};
                if (a.color = new Nu(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
                    const e = n.baseColorFactor;
                    a.color.fromArray(e), a.opacity = e[3]
                }
                void 0 !== n.baseColorTexture && l.push(t.assignTexture(a, "map", n.baseColorTexture)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), l.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function (t) {
                    return t.getMaterialType && t.getMaterialType(e)
                })), l.push(Promise.all(this._invokeAll((function (t) {
                    return t.extendMaterialParams && t.extendMaterialParams(e, a)
                }))))
            }
            !0 === r.doubleSided && (a.side = 2);
            const c = r.alphaMode || Ox;
            if (c === Nx ? (a.transparent = !0, a.depthWrite = !1) : (a.format = mc, a.transparent = !1, c === Dx && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== Bu && (l.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new eh(1, 1), void 0 !== r.normalTexture.scale)) {
                const e = r.normalTexture.scale;
                a.normalScale.set(e, e)
            }
            return void 0 !== r.occlusionTexture && s !== Bu && (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== Bu && (a.emissive = (new Nu).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== Bu && l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)), Promise.all(l).then((function () {
                let n;
                return n = s === px ? i[Ky.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new s(a), r.name && (n.name = r.name), n.map && (n.map.encoding = Oc), n.emissiveMap && (n.emissiveMap.encoding = Oc), Fx(n, r), t.associations.set(n, {materials: e}), r.extensions && Ux(i, n, r), n
            }))
        }

        createUniqueName(e) {
            const t = C_.sanitizeNodeName(e || "");
            let n = t;
            for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;
            return this.nodeNamesUsed[n] = !0, n
        }

        loadGeometries(e) {
            const t = this, n = this.extensions, i = this.primitiveCache;

            function r(e) {
                return n[Ky.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (n) {
                    return $x(n, e, t)
                }))
            }

            const s = [];
            for (let n = 0, a = e.length; n < a; n++) {
                const a = e[n], o = zx(a), l = i[o];
                if (l) s.push(l.promise); else {
                    let e;
                    e = a.extensions && a.extensions[Ky.KHR_DRACO_MESH_COMPRESSION] ? r(a) : $x(new Ku, a, t), i[o] = {
                        primitive: a,
                        promise: e
                    }, s.push(e)
                }
            }
            return Promise.all(s)
        }

        loadMesh(e) {
            const t = this, n = this.json, i = this.extensions, r = n.meshes[e], s = r.primitives, a = [];
            for (let e = 0, t = s.length; e < t; e++) {
                const t = void 0 === s[e].material ? kx(this.cache) : this.getDependency("material", s[e].material);
                a.push(t)
            }
            return a.push(t.loadGeometries(s)), Promise.all(a).then((function (n) {
                const a = n.slice(0, n.length - 1), o = n[n.length - 1], l = [];
                for (let n = 0, c = o.length; n < c; n++) {
                    const c = o[n], h = s[n];
                    let u;
                    const d = a[n];
                    if (h.mode === Tx || h.mode === Sx || h.mode === Ex || void 0 === h.mode) u = !0 === r.isSkinnedMesh ? new qm(c, d) : new fd(c, d), !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), h.mode === Sx ? u.geometry = Xx(u.geometry, 1) : h.mode === Ex && (u.geometry = Xx(u.geometry, 2)); else if (h.mode === xx) u = new fg(c, d); else if (h.mode === wx) u = new ug(c, d); else if (h.mode === bx) u = new mg(c, d); else {
                        if (h.mode !== yx) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                        u = new bg(c, d)
                    }
                    Object.keys(u.geometry.morphAttributes).length > 0 && Hx(u, r), u.name = t.createUniqueName(r.name || "mesh_" + e), Fx(u, r), h.extensions && Ux(i, u, h), t.assignFinalMaterial(u), l.push(u)
                }
                for (let n = 0, i = l.length; n < i; n++) t.associations.set(l[n], {meshes: e, primitives: n});
                if (1 === l.length) return l[0];
                const c = new vm;
                t.associations.set(c, {meshes: e});
                for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                return c
            }))
        }

        loadCamera(e) {
            let t;
            const n = this.json.cameras[e], i = n[n.type];
            if (i) return "perspective" === n.type ? t = new wd(Qc.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new $d(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Fx(t, n), Promise.resolve(t);
            console.warn("THREE.GLTFLoader: Missing camera parameters.")
        }

        loadSkin(e) {
            const t = this.json.skins[e], n = {joints: t.joints};
            return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function (e) {
                return n.inverseBindMatrices = e, n
            }))
        }

        loadAnimation(e) {
            const t = this.json.animations[e], n = [], i = [], r = [], s = [], a = [];
            for (let e = 0, o = t.channels.length; e < o; e++) {
                const o = t.channels[e], l = t.samplers[o.sampler], c = o.target, h = void 0 !== c.node ? c.node : c.id,
                    u = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
                    d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
                n.push(this.getDependency("node", h)), i.push(this.getDependency("accessor", u)), r.push(this.getDependency("accessor", d)), s.push(l), a.push(c)
            }
            return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(a)]).then((function (n) {
                const i = n[0], r = n[1], s = n[2], a = n[3], o = n[4], l = [];
                for (let e = 0, t = i.length; e < t; e++) {
                    const t = i[e], n = r[e], c = s[e], h = a[e], u = o[e];
                    if (void 0 === t) continue;
                    let d;
                    switch (t.updateMatrix(), t.matrixAutoUpdate = !0, Px[u.path]) {
                        case Px.weights:
                            d = Dv;
                            break;
                        case Px.rotation:
                            d = Bv;
                            break;
                        default:
                            d = Uv
                    }
                    const p = t.name ? t.name : t.uuid, f = void 0 !== h.interpolation ? Ix[h.interpolation] : Mc,
                        m = [];
                    Px[u.path] === Px.weights ? t.traverse((function (e) {
                        !0 === e.isMesh && e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid)
                    })) : m.push(p);
                    let g = c.array;
                    if (c.normalized) {
                        const e = Vx(g.constructor), t = new Float32Array(g.length);
                        for (let n = 0, i = g.length; n < i; n++) t[n] = g[n] * e;
                        g = t
                    }
                    for (let e = 0, t = m.length; e < t; e++) {
                        const t = new d(m[e] + "." + Px[u.path], n.array, g, f);
                        "CUBICSPLINE" === h.interpolation && (t.createInterpolant = function (e) {
                            return new (this instanceof Bv ? _x : gx)(this.times, this.values, this.getValueSize() / 3, e)
                        }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(t)
                    }
                }
                const c = t.name ? t.name : "animation_" + e;
                return new Fv(c, void 0, l)
            }))
        }

        createNodeMesh(e) {
            const t = this.json, n = this, i = t.nodes[e];
            return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function (e) {
                const t = n._getNodeRef(n.meshCache, i.mesh, e);
                return void 0 !== i.weights && t.traverse((function (e) {
                    if (e.isMesh) for (let t = 0, n = i.weights.length; t < n; t++) e.morphTargetInfluences[t] = i.weights[t]
                })), t
            }))
        }

        loadNode(e) {
            const t = this.json, n = this.extensions, i = this, r = t.nodes[e],
                s = r.name ? i.createUniqueName(r.name) : "";
            return function () {
                const t = [], n = i._invokeOne((function (t) {
                    return t.createNodeMesh && t.createNodeMesh(e)
                }));
                return n && t.push(n), void 0 !== r.camera && t.push(i.getDependency("camera", r.camera).then((function (e) {
                    return i._getNodeRef(i.cameraCache, r.camera, e)
                }))), i._invokeAll((function (t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                })).forEach((function (e) {
                    t.push(e)
                })), Promise.all(t)
            }().then((function (t) {
                let a;
                if (a = !0 === r.isBone ? new Ym : t.length > 1 ? new vm : 1 === t.length ? t[0] : new mu, a !== t[0]) for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
                if (r.name && (a.userData.name = r.name, a.name = s), Fx(a, r), r.extensions && Ux(n, a, r), void 0 !== r.matrix) {
                    const e = new Wh;
                    e.fromArray(r.matrix), a.applyMatrix4(e)
                } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
                return i.associations.has(a) || i.associations.set(a, {}), i.associations.get(a).nodes = e, a
            }))
        }

        loadScene(e) {
            const t = this.json, n = this.extensions, i = this.json.scenes[e], r = this, s = new vm;
            i.name && (s.name = r.createUniqueName(i.name)), Fx(s, i), i.extensions && Ux(n, s, i);
            const a = i.nodes || [], o = [];
            for (let e = 0, n = a.length; e < n; e++) o.push(jx(a[e], s, t, r));
            return Promise.all(o).then((function () {
                return r.associations = (e => {
                    const t = new Map;
                    for (const [e, n] of r.associations) (e instanceof Lu || e instanceof oh) && t.set(e, n);
                    return e.traverse((e => {
                        const n = r.associations.get(e);
                        null != n && t.set(e, n)
                    })), t
                })(s), s
            }))
        }
    }

    function jx(e, t, n, i) {
        const r = n.nodes[e];
        return i.getDependency("node", e).then((function (e) {
            if (void 0 === r.skin) return e;
            let t;
            return i.getDependency("skin", r.skin).then((function (e) {
                t = e;
                const n = [];
                for (let e = 0, r = t.joints.length; e < r; e++) n.push(i.getDependency("node", t.joints[e]));
                return Promise.all(n)
            })).then((function (n) {
                return e.traverse((function (e) {
                    if (!e.isMesh) return;
                    const i = [], r = [];
                    for (let e = 0, s = n.length; e < s; e++) {
                        const s = n[e];
                        if (s) {
                            i.push(s);
                            const n = new Wh;
                            void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), r.push(n)
                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                    }
                    e.bind(new Qm(i, r), e.matrixWorld)
                })), e
            }))
        })).then((function (e) {
            t.add(e);
            const s = [];
            if (r.children) {
                const t = r.children;
                for (let r = 0, a = t.length; r < a; r++) {
                    const a = t[r];
                    s.push(jx(a, e, n, i))
                }
            }
            return Promise.all(s)
        }))
    }

    function $x(e, t, n) {
        const i = t.attributes, r = [];

        function s(t, i) {
            return n.getDependency("accessor", t).then((function (t) {
                e.setAttribute(i, t)
            }))
        }

        for (const t in i) {
            const n = Rx[t] || t.toLowerCase();
            n in e.attributes || r.push(s(i[t], n))
        }
        if (void 0 !== t.indices && !e.index) {
            const i = n.getDependency("accessor", t.indices).then((function (t) {
                e.setIndex(t)
            }));
            r.push(i)
        }
        return Fx(e, t), function (e, t, n) {
            const i = t.attributes, r = new gh;
            if (void 0 === i.POSITION) return;
            {
                const e = n.json.accessors[i.POSITION], t = e.min, s = e.max;
                if (void 0 === t || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                if (r.set(new ph(t[0], t[1], t[2]), new ph(s[0], s[1], s[2])), e.normalized) {
                    const t = Vx(Mx[e.componentType]);
                    r.min.multiplyScalar(t), r.max.multiplyScalar(t)
                }
            }
            const s = t.targets;
            if (void 0 !== s) {
                const e = new ph, t = new ph;
                for (let i = 0, r = s.length; i < r; i++) {
                    const r = s[i];
                    if (void 0 !== r.POSITION) {
                        const i = n.json.accessors[r.POSITION], s = i.min, a = i.max;
                        if (void 0 !== s && void 0 !== a) {
                            if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), i.normalized) {
                                const e = Vx(Mx[i.componentType]);
                                t.multiplyScalar(e)
                            }
                            e.max(t)
                        } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                    }
                }
                r.expandByVector(e)
            }
            e.boundingBox = r;
            const a = new Nh;
            r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = a
        }(e, t, n), Promise.all(r).then((function () {
            return void 0 !== t.targets ? function (e, t, n) {
                let i = !1, r = !1;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), i && r) break
                }
                if (!i && !r) return Promise.resolve(e);
                const s = [], a = [];
                for (let o = 0, l = t.length; o < l; o++) {
                    const l = t[o];
                    if (i) {
                        const t = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : e.attributes.position;
                        s.push(t)
                    }
                    if (r) {
                        const t = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : e.attributes.normal;
                        a.push(t)
                    }
                }
                return Promise.all([Promise.all(s), Promise.all(a)]).then((function (t) {
                    const n = t[0], s = t[1];
                    return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = s), e.morphTargetsRelative = !0, e
                }))
            }(e, t.targets, n) : e
        }))
    }

    function Xx(e, t) {
        let n = e.getIndex();
        if (null === n) {
            const t = [], i = e.getAttribute("position");
            if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
            for (let e = 0; e < i.count; e++) t.push(e);
            e.setIndex(t), n = e.getIndex()
        }
        const i = n.count - 2, r = [];
        if (2 === t) for (let e = 1; e <= i; e++) r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1)); else for (let e = 0; e < i; e++) e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
        r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = e.clone();
        return s.setIndex(r), s
    }

    class qx {
        constructor(e = 4) {
            this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
        }

        _initWorker(e) {
            if (!this.workers[e]) {
                const t = this.workerCreator();
                t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t
            }
        }

        _getIdleWorker() {
            for (let e = 0; e < this.pool; e++) if (!(this.workerStatus & 1 << e)) return e;
            return -1
        }

        _onMessage(e, t) {
            const n = this.workersResolve[e];
            if (n && n(t), this.queue.length) {
                const {resolve: t, msg: n, transfer: i} = this.queue.shift();
                this.workersResolve[e] = t, this.workers[e].postMessage(n, i)
            } else this.workerStatus ^= 1 << e
        }

        setWorkerCreator(e) {
            this.workerCreator = e
        }

        setWorkerLimit(e) {
            this.pool = e
        }

        postMessage(e, t) {
            return new Promise((n => {
                const i = this._getIdleWorker();
                -1 !== i ? (this._initWorker(i), this.workerStatus |= 1 << i, this.workersResolve[i] = n, this.workers[i].postMessage(e, t)) : this.queue.push({
                    resolve: n,
                    msg: e,
                    transfer: t
                })
            }))
        }

        dispose() {
            this.workers.forEach((e => e.terminate())), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
        }
    }

    const Yx = new WeakMap;

    class Kx extends Vv {
        constructor(e) {
            super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new qx, this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
        }

        setTranscoderPath(e) {
            return this.transcoderPath = e, this
        }

        setWorkerLimit(e) {
            return this.workerPool.setWorkerLimit(e), this
        }

        detectSupport(e) {
            return this.workerConfig = {
                astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
                etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
                etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
                dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
                bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
                pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
            }, this
        }

        dispose() {
            return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
        }

        init() {
            if (!this.transcoderPending) {
                const e = new jv(this.manager);
                e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
                const t = e.loadAsync("basis_transcoder.js"), n = new jv(this.manager);
                n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
                const i = n.loadAsync("basis_transcoder.wasm");
                this.transcoderPending = Promise.all([t, i]).then((([e, t]) => {
                    const n = Kx.BasisWorker.toString(),
                        i = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Kx.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Kx.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Kx.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([i])), this.transcoderBinary = t, this.workerPool.setWorkerCreator((() => {
                        const e = new Worker(this.workerSourceURL), t = this.transcoderBinary.slice(0);
                        return e.postMessage({type: "init", config: this.workerConfig, transcoderBinary: t}, [t]), e
                    }))
                }))
            }
            return this.transcoderPending
        }

        load(e, t, n, i) {
            if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
            const r = new jv(this.manager);
            r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials);
            const s = new Tg;
            return r.load(e, (e => {
                if (Yx.has(e)) {
                    return Yx.get(e).promise.then(t).catch(i)
                }
                this._createTexture([e]).then((function (e) {
                    s.copy(e), s.needsUpdate = !0, t && t(s)
                })).catch(i)
            }), n, i), s
        }

        _createTextureFrom(e) {
            const {mipmaps: t, width: n, height: i, format: r, type: s, error: a, dfdTransferFn: o, dfdFlags: l} = e;
            if ("error" === s) return Promise.reject(a);
            const c = new Tg(t, n, i, r, cc);
            return c.minFilter = 1 === t.length ? oc : lc, c.magFilter = oc, c.generateMipmaps = !1, c.needsUpdate = !0, c.encoding = 2 === o ? Oc : Ic, c.premultiplyAlpha = !!(1 & l), c
        }

        _createTexture(e, t = {}) {
            const n = t, i = this.init().then((() => this.workerPool.postMessage({
                type: "transcode",
                buffers: e,
                taskConfig: n
            }, e))).then((e => this._createTextureFrom(e.data)));
            return Yx.set(e[0], {promise: i}), i
        }

        dispose() {
            return URL.revokeObjectURL(this.workerSourceURL), this.workerPool.dispose(), this
        }
    }

    function Jx(e, t = !1) {
        e.traverse((e => {
            if ("isMesh" in e && e.isMesh) {
                if (!e.isMesh) return;
                const n = e;
                n.material && function (e, t = !1) {
                    t && ("map" in e && e.map && e.map.dispose(), "lightMap" in e && e.lightMap && e.lightMap.dispose(), "bumpMap" in e && e.bumpMap && e.bumpMap.dispose(), "normalMap" in e && e.normalMap && e.normalMap.dispose(), "envMap" in e && e.envMap && e.envMap.dispose(), "alphaMap" in e && e.alphaMap && e.alphaMap.dispose(), "aoMap" in e && e.aoMap && e.aoMap.dispose(), "emissiveMap" in e && e.emissiveMap && e.emissiveMap.dispose(), "metalnessMap" in e && e.metalnessMap && e.metalnessMap.dispose(), "roughnessMap" in e && e.roughnessMap && e.roughnessMap.dispose(), "specularMap" in e && e.specularMap && e.specularMap.dispose(), "displacementMap" in e && e.displacementMap && e.displacementMap.dispose()), e.dispose()
                }(n.material, t), n.geometry && n.geometry.dispose()
            }
        }))
    }

    Kx.BasisFormat = {ETC1S: 0, UASTC_4x4: 1}, Kx.TranscoderFormat = {
        ETC1: 0,
        ETC2: 1,
        BC1: 2,
        BC3: 3,
        BC4: 4,
        BC5: 5,
        BC7_M6_OPAQUE_ONLY: 6,
        BC7_M5: 7,
        PVRTC1_4_RGB: 8,
        PVRTC1_4_RGBA: 9,
        ASTC_4x4: 10,
        ATC_RGB: 11,
        ATC_RGBA_INTERPOLATED_ALPHA: 12,
        RGBA32: 13,
        RGB565: 14,
        BGR565: 15,
        RGBA4444: 16
    }, Kx.EngineFormat = {
        RGBAFormat: gc,
        RGBA_ASTC_4x4_Format: 37808,
        RGBA_BPTC_Format: 36492,
        RGBA_ETC2_EAC_Format: Sc,
        RGBA_PVRTC_4BPPV1_Format: wc,
        RGBA_S3TC_DXT5_Format: xc,
        RGB_ETC1_Format: 36196,
        RGB_ETC2_Format: Tc,
        RGB_PVRTC_4BPPV1_Format: bc,
        RGB_S3TC_DXT1_Format: yc
    }, Kx.BasisWorker = function () {
        let e, t, n;
        const i = _EngineFormat, r = _TranscoderFormat, s = _BasisFormat;
        self.addEventListener("message", (function (a) {
            const h = a.data;
            switch (h.type) {
                case"init":
                    e = h.config, u = h.transcoderBinary, t = new Promise((e => {
                        n = {wasmBinary: u, onRuntimeInitialized: e}, BASIS(n)
                    })).then((() => {
                        n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                    }));
                    break;
                case"transcode":
                    t.then((() => {
                        try {
                            const {
                                width: t,
                                height: a,
                                hasAlpha: u,
                                mipmaps: d,
                                format: p,
                                dfdTransferFn: f,
                                dfdFlags: m
                            } = function (t) {
                                const a = new n.KTX2File(new Uint8Array(t));

                                function h() {
                                    a.close(), a.delete()
                                }

                                if (!a.isValid()) throw h(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                                const u = a.isUASTC() ? s.UASTC_4x4 : s.ETC1S, d = a.getWidth(), p = a.getHeight(),
                                    f = a.getLevels(), m = a.getHasAlpha(), g = a.getDFDTransferFunc(),
                                    v = a.getDFDFlags(), {
                                        transcoderFormat: _,
                                        engineFormat: y
                                    } = function (t, n, a, h) {
                                        let u, d;
                                        const p = t === s.ETC1S ? o : l;
                                        for (let i = 0; i < p.length; i++) {
                                            const r = p[i];
                                            if (e[r.if] && (r.basisFormat.includes(t) && (!r.needsPowerOfTwo || c(n) && c(a)))) return u = r.transcoderFormat[h ? 1 : 0], d = r.engineFormat[h ? 1 : 0], {
                                                transcoderFormat: u,
                                                engineFormat: d
                                            }
                                        }
                                        return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), u = r.RGBA32, d = i.RGBAFormat, {
                                            transcoderFormat: u,
                                            engineFormat: d
                                        }
                                    }(u, d, p, m);
                                if (!d || !p || !f) throw h(), new Error("THREE.KTX2Loader:\tInvalid texture");
                                if (!a.startTranscoding()) throw h(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                                const x = [];
                                for (let e = 0; e < f; e++) {
                                    const t = a.getImageLevelInfo(e, 0, 0), n = t.origWidth, i = t.origHeight,
                                        r = new Uint8Array(a.getImageTranscodedSizeInBytes(e, 0, 0, _));
                                    if (!a.transcodeImage(r, e, 0, 0, _, 0, -1, -1)) throw h(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                    x.push({data: r, width: n, height: i})
                                }
                                return h(), {
                                    width: d,
                                    height: p,
                                    hasAlpha: m,
                                    mipmaps: x,
                                    format: y,
                                    dfdTransferFn: g,
                                    dfdFlags: v
                                }
                            }(h.buffers[0]), g = [];
                            for (let e = 0; e < d.length; ++e) g.push(d[e].data.buffer);
                            self.postMessage({
                                type: "transcode",
                                id: h.id,
                                width: t,
                                height: a,
                                hasAlpha: u,
                                mipmaps: d,
                                format: p,
                                dfdTransferFn: f,
                                dfdFlags: m
                            }, g)
                        } catch (e) {
                            console.error(e), self.postMessage({type: "error", id: h.id, error: e.message})
                        }
                    }))
            }
            var u
        }));
        const a = [{
            if: "astcSupported",
            basisFormat: [s.UASTC_4x4],
            transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4],
            engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
            priorityETC1S: 1 / 0,
            priorityUASTC: 1,
            needsPowerOfTwo: !1
        }, {
            if: "bptcSupported",
            basisFormat: [s.ETC1S, s.UASTC_4x4],
            transcoderFormat: [r.BC7_M5, r.BC7_M5],
            engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
            priorityETC1S: 3,
            priorityUASTC: 2,
            needsPowerOfTwo: !1
        }, {
            if: "dxtSupported",
            basisFormat: [s.ETC1S, s.UASTC_4x4],
            transcoderFormat: [r.BC1, r.BC3],
            engineFormat: [i.RGB_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
            priorityETC1S: 4,
            priorityUASTC: 5,
            needsPowerOfTwo: !1
        }, {
            if: "etc2Supported",
            basisFormat: [s.ETC1S, s.UASTC_4x4],
            transcoderFormat: [r.ETC1, r.ETC2],
            engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
            priorityETC1S: 1,
            priorityUASTC: 3,
            needsPowerOfTwo: !1
        }, {
            if: "etc1Supported",
            basisFormat: [s.ETC1S, s.UASTC_4x4],
            transcoderFormat: [r.ETC1, r.ETC1],
            engineFormat: [i.RGB_ETC1_Format, i.RGB_ETC1_Format],
            priorityETC1S: 2,
            priorityUASTC: 4,
            needsPowerOfTwo: !1
        }, {
            if: "pvrtcSupported",
            basisFormat: [s.ETC1S, s.UASTC_4x4],
            transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA],
            engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
            priorityETC1S: 5,
            priorityUASTC: 6,
            needsPowerOfTwo: !0
        }], o = a.sort((function (e, t) {
            return e.priorityETC1S - t.priorityETC1S
        })), l = a.sort((function (e, t) {
            return e.priorityUASTC - t.priorityUASTC
        }));

        function c(e) {
            return e <= 2 || 0 == (e & e - 1) && 0 !== e
        }
    };

    class Zx {
        constructor() {
            this.textureCache = new Map, this.modelCache = new Map, this.dracoCache = new Map, this.ktx2Supported = !1, this.gltf = new qy, this.texture = new qv, this.draco = new $y, this.ktx2 = new Kx
        }

        async setup(e) {
            this.draco.setDecoderPath(Gy), this.gltf.setDRACOLoader(this.draco), this.draco.preload(), await this.draco.decoderPending, function () {
                try {
                    if ("object" == typeof WebAssembly && "function" == typeof WebAssembly.instantiate && new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0)) instanceof WebAssembly.Module) return !0
                } catch (e) {
                }
                return !1
            }() && (this.ktx2.setTranscoderPath(zy), await this.ktx2.transcoderPending, this.ktx2.detectSupport(e), this.ktx2Supported = await async function (e, t) {
                var n;
                const i = e;
                let r = !1;
                const s = i.workerConfig;
                if (Object.values(s).find((e => e))) try {
                    const e = await i.loadAsync(t);
                    r = (null === (n = e.image) || void 0 === n ? void 0 : n.width) > 0, e.dispose()
                } catch (e) {
                    r = !1
                }
                return r
            }(this.ktx2, Vy))
        }

        async loadTexture(e, t = this.texture, n, i) {
            if (!this.textureCache.has(e)) {
                const r = await t.loadAsync(e);
                void 0 !== n && (r.encoding = n), r.flipY = void 0 !== i && i, r.needsUpdate = !0, this.textureCache.set(e, r)
            }
            return this.textureCache.get(e)
        }

        async loadTextureFromManifest(e) {
            let t = this.texture, n = e.image;
            return this.ktx2Supported && e.ktx2 && (t = this.ktx2, n = e.ktx2), await this.loadTexture(n, t, e.encoding, e.flipY)
        }

        async loadModel(e) {
            if (!this.modelCache.has(e)) {
                const t = e.endsWith(".drc") ? this.draco : this.gltf, n = await t.loadAsync(e);
                this.modelCache.set(e, n)
            }
            return this.modelCache.get(e)
        }

        async loadDraco(e) {
            if (!this.dracoCache.has(e)) {
                const t = await this.draco.loadAsync(e);
                this.dracoCache.set(e, t)
            }
            return this.dracoCache.get(e)
        }

        async loadManifest(e) {
            const t = [];
            if (e.models) for (const n of e.models) t.push(this.loadModel(n));
            if (e.textures) for (const n of e.textures) t.push(this.loadTextureFromManifest(n));
            return await Promise.all(t)
        }

        dispose() {
            for (const [e, t] of this.textureCache) t.dispose();
            this.textureCache.clear();
            for (const [e, t] of this.modelCache) Jx(t.scene);
            this.modelCache.clear(), this.draco.dispose(), this.ktx2.dispose()
        }
    }

    class Qx {
        constructor(e, t, n) {
            this.desktopMediaQuery = window.matchMedia("(min-width: 600px)"), this.materials = [], this.dom = {wrapperScope: e}, this.renderer = function (e = {}) {
                const t = new wm({...Oy, ...e});
                return t.info.autoReset = !1, t.debug.checkShaderErrors = !1, t
            }({canvas: t}), this.boundaries = n, this.loaders = new Zx, this.events = new Wy(this.boundaries)
        }

        pointerDown(e, t) {
            if (this.isInXr || !this.isDesktop) return;
            const {width: n, height: i} = this.boundaries, r = Dy(n, i, e, t);
            this.events.pointerDown(r)
        }

        pointerMove(e, t) {
            if (this.isInXr || !this.isDesktop) return;
            const {width: n, height: i} = this.boundaries, r = Dy(n, i, e, t);
            this.events.pointerMove(r)
        }

        pointerUp() {
            !this.isInXr && this.isDesktop && this.events.pointerUp()
        }

        visibilityChange(e) {
            this.events.visibilityChange(e)
        }

        resize(e, t, n) {
            this.isInXr || (this.boundaries.resize(e, t, n), this.renderer.setSize(this.boundaries.width, this.boundaries.height), this.renderer.setPixelRatio(this.boundaries.pixelRatio), this.events.resize(this.boundaries))
        }

        async setup() {
            await this.loaders.setup(this.renderer)
        }

        dispose() {
            this.loaders.dispose(), this.renderer.dispose()
        }

        get isInXr() {
            return this.renderer.xr.isPresenting
        }

        get isDesktop() {
            return this.desktopMediaQuery.matches
        }
    }

    const eb = "rtl" === document.documentElement.dir;

    class tb extends mu {
        constructor() {
            super(), this.matrixAutoUpdate = !1
        }
    }

    class nb extends tb {
        constructor(e) {
            super(), this.engine = e
        }

        dispose(e = !1) {
            Jx(this, e)
        }
    }

    class ib extends fd {
        constructor(e, t) {
            super(e, t), this.geometry = e, this.material = t, this.matrixAutoUpdate = !1
        }
    }

    function rb(e) {
        let t;
        return e.scene.traverseVisible((e => {
            const n = e;
            n.isMesh && (t = n.geometry.clone())
        })), Jx(e.scene, !0), t
    }

    const sb = `${Ny}models/`, ab = {
            GLOBE: `${sb}globe_diffuse.glb`,
            GLOBE_CLOUDS: `${sb}globe_clouds.glb`,
            GLOBE_SUDAN_EGYPT: `${sb}globe_sudan-egypt.glb`,
            GLOBE_KINGDOM: `${sb}globe_kushkingdom.glb`,
            GLOBE_MEROE: `${sb}globe_meroe.glb`,
            GLOBE_ILLUSTRATIONS: `${sb}globe_map.glb`,
            PYRAMID: `${sb}hero_pyramid.glb`,
            PYRAMID_ANGLE: `${sb}pyramid_illustration-uniquely-nubian.glb`,
            PYRAMID_SHADOUF: `${sb}pyramid_illustration-shadouf.glb`,
            PYRAMID_QUEEN: `${sb}pyramid_illustration-queen.glb`,
            PYRAMID_BRICKS: `${sb}pyramid_illustration-bricks.glb`,
            TERRAIN: `${sb}pyramid_ground.glb`,
            CEMETERY: `${sb}pyramid_field.glb`,
            OUTSKIRTS: `${sb}pyramid_outskirts.glb`,
            CHAPEL: `${sb}chapel.glb`,
            CHAPEL_GIFTS: `${sb}chapel_illustration-gifts.glb`,
            CHAPEL_WALL_NORTH: `${sb}chapel_illustration-wall_north.glb`,
            CHAPEL_WALL_SOUTH: `${sb}chapel_illustration-wall_south.glb`,
            BURIAL_CHAMBER: `${sb}burial-chamber.glb`,
            BURIAL_CHAMBER_GODS: `${sb}burial_chamber_illustration-gods.glb`,
            BURIAL_CHAMBER_BABIRD: `${sb}burial_chamber_illustration-babird.glb`,
            BURIAL_CHAMBER_VESSELS: `${sb}burial_chamber_illustration-vessels.glb`,
            BURIAL_CHAMBER_GODS_XR: `${sb}burial_chamber_xr_illustration-gods.glb`,
            BURIAL_CHAMBER_BABIRD_XR: `${sb}burial_chamber_xr_illustration-babird.glb`,
            BURIAL_CHAMBER_VESSELS_XR: `${sb}burial_chamber_xr_illustration-vessels.glb`
        }, ob = `${Ny}models/cameras/`, lb = {
            GLOBE: `${ob}globe.glb`,
            MEROE_DESKTOP: `${ob}meroe-desktop.glb`,
            MEROE_DESKTOP_RTL: `${ob}meroe-desktop-rtl.glb`,
            MEROE_MOBILE: `${ob}meroe-mobile.glb`,
            MEROE_LANDSCAPE: `${ob}meroe-landscape.glb`,
            MEROE_LANDSCAPE_RTL: `${ob}meroe-landscape-rtl.glb`,
            CHAPEL_MOBILE: `${ob}chapel-mobile.glb`,
            CHAPEL_DESKTOP: `${ob}chapel-desktop.glb`,
            CHAPEL_DESKTOP_RTL: `${ob}chapel-desktop-rtl.glb`,
            BURIAL_CHAMBER_MOBILE: `${ob}burial-chamber-mobile.glb`,
            BURIAL_CHAMBER_DESKTOP: `${ob}burial-chamber-desktop.glb`,
            BURIAL_CHAMBER_DESKTOP_RTL: `${ob}burial-chamber-desktop-rtl.glb`
        }, cb = "#include <clipping_planes_pars_vertex>", hb = "#include <clipping_planes_vertex>",
        ub = "#include <clipping_planes_pars_fragment>", db = "#include <output_fragment>",
        pb = `\n  ${cb}\n  uniform float uXray;\n  varying float edge_alpha;\n`,
        fb = `\n  ${hb}\n  vec3 normalisedMatrix = normalize(normalMatrix * normal);\n\n  vec3 edgesToShow = vec3(1, 1, 0);\n  float edgeFallOff = abs(dot(normalisedMatrix, edgesToShow));\n\n  edge_alpha = pow(1.0 - edgeFallOff, uXray);\n`,
        mb = `\n  ${ub}\n  uniform float uTime;\n  varying float edge_alpha;\n`;

    class gb extends Bu {
        constructor(e) {
            super(e), this.onBeforeCompile = (e, t) => {
                e.uniforms.uTime = this.uniforms.uTime, e.uniforms.uXray = this.uniforms.uXray, e.vertexShader = e.vertexShader.replace(cb, pb), e.vertexShader = e.vertexShader.replace(hb, fb), e.fragmentShader = e.fragmentShader.replace(ub, mb), e.fragmentShader = e.fragmentShader.replace(db, "\n  // Put the string we replace back so we don't break anything.\n  #include <output_fragment>\n  gl_FragColor.a = edge_alpha;\n")
            }, this.uniforms = {uTime: {value: 0}, uXray: {value: 0}}
        }

        set xray(e) {
            this.uniforms.uXray.value = e
        }
    }

    const vb = {defaults: {ease: "none", duration: .5}}, _b = {requiredFeatures: ["hit-test", "dom-overlay"]}, yb = {
            GREY_0: new Nu(16777215),
            GREY_500: new Nu(10724259),
            GREY_700: new Nu(7829367),
            GREY_800: new Nu(5592405),
            GREY_900: new Nu(2105636),
            GREY_999: new Nu(0),
            YELLOW: new Nu(16759386),
            SUNSET_ORANGE: new Nu(16742190),
            SANDSTONE: new Nu(16774891)
        }, xb = "(min-aspect-ratio: 1/1)", bb = {
            ATLAS_1: {ktx2: `${Ny}textures/atlas/atlas1.ktx2`, image: `${Ny}textures/atlas/atlas1.jpg`},
            ATLAS_1_ALPHA: {ktx2: `${Ny}textures/atlas/atlas1-alpha.ktx2`, image: `${Ny}textures/atlas/atlas1-alpha.jpg`},
            ATLAS_2: {ktx2: `${Ny}textures/atlas/atlas2.ktx2`, image: `${Ny}textures/atlas/atlas2.jpg`},
            RETICLE_ALPHA: {
                ktx2: `${Ny}textures/unique/reticle-alpha.ktx2`,
                image: `${Ny}textures/unique/reticle-alpha.jpg`
            },
            GLOBE_GLOW: {ktx2: `${Ny}textures/unique/glow.ktx2`, image: `${Ny}textures/unique/glow.jpg`, encoding: Ic},
            CEMETERY_OUTSKIRTS: {
                ktx2: `${Ny}textures/unique/cemetery-outskirts.ktx2`,
                image: `${Ny}textures/unique/cemetery-outskirts.jpg`
            },
            MATCAP: {image: `${Ny}textures/unique/matcap.jpg`}
        }, wb = {textures: [bb.ATLAS_1, bb.ATLAS_1_ALPHA, bb.ATLAS_2, bb.CEMETERY_OUTSKIRTS, bb.GLOBE_GLOW, bb.MATCAP]},
        Tb = {DIFFUSE: new Bu, ALPHA: new Bu, DIFFUSE_AND_ALPHA: new Bu},
        Sb = {DIFFUSE: new Bu, ALPHA: new Bu({fog: !1})};
    var Eb;
    let Mb, Ab;

    async function Lb(e) {
        return Mb || (Mb = await async function (e) {
            const t = rb(await e.loaders.loadModel(ab.BURIAL_CHAMBER));
            t.computeVertexNormals();
            const n = e.materials[Eb.BURIAL_CHAMBER];
            return {mesh: new ib(t, n)}
        }(e)), Mb
    }

    !function (e) {
        e[e.GLOBE = 0] = "GLOBE", e[e.GLOBE_CLOUDS = 1] = "GLOBE_CLOUDS", e[e.GLOBE_ILLUSTRATION_SUDAN_EGYPT = 2] = "GLOBE_ILLUSTRATION_SUDAN_EGYPT", e[e.GLOBE_ILLUSTRATION_KINGDOM = 3] = "GLOBE_ILLUSTRATION_KINGDOM", e[e.GLOBE_ILLUSTRATION_MEROE = 4] = "GLOBE_ILLUSTRATION_MEROE", e[e.GLOBE_GLOW = 5] = "GLOBE_GLOW", e[e.PYRAMID = 6] = "PYRAMID", e[e.PYRAMID_GROUND = 7] = "PYRAMID_GROUND", e[e.PYRAMID_FADE = 8] = "PYRAMID_FADE", e[e.PYRAMID_INFINITE_FLOOR = 9] = "PYRAMID_INFINITE_FLOOR", e[e.PYRAMID_ILLUSTRATION_ANGLE = 10] = "PYRAMID_ILLUSTRATION_ANGLE", e[e.PYRAMID_ILLUSTRATION_SHADOUF = 11] = "PYRAMID_ILLUSTRATION_SHADOUF", e[e.PYRAMID_ILLUSTRATION_QUEEN = 12] = "PYRAMID_ILLUSTRATION_QUEEN", e[e.PYRAMID_ILLUSTRATION_BRICKS = 13] = "PYRAMID_ILLUSTRATION_BRICKS", e[e.CHAPEL = 14] = "CHAPEL", e[e.CHAPEL_ILLUSTRATION_GIFTS = 15] = "CHAPEL_ILLUSTRATION_GIFTS", e[e.CHAPEL_ILLUSTRATION_WALL_NORTH = 16] = "CHAPEL_ILLUSTRATION_WALL_NORTH", e[e.CHAPEL_ILLUSTRATION_WALL_SOUTH = 17] = "CHAPEL_ILLUSTRATION_WALL_SOUTH", e[e.BURIAL_CHAMBER = 18] = "BURIAL_CHAMBER", e[e.BURIAL_CHAMBER_FILLED = 19] = "BURIAL_CHAMBER_FILLED", e[e.BURIAL_CHAMBER_ILLUSTRATION_GODS = 20] = "BURIAL_CHAMBER_ILLUSTRATION_GODS", e[e.BURIAL_CHAMBER_ILLUSTRATION_BABIRD = 21] = "BURIAL_CHAMBER_ILLUSTRATION_BABIRD", e[e.BURIAL_CHAMBER_ILLUSTRATION_VESSELS = 22] = "BURIAL_CHAMBER_ILLUSTRATION_VESSELS", e[e.BURIAL_CHAMBER_ILLUSTRATION_GODS_XR = 23] = "BURIAL_CHAMBER_ILLUSTRATION_GODS_XR", e[e.BURIAL_CHAMBER_ILLUSTRATION_BABIRD_XR = 24] = "BURIAL_CHAMBER_ILLUSTRATION_BABIRD_XR", e[e.BURIAL_CHAMBER_ILLUSTRATION_VESSELS_XR = 25] = "BURIAL_CHAMBER_ILLUSTRATION_VESSELS_XR"
    }(Eb || (Eb = {}));

    class Cb extends nb {
        async initialise(e = !0) {
            this.resources = await Lb(this.engine);
            const t = this.resources.mesh.clone();
            t.material.transparent = e, this.add(t)
        }
    }

    async function Rb(e) {
        return Ab || (Ab = await async function (e) {
            const t = rb(await e.loaders.loadModel(ab.PYRAMID)), n = e.materials[Eb.PYRAMID];
            return {mesh: new ib(t, n)}
        }(e)), Ab
    }

    class Pb extends tb {
        constructor() {
            super(...arguments), this._alpha = 1, this._alphaTest = 0
        }

        setAlpha(e) {
            0 !== e ? (this.visible = !0, this.traverseVisible((t => {
                const n = t;
                if (n.isMesh && n.material) {
                    n.material.opacity = e
                }
            }))) : this.visible = !1
        }

        setAlphaTest(e) {
            this.traverseVisible((t => {
                const n = t;
                if (n.isMesh && n.material) {
                    n.material.alphaTest = e
                }
            }))
        }

        set alphaTest(e) {
            this._alphaTest = e, this.setAlphaTest(e)
        }

        get alphaTest() {
            return this._alphaTest
        }

        set alpha(e) {
            this._alpha = e, this.setAlpha(e)
        }

        get alpha() {
            return this._alpha
        }
    }

    class Ib extends Pb {
        constructor(e) {
            super(), this.engine = e
        }

        async initialise() {
            this.resources = await Rb(this.engine);
            const e = this.resources.mesh.clone();
            this.add(e), this.alphaTest = .5
        }
    }

    const Ob = "\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n",
        Db = new Bd(2, 2, 1, 1);

    function Nb(e) {
        return function (e) {
            const t = new xd({
                vertexShader: "\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",
                fragmentShader: "\n  uniform float uAlpha;\n  uniform vec3 uColor;\n\n  void main() {\n    gl_FragColor = vec4(uColor, uAlpha);\n  }\n",
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                transparent: !0,
                uniforms: {uAlpha: {value: 1}, uColor: {value: e}}
            });
            return {geometry: Db, material: t}
        }(e)
    }

    class Bb extends nb {
        constructor(e, t) {
            super(e);
            const n = Nb(t);
            this.resources = {geometry: n.geometry, material: n.material}
        }

        initialise() {
            const e = new ib(this.resources.geometry, this.resources.material);
            e.frustumCulled = !1, this.add(e)
        }

        get alpha() {
            return this.resources.material.uniforms.uAlpha.value
        }

        set alpha(e) {
            this.resources.material.uniforms.uAlpha.value = e
        }
    }

    const kb = {
            GLOBE_MAP: {modelPath: ab.GLOBE_SUDAN_EGYPT, materialId: Eb.GLOBE_ILLUSTRATION_SUDAN_EGYPT},
            GLOBE_KINGDOM: {modelPath: ab.GLOBE_KINGDOM, materialId: Eb.GLOBE_ILLUSTRATION_KINGDOM},
            GLOBE_MEROE: {modelPath: ab.GLOBE_MEROE, materialId: Eb.GLOBE_ILLUSTRATION_MEROE},
            ANGLE: {modelPath: ab.PYRAMID_ANGLE, materialId: Eb.PYRAMID_ILLUSTRATION_ANGLE},
            SHADOUF: {modelPath: ab.PYRAMID_SHADOUF, materialId: Eb.PYRAMID_ILLUSTRATION_SHADOUF},
            QUEEN: {modelPath: ab.PYRAMID_QUEEN, materialId: Eb.PYRAMID_ILLUSTRATION_QUEEN},
            BRICKS: {modelPath: ab.PYRAMID_BRICKS, materialId: Eb.PYRAMID_ILLUSTRATION_BRICKS},
            GIFTS: {modelPath: ab.CHAPEL_GIFTS, materialId: Eb.CHAPEL_ILLUSTRATION_GIFTS},
            CHAPEL_WALL_NORTH: {modelPath: ab.CHAPEL_WALL_NORTH, materialId: Eb.CHAPEL_ILLUSTRATION_WALL_NORTH},
            CHAPEL_WALL_SOUTH: {modelPath: ab.CHAPEL_WALL_SOUTH, materialId: Eb.CHAPEL_ILLUSTRATION_WALL_SOUTH},
            BURIAL_CHAMBER_GODS: {modelPath: ab.BURIAL_CHAMBER_GODS, materialId: Eb.BURIAL_CHAMBER_ILLUSTRATION_GODS},
            BURIAL_CHAMBER_BABIRD: {modelPath: ab.BURIAL_CHAMBER_BABIRD, materialId: Eb.BURIAL_CHAMBER_ILLUSTRATION_BABIRD},
            BURIAL_CHAMBER_VESSELS: {
                modelPath: ab.BURIAL_CHAMBER_VESSELS,
                materialId: Eb.BURIAL_CHAMBER_ILLUSTRATION_VESSELS
            },
            ANGLE_XR: {modelPath: ab.PYRAMID_ANGLE, materialId: Eb.PYRAMID_ILLUSTRATION_ANGLE},
            BRICKS_XR: {modelPath: ab.PYRAMID_BRICKS, materialId: Eb.PYRAMID_ILLUSTRATION_BRICKS},
            KING_XR: {modelPath: ab.PYRAMID_QUEEN, materialId: Eb.PYRAMID_ILLUSTRATION_QUEEN},
            SHADOUF_XR: {modelPath: ab.PYRAMID_SHADOUF, materialId: Eb.PYRAMID_ILLUSTRATION_SHADOUF},
            BURIAL_CHAMBER_GODS_XR: {
                modelPath: ab.BURIAL_CHAMBER_GODS_XR,
                materialId: Eb.BURIAL_CHAMBER_ILLUSTRATION_GODS_XR
            },
            BURIAL_CHAMBER_BABIRD_XR: {
                modelPath: ab.BURIAL_CHAMBER_BABIRD_XR,
                materialId: Eb.BURIAL_CHAMBER_ILLUSTRATION_BABIRD_XR
            },
            BURIAL_CHAMBER_VESSELS_XR: {
                modelPath: ab.BURIAL_CHAMBER_VESSELS_XR,
                materialId: Eb.BURIAL_CHAMBER_ILLUSTRATION_VESSELS_XR
            }
        }, Ub = [kb.GLOBE_MAP, kb.GLOBE_KINGDOM, kb.GLOBE_MEROE], Fb = [kb.ANGLE, kb.SHADOUF, kb.QUEEN, kb.BRICKS],
        Hb = [kb.GIFTS, kb.CHAPEL_WALL_SOUTH, kb.CHAPEL_WALL_NORTH],
        zb = [kb.GIFTS, kb.CHAPEL_WALL_SOUTH, kb.CHAPEL_WALL_NORTH],
        Gb = [kb.BURIAL_CHAMBER_GODS, kb.BURIAL_CHAMBER_BABIRD, kb.BURIAL_CHAMBER_VESSELS],
        Vb = [kb.BURIAL_CHAMBER_GODS_XR, kb.BURIAL_CHAMBER_BABIRD_XR, kb.BURIAL_CHAMBER_VESSELS_XR],
        Wb = [kb.ANGLE_XR, kb.SHADOUF_XR, kb.KING_XR, kb.BRICKS_XR];

    function jb(e, t) {
        const n = Ly() ? 0 : 2;
        n ? bi.to(e, {duration: n, alpha: t}) : bi.set(e, {alpha: t})
    }

    function $b(e, t) {
        for (let n = 0; n < e.length; n++) {
            const i = t === n ? 1 : 0, r = e[n];
            r.alpha !== i && jb(r, i)
        }
    }

    function Xb(e, t = 0, n = 1) {
        return e > t && e < n
    }

    function qb(e, t, n) {
        return (e - t) / (n - t)
    }

    class Yb {
        constructor(e) {
            this.time = e
        }
    }

    const Kb = "checkpoint";

    class Jb extends Hc {
        constructor(e, t) {
            super(), this.id = e, this.isActive = !1, this.checkpoints = t.map((e => new Yb(e)))
        }

        update(e) {
            const t = this.getNormalisedProgress(e), n = Xb(t, 0, 1), i = this.isActive && !n, r = !this.isActive && n;
            (i || r) && (this.isActive = n, this.dispatchEvent({
                type: Kb,
                id: this.id,
                active: this.isActive,
                progress: t
            }))
        }

        getNormalisedProgress(e) {
            return qb(e, this.checkpoints[0].time, this.checkpoints[this.checkpoints.length - 1].time)
        }
    }

    class Zb extends Pb {
        constructor(e, t = 0) {
            super(), this.engine = e, this.onCheckpoint = e => {
                const {active: t} = e;
                jb(this, t ? .9 : 0)
            }, this.alpha = t
        }

        async initialise(e, t) {
            const n = await this.engine.loaders.loadModel(e), i = rb(n), r = this.engine.materials[t];
            this.add(new ib(i, r));
            const [s] = n.animations;
            s && this.populateBooleanAnimation(s), this.setAlpha(this.alpha)
        }

        update(e) {
            var t;
            null === (t = this.booleanAnimation) || void 0 === t || t.update(e)
        }

        populateBooleanAnimation(e) {
            const {name: t, tracks: n} = e, [i] = n, r = [...i.times];
            this.booleanAnimation = new Jb(t, r), this.booleanAnimation.addEventListener(Kb, this.onCheckpoint)
        }
    }

    class Qb {
        constructor(e) {
            this.timeline = bi.timeline(vb), this.scene = e.scene, this.mixer = new P_(this.scene);
            const {action: t, animation: n, camera: i} = function (e, t) {
                const [n] = t.cameras, [i] = t.animations, r = e.clipAction(i);
                return function (e) {
                    e.loop = 2200, e.repetitions = 0, e.clampWhenFinished = !0, e.zeroSlopeAtEnd = !1, e.zeroSlopeAtStart = !1, e.play(), e.paused = !0, e.time = 0
                }(r), {camera: n, mixer: e, action: r, animation: i}
            }(this.mixer, e);
            this.action = t, this.animation = n, this.camera = i, this.timeline.to(this.action, {time: this.animation.duration}), this.timeline.pause()
        }

        get progress() {
            return this.timeline.progress()
        }

        set progress(e) {
            this.timeline.progress(e)
        }
    }

    var ew;
    !function (e) {
        e.CHANGE = "change"
    }(ew || (ew = {}));

    class tw extends Hc {
        constructor(e, t) {
            super(), this.cameraContainer = e, this.fallbackCamera = t, this._animationTrackProgress = 0, this.activeResponsiveCamera = null, this.fallbackResponsiveCamera = null, this.onMediaQuery = e => {
                var t;
                (null === (t = e.mediaQuery) || void 0 === t ? void 0 : t.matches) ? this.setActiveGltfCamera(e) : this.fallbackResponsiveCamera && this.setActiveGltfCamera(this.fallbackResponsiveCamera)
            }
        }

        add(e, t = !1) {
            t && (this.fallbackResponsiveCamera = e, this.activeResponsiveCamera || this.setActiveGltfCamera(e)), e.mediaQuery && (e.mediaQuery.addListener((() => {
                this.onMediaQuery(e)
            })), e.mediaQuery.matches && this.onMediaQuery(e))
        }

        setActiveGltfCamera(e) {
            if (e === this.activeResponsiveCamera) return;
            const t = this.activeResponsiveCamera;
            t && (this.cameraContainer.remove(t.track.scene), e.track.camera.aspect = null == t ? void 0 : t.track.camera.aspect, e.track.camera.updateProjectionMatrix()), this.activeResponsiveCamera = e, this.cameraContainer.add(e.track.scene), e.track.progress = this._animationTrackProgress, this.dispatchEvent({type: ew.CHANGE})
        }

        getActiveCamera() {
            var e;
            return (null === (e = this.activeResponsiveCamera) || void 0 === e ? void 0 : e.track.camera) || this.fallbackCamera
        }

        getActiveCameraTrack() {
            return this.activeResponsiveCamera
        }

        resize(e) {
            this.activeResponsiveCamera && (this.activeResponsiveCamera.track.camera.aspect = e.aspect, this.activeResponsiveCamera.track.camera.updateProjectionMatrix())
        }

        set trackProgress(e) {
            this._animationTrackProgress = e, this.activeResponsiveCamera && (this.activeResponsiveCamera.track.progress = e)
        }

        get trackProgress() {
            return this._animationTrackProgress
        }
    }

    class nw {
        constructor(e) {
            this.engine = e, this.scene = new Sm, this.camera = new wd
        }

        resize(e) {
            this.camera.aspect = e.aspect, this.camera.updateProjectionMatrix()
        }

        dispose() {
            Jx(this.scene)
        }
    }

    class iw extends mu {
        constructor() {
            super(...arguments), this.swayDuration = .5
        }

        sway(e, t) {
            if (e) {
                const t = {...e, duration: this.swayDuration};
                bi.to(this.position, t)
            }
            if (t) {
                const e = {...t, duration: this.swayDuration};
                bi.to(this.rotation, e)
            }
        }

        resetSway() {
            const e = {x: 0, y: 0, z: 0, duration: this.swayDuration};
            bi.to(this.position, e), bi.to(this.rotation, e)
        }

        dispose() {
            bi.killTweensOf(this.rotation), bi.killTweensOf(this.position)
        }
    }

    class rw extends nw {
        constructor(e) {
            super(e), this.animationRequestId = 0, this.cameraContainer = new iw, this.postProcessing = null, this.isOnScreen = !1, this.isRendering = !1, this.onCameraChange = () => {
                this.camera = this.cameraManager.getActiveCamera(), this.postProcessing && (this.postProcessing.camera = this.cameraManager.getActiveCamera()), this.isOnScreen && this.render()
            }, this.onTimelineProgress = () => {
                this.isOnScreen = Xb(this.timeline.progress(), 0, 1), this.isOnScreen ? this.startRenderLoop() : this.stopRenderLoop()
            }, this.stopRenderLoop = () => {
                this.isRendering = !1, window.cancelAnimationFrame(this.animationRequestId)
            }, this.stopRenderDebounced = Py(this.stopRenderLoop, 500), this.renderLoop = () => {
                var e;
                null === (e = this.update) || void 0 === e || e.call(this, 0), this.render(), this.isRendering && (this.animationRequestId = window.requestAnimationFrame(this.renderLoop))
            }, this.cameraContainer.add(this.camera), this.scene.add(this.cameraContainer), this.cameraManager = new tw(this.cameraContainer, this.camera), this.timeline = bi.timeline({
                ...vb,
                paused: !0,
                onUpdate: this.onTimelineProgress
            }), this.cameraManager.addEventListener(ew.CHANGE, this.onCameraChange)
        }

        setupCameras(e) {
            e.map((async ({path: e, fov: t, mediaQuery: n, near: i, far: r}) => {
                const s = await this.engine.loaders.loadModel(e), a = !n, o = new Qb(s), l = {track: o, mediaQuery: n};
                a && (this.camera = o.camera), t && (o.camera.fov = t), i && (o.camera.near = i), r && (o.camera.far = r), this.cameraManager.add(l, a), this.cameraManager.resize(this.engine.boundaries), this.isOnScreen && this.render()
            }))
        }

        startRenderLoop() {
            var e;
            this.isRendering ? null === (e = this.update) || void 0 === e || e.call(this, 0) : (this.isRendering = !0, this.renderLoop()), this.stopRenderDebounced()
        }

        render() {
            this.postProcessing ? this.postProcessing.composer.render() : this.engine.renderer.render(this.scene, this.cameraManager.getActiveCamera())
        }

        resize(e) {
            var t;
            this.cameraManager.resize(e), null === (t = this.postProcessing) || void 0 === t || t.resize(e), super.resize(e)
        }

        dispose() {
            this.stopRenderLoop(), this.postProcessing && (this.postProcessing.dispose(), this.postProcessing = null), super.dispose()
        }
    }

    class sw {
        constructor() {
            this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
        }

        setSize() {
        }

        render() {
            console.error("THREE.Pass: .render() must be implemented in derived pass.")
        }
    }

    const aw = new $d(-1, 1, 1, -1, 0, 1), ow = new Ku;
    ow.setAttribute("position", new Gu([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), ow.setAttribute("uv", new Gu([0, 2, 0, 0, 2, 0], 2));

    class lw {
        constructor(e) {
            this._mesh = new fd(ow, e)
        }

        dispose() {
            this._mesh.geometry.dispose()
        }

        render(e) {
            e.render(this._mesh, aw)
        }

        get material() {
            return this._mesh.material
        }

        set material(e) {
            this._mesh.material = e
        }
    }

    var cw = {
        uniforms: {tDiffuse: {value: null}, opacity: {value: 1}},
        vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"
    };
    const hw = {
        shaderID: "luminosityHighPass",
        uniforms: {
            tDiffuse: {value: null},
            luminosityThreshold: {value: 1},
            smoothWidth: {value: 1},
            defaultColor: {value: new Nu(0)},
            defaultOpacity: {value: 0}
        },
        vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"
    };

    class uw extends sw {
        constructor(e, t, n, i) {
            super(), this.strength = void 0 !== t ? t : 1, this.radius = n, this.threshold = i, this.resolution = void 0 !== e ? new eh(e.x, e.y) : new eh(256, 256), this.clearColor = new Nu(0, 0, 0);
            const r = {minFilter: oc, magFilter: oc, format: gc};
            this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
            let s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
            this.renderTargetBright = new hh(s, a, r), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
            for (let e = 0; e < this.nMips; e++) {
                const t = new hh(s, a, r);
                t.texture.name = "UnrealBloomPass.h" + e, t.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(t);
                const n = new hh(s, a, r);
                n.texture.name = "UnrealBloomPass.v" + e, n.texture.generateMipmaps = !1, this.renderTargetsVertical.push(n), s = Math.round(s / 2), a = Math.round(a / 2)
            }
            void 0 === hw && console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
            const o = hw;
            this.highPassUniforms = yd.clone(o.uniforms), this.highPassUniforms.luminosityThreshold.value = i, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new xd({
                uniforms: this.highPassUniforms,
                vertexShader: o.vertexShader,
                fragmentShader: o.fragmentShader,
                defines: {}
            }), this.separableBlurMaterials = [];
            const l = [3, 5, 7, 9, 11];
            s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
            for (let e = 0; e < this.nMips; e++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[e])), this.separableBlurMaterials[e].uniforms.texSize.value = new eh(s, a), s = Math.round(s / 2), a = Math.round(a / 2);
            this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0;
            this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new ph(1, 1, 1), new ph(1, 1, 1), new ph(1, 1, 1), new ph(1, 1, 1), new ph(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, void 0 === cw && console.error("THREE.UnrealBloomPass relies on CopyShader");
            const c = cw;
            this.copyUniforms = yd.clone(c.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new xd({
                uniforms: this.copyUniforms,
                vertexShader: c.vertexShader,
                fragmentShader: c.fragmentShader,
                blending: 2,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new Nu, this.oldClearAlpha = 1, this.basic = new Bu, this.fsQuad = new lw(null)
        }

        dispose() {
            for (let e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
            for (let e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
            this.renderTargetBright.dispose()
        }

        setSize(e, t) {
            let n = Math.round(e / 2), i = Math.round(t / 2);
            this.renderTargetBright.setSize(n, i);
            for (let e = 0; e < this.nMips; e++) this.renderTargetsHorizontal[e].setSize(n, i), this.renderTargetsVertical[e].setSize(n, i), this.separableBlurMaterials[e].uniforms.texSize.value = new eh(n, i), n = Math.round(n / 2), i = Math.round(i / 2)
        }

        render(e, t, n, i, r) {
            e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
            const s = e.autoClear;
            e.autoClear = !1, e.setClearColor(this.clearColor, 0), r && e.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
            let a = this.renderTargetBright;
            for (let t = 0; t < this.nMips; t++) this.fsQuad.material = this.separableBlurMaterials[t], this.separableBlurMaterials[t].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[t].uniforms.direction.value = uw.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[t]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[t].uniforms.colorTexture.value = this.renderTargetsHorizontal[t].texture, this.separableBlurMaterials[t].uniforms.direction.value = uw.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[t]), e.clear(), this.fsQuad.render(e), a = this.renderTargetsVertical[t];
            this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && e.state.buffers.stencil.setTest(!0), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = s
        }

        getSeperableBlurMaterial(e) {
            return new xd({
                defines: {KERNEL_RADIUS: e, SIGMA: e},
                uniforms: {
                    colorTexture: {value: null},
                    texSize: {value: new eh(.5, .5)},
                    direction: {value: new eh(.5, .5)}
                },
                vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                fragmentShader: "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
            })
        }

        getCompositeMaterial(e) {
            return new xd({
                defines: {NUM_MIPS: e},
                uniforms: {
                    blurTexture1: {value: null},
                    blurTexture2: {value: null},
                    blurTexture3: {value: null},
                    blurTexture4: {value: null},
                    blurTexture5: {value: null},
                    dirtTexture: {value: null},
                    bloomStrength: {value: 1},
                    bloomFactors: {value: null},
                    bloomTintColors: {value: null},
                    bloomRadius: {value: 0}
                },
                vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                fragmentShader: "varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"
            })
        }
    }

    uw.BlurDirectionX = new eh(1, 0), uw.BlurDirectionY = new eh(0, 1);

    class dw extends sw {
        constructor(e, t) {
            super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof xd ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = yd.clone(e.uniforms), this.material = new xd({
                defines: Object.assign({}, e.defines),
                uniforms: this.uniforms,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader
            })), this.fsQuad = new lw(this.material)
        }

        render(e, t, n) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e))
        }
    }

    class pw extends sw {
        constructor(e, t) {
            super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1
        }

        render(e, t, n) {
            const i = e.getContext(), r = e.state;
            let s, a;
            r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0), this.inverse ? (s = 0, a = 1) : (s = 1, a = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295), r.buffers.stencil.setClear(a), r.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), r.buffers.stencil.setLocked(!0)
        }
    }

    class fw extends sw {
        constructor() {
            super(), this.needsSwap = !1
        }

        render(e) {
            e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1)
        }
    }

    class mw {
        constructor(e, t) {
            if (this.renderer = e, void 0 === t) {
                const n = {minFilter: oc, magFilter: oc, format: gc}, i = e.getSize(new eh);
                this._pixelRatio = e.getPixelRatio(), this._width = i.width, this._height = i.height, (t = new hh(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1"
            } else this._pixelRatio = 1, this._width = t.width, this._height = t.height;
            this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === cw && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === dw && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new dw(cw), this.clock = new g_
        }

        swapBuffers() {
            const e = this.readBuffer;
            this.readBuffer = this.writeBuffer, this.writeBuffer = e
        }

        addPass(e) {
            this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }

        insertPass(e, t) {
            this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }

        removePass(e) {
            const t = this.passes.indexOf(e);
            -1 !== t && this.passes.splice(t, 1)
        }

        isLastEnabledPass(e) {
            for (let t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return !1;
            return !0
        }

        render(e) {
            void 0 === e && (e = this.clock.getDelta());
            const t = this.renderer.getRenderTarget();
            let n = !1;
            for (let t = 0, i = this.passes.length; t < i; t++) {
                const i = this.passes[t];
                if (!1 !== i.enabled) {
                    if (i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t), i.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), i.needsSwap) {
                        if (n) {
                            const t = this.renderer.getContext(), n = this.renderer.state.buffers.stencil;
                            n.setFunc(t.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), n.setFunc(t.EQUAL, 1, 4294967295)
                        }
                        this.swapBuffers()
                    }
                    void 0 !== pw && (i instanceof pw ? n = !0 : i instanceof fw && (n = !1))
                }
            }
            this.renderer.setRenderTarget(t)
        }

        reset(e) {
            if (void 0 === e) {
                const t = this.renderer.getSize(new eh);
                this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
        }

        setSize(e, t) {
            this._width = e, this._height = t;
            const n = this._width * this._pixelRatio, i = this._height * this._pixelRatio;
            this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
            for (let e = 0; e < this.passes.length; e++) this.passes[e].setSize(n, i)
        }

        setPixelRatio(e) {
            this._pixelRatio = e, this.setSize(this._width, this._height)
        }
    }

    new $d(-1, 1, 1, -1, 0, 1);
    const gw = new Ku;
    gw.setAttribute("position", new Gu([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), gw.setAttribute("uv", new Gu([0, 2, 0, 0, 2, 0], 2));

    class vw extends sw {
        constructor(e, t, n, i, r) {
            super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = void 0 !== r ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Nu
        }

        render(e, t, n) {
            const i = e.autoClear;
            let r, s;
            e.autoClear = !1, void 0 !== this.overrideMaterial && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), r = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = s), e.autoClear = i
        }
    }

    class _w {
        constructor(e, t, n) {
            this.passes = [], this.composer = new mw(e.renderer), this.passes.push(new vw(t, n))
        }

        addPasses() {
            for (let e = 0; e < this.passes.length; e++) {
                const t = this.passes[e];
                t.renderToScreen = e === this.passes.length - 1, this.composer.addPass(t)
            }
        }

        resize(e) {
            const {width: t, height: n, pixelRatio: i} = e;
            this.composer.setSize(t, n), this.composer.setPixelRatio(i)
        }

        dispose() {
            for (const e of this.passes) this.composer.removePass(e);
            this.passes = []
        }

        set camera(e) {
            this.passes[0].camera = e
        }
    }

    class yw extends dw {
        constructor(e, t = 50) {
            super({
                uniforms: {
                    tDiffuse: {value: null},
                    uStrength: {value: t},
                    uAlpha: {value: 1},
                    uSpread: {value: .25}
                },
                vertexShader: Ob,
                fragmentShader: "\n  varying vec2 vUv;\n  uniform sampler2D tDiffuse;\n  uniform float uStrength;\n  uniform float uAlpha;\n  uniform float uSpread;\n\n  void main() {\n    vec4 texture = texture2D(tDiffuse, vUv);\n    float vignette = vUv.y * vUv.x * (1.-vUv.x) * (1.-vUv.y) * uSpread;\n    float multiplier = 1.0 - (vignette * uStrength);\n    multiplier = clamp(multiplier, 0.0, uAlpha);\n\n    texture.rgb *= (1.0 - multiplier);\n    gl_FragColor = vec4(texture.rgb, 1.0);\n  }\n"
            })
        }

        get spread() {
            return this.material.uniforms.uSpread.value
        }

        set spread(e) {
            this.material.uniforms.uSpread.value = e
        }

        get strength() {
            return this.material.uniforms.uStrength.value
        }

        set strength(e) {
            this.material.uniforms.uStrength.value = e
        }

        get alpha() {
            return this.material.uniforms.uAlpha.value
        }

        set alpha(e) {
            this.material.uniforms.uAlpha.value = e
        }
    }

    class xw extends _w {
        constructor(e, t, n) {
            super(e, t, n), this.bloomPass = new uw(e.boundaries.vec2, 3.5, 1, 1), this.passes.push(this.bloomPass), this.vignettePass = new yw(e), this.vignettePass.strength = 100, this.vignettePass.spread = .25, this.vignettePass.alpha = 0, this.passes.push(this.vignettePass), this.addPasses()
        }

        resize(e) {
            this.bloomPass.resolution.x = e.width, this.bloomPass.resolution.y = e.height, super.resize(e)
        }
    }

    const bw = yb.SANDSTONE, ww = yb.GREY_999;

    class Tw extends rw {
        constructor(e) {
            super(e), this.postProcessing = new xw(this.engine, this.scene, this.camera), this.illustrations = [], this.burialChamber = new Cb(this.engine), this.pyramid = new Ib(this.engine), this.fadeToBlackOverlay = new Bb(this.engine, yb.GREY_999), this.pointerMove = e => {
                if (!this.isOnScreen) return;
                const t = e, {x: n, y: i} = t.pointer;
                this.cameraContainer.sway({y: .05 * i}, {y: .03125 * -n}), this.startRenderLoop()
            };
            const t = bw.clone();
            this.scene.background = t, this.scene.fog = new Tm(ww, 0, 120), this.scene.add(this.pyramid), this.scene.add(this.burialChamber), this.fadeToBlackOverlay.alpha = 1, this.scene.add(this.fadeToBlackOverlay), this.postProcessing.bloomPass.strength = 0, this.timeline.to(this.cameraManager, {trackProgress: .8}), this.timeline.to(this.fadeToBlackOverlay, {
                alpha: 0,
                duration: .064
            }, 0), this.timeline.to(this.postProcessing.vignettePass, {
                alpha: 1,
                duration: .0032
            }, .135), this.timeline.to(this.postProcessing.bloomPass, {
                threshold: .4,
                strength: 3.5,
                duration: .032
            }, .135), this.timeline.to(t, {
                r: ww.r,
                g: ww.g,
                b: ww.b,
                duration: .035
            }, .1), this.timeline.to(this.scene.fog, {
                far: 16,
                duration: .0476
            }, .0875), e.events.addEventListener(Hy.POINTER_MOVE, this.pointerMove)
        }

        async initialise() {
            const e = [{
                path: lb.BURIAL_CHAMBER_MOBILE,
                fov: 50
            }, {
                path: eb ? lb.BURIAL_CHAMBER_DESKTOP_RTL : lb.BURIAL_CHAMBER_DESKTOP,
                mediaQuery: window.matchMedia(xb)
            }];
            this.setupCameras(e), this.fadeToBlackOverlay.initialise();
            const t = [this.pyramid.initialise(), this.burialChamber.initialise()];
            await Promise.all(t);
            for (const {modelPath: e, materialId: t} of Gb) {
                const n = new Zb(this.engine);
                n.initialise(e, t), this.scene.add(n), this.illustrations.push(n)
            }
        }

        update(e, t) {
            const n = this.cameraManager.getActiveCameraTrack();
            if (n) {
                n.track.mixer.update(e);
                for (const e of this.illustrations) e.update(n.track.action.time)
            }
        }
    }

    let Sw;

    async function Ew(e) {
        return Sw || (Sw = await async function (e) {
            const t = rb(await e.loaders.loadModel(ab.CHAPEL)), n = e.materials[Eb.CHAPEL];
            return {mesh: new ib(t, n)}
        }(e)), Sw
    }

    class Mw extends nb {
        async initialise() {
            this.resources = await Ew(this.engine);
            const e = this.resources.mesh.clone();
            e.matrixAutoUpdate = !1, this.add(e)
        }
    }

    class Aw extends dw {
        constructor(e, t = .6) {
            const {vec2: n, pixelRatio: i} = e.boundaries;
            super({
                uniforms: {
                    tDiffuse: {value: null},
                    uResolution: {value: n.clone().addScalar(i)},
                    uStrength: {value: t}
                },
                vertexShader: Ob,
                fragmentShader: "\n  varying highp vec2 vUv;\n\n  uniform sampler2D tDiffuse;\n  uniform highp vec2 uResolution;\n  uniform highp float uStrength;\n  void main ()\n  {\n    lowp vec4 sum_1;\n    highp float tmpvar_2;\n    tmpvar_2 = (1.0/(uResolution.x));\n    highp float tmpvar_3;\n    tmpvar_3 = (1.0/(uResolution.y));\n    highp vec2 tmpvar_4;\n    tmpvar_4.x = -(tmpvar_2);\n    tmpvar_4.y = 0.0;\n    sum_1 = -(texture2D (tDiffuse, (vUv + tmpvar_4)));\n    highp vec2 tmpvar_5;\n    tmpvar_5.x = 0.0;\n    tmpvar_5.y = -(tmpvar_3);\n    sum_1 = (sum_1 - texture2D (tDiffuse, (vUv + tmpvar_5)));\n    lowp vec4 tmpvar_6;\n    tmpvar_6 = texture2D (tDiffuse, vUv);\n    sum_1 = (sum_1 + (5.0 * tmpvar_6));\n    highp vec2 tmpvar_7;\n    tmpvar_7.x = 0.0;\n    tmpvar_7.y = tmpvar_3;\n    sum_1 = (sum_1 - texture2D (tDiffuse, (vUv + tmpvar_7)));\n    highp vec2 tmpvar_8;\n    tmpvar_8.x = tmpvar_2;\n    tmpvar_8.y = 0.0;\n    sum_1 = (sum_1 - texture2D (tDiffuse, (vUv + tmpvar_8)));\n    lowp vec4 tmpvar_9;\n    tmpvar_9 = mix (tmpvar_6, sum_1, uStrength);\n    gl_FragColor = tmpvar_9;\n  }\n"
            })
        }

        resize(e) {
            const t = e.vec2.clone().addScalar(e.pixelRatio);
            this.material.uniforms.uResolution.value.x = t.x, this.material.uniforms.uResolution.value.y = t.y
        }

        get strength() {
            return this.material.uniforms.uStrength.value
        }

        set strength(e) {
            e <= 0 ? this.enabled = !1 : (this.enabled = !0, this.material.uniforms.uStrength.value = e)
        }
    }

    class Lw extends _w {
        constructor(e, t, n) {
            super(e, t, n), this.sharpenPass = new Aw(e), this.passes.push(this.sharpenPass), this.addPasses()
        }

        resize(e) {
            this.sharpenPass.resize(e), super.resize(e)
        }

        get strength() {
            return this.sharpenPass.material.uniforms.uStrength.value
        }

        set strength(e) {
            this.sharpenPass.material.uniforms.uStrength.value = e
        }
    }

    const Cw = .025;

    class Rw extends rw {
        constructor(e) {
            super(e), this.postProcessing = new Lw(this.engine, this.scene, this.camera), this.illustrations = [], this.chapel = new Mw(this.engine), this.fadeToBlackOverlay = new Bb(this.engine, yb.GREY_999), this.pointerMove = e => {
                if (!this.isOnScreen) return;
                const t = e;
                this.cameraContainer.sway({x: .016 * t.pointer.x, y: .014 * t.pointer.y}), this.startRenderLoop()
            }, this.pointerUp = () => {
                this.isOnScreen && this.cameraContainer.resetSway()
            }, this.fadeToBlackOverlay.alpha = 1, this.scene.add(this.chapel), this.scene.add(this.fadeToBlackOverlay), this.timeline.to(this.fadeToBlackOverlay, {
                alpha: 0,
                duration: Cw
            }, "main"), this.timeline.to(this.cameraManager, {trackProgress: 1}, "main"), this.timeline.to(this.fadeToBlackOverlay, {
                alpha: 1,
                duration: .05
            }, .45), e.events.addEventListener(Hy.POINTER_MOVE, this.pointerMove)
        }

        async initialise() {
            const e = [{path: lb.CHAPEL_MOBILE, fov: 80}, {
                path: eb ? lb.CHAPEL_DESKTOP_RTL : lb.CHAPEL_DESKTOP,
                mediaQuery: window.matchMedia(xb),
                fov: 60
            }];
            this.setupCameras(e), this.fadeToBlackOverlay.initialise(), await this.chapel.initialise();
            for (const {modelPath: e, materialId: t} of Hb) {
                const n = new Zb(this.engine);
                n.initialise(e, t), this.scene.add(n), this.illustrations.push(n)
            }
        }

        update(e) {
            const t = this.cameraManager.getActiveCameraTrack();
            if (t) {
                t.track.mixer.update(e);
                for (const e of this.illustrations) e.update(t.track.action.time)
            }
        }
    }

    class Pw extends mu {
        constructor(e) {
            super(), this.element = e || document.createElement("div"), this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", (function () {
                this.traverse((function (e) {
                    e.element instanceof Element && null !== e.element.parentNode && e.element.parentNode.removeChild(e.element)
                }))
            }))
        }

        copy(e, t) {
            return super.copy(e, t), this.element = e.element.cloneNode(!0), this
        }
    }

    Pw.prototype.isCSS2DObject = !0;
    const Iw = new ph, Ow = new Wh, Dw = new Wh, Nw = new ph, Bw = new ph;

    class kw {
        constructor() {
            const e = this;
            let t, n, i, r;
            const s = {objects: new WeakMap}, a = document.createElement("div");

            function o(t, n, c) {
                if (t.isCSS2DObject) {
                    t.onBeforeRender(e, n, c), Iw.setFromMatrixPosition(t.matrixWorld), Iw.applyMatrix4(Dw);
                    const o = t.element;
                    /apple/i.test(navigator.vendor) ? o.style.transform = "translate(-50%,-50%) translate(" + Math.round(Iw.x * i + i) + "px," + Math.round(-Iw.y * r + r) + "px)" : o.style.transform = "translate(-50%,-50%) translate(" + (Iw.x * i + i) + "px," + (-Iw.y * r + r) + "px)", o.style.display = t.visible && Iw.z >= -1 && Iw.z <= 1 ? "" : "none";
                    const h = {distanceToCameraSquared: l(c, t)};
                    s.objects.set(t, h), o.parentNode !== a && a.appendChild(o), t.onAfterRender(e, n, c)
                }
                for (let e = 0, i = t.children.length; e < i; e++) o(t.children[e], n, c)
            }

            function l(e, t) {
                return Nw.setFromMatrixPosition(e.matrixWorld), Bw.setFromMatrixPosition(t.matrixWorld), Nw.distanceToSquared(Bw)
            }

            a.style.overflow = "hidden", this.domElement = a, this.getSize = function () {
                return {width: t, height: n}
            }, this.render = function (e, t) {
                !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), Ow.copy(t.matrixWorldInverse), Dw.multiplyMatrices(t.projectionMatrix, Ow), o(e, e, t), function (e) {
                    const t = function (e) {
                        const t = [];
                        return e.traverse((function (e) {
                            e.isCSS2DObject && t.push(e)
                        })), t
                    }(e).sort((function (e, t) {
                        return s.objects.get(e).distanceToCameraSquared - s.objects.get(t).distanceToCameraSquared
                    })), n = t.length;
                    for (let e = 0, i = t.length; e < i; e++) t[e].element.style.zIndex = n - e
                }(e)
            }, this.setSize = function (e, s) {
                t = e, n = s, i = t / 2, r = n / 2, a.style.width = e + "px", a.style.height = s + "px"
            }
        }
    }

    let Uw;
    const Fw = new Bd(2, 2, 1, 1);

    function Hw(e) {
        return Uw || (Uw = function (e) {
            const t = new xd({
                vertexShader: Ob,
                fragmentShader: "\n  varying vec2 vUv;\n\n  uniform float uAlpha;\n  uniform float uStrength;\n  uniform vec3 uColor;\n\n  void main() {\n    float alpha = (vUv.x - vUv.y);\n    alpha += uStrength - (vUv.y / 20.0);\n    vec3 color = uColor;\n    gl_FragColor = vec4(color, alpha);\n  }\n",
                depthWrite: !1,
                transparent: !0,
                uniforms: {uAlpha: {value: 1}, uColor: {value: e}, uStrength: {value: .4}}
            });
            return {geometry: Fw, material: t}
        }(e)), Uw
    }

    class zw extends nb {
        constructor(e, t) {
            super(e), this.color = t, this.resources = Hw(this.color)
        }

        initialise() {
            const e = new ib(this.resources.geometry, this.resources.material);
            e.frustumCulled = !1, this.add(e)
        }

        get alpha() {
            return this.resources.material.uniforms.uAlpha.value || 0
        }

        set alpha(e) {
            this.resources.material.uniforms.uAlpha.value = e
        }

        get strength() {
            return this.resources.material.uniforms.uStrength.value || 0
        }

        set strength(e) {
            this.resources.material.uniforms.uStrength.value = e
        }
    }

    const Gw = new Bd(1, 1);
    Gw.rotateX(-Math.PI / 2);
    const Vw = new Bd(1, 1);
    let Ww;
    const jw = {models: [ab.GLOBE, ab.GLOBE_CLOUDS]}, $w = 1.63;

    async function Xw(e) {
        return Ww || (Ww = await async function (e) {
            if (Ww) return Ww;
            const [t, n] = await e.loaders.loadManifest(jw), i = rb(t), r = rb(n), s = Vw.clone();
            s.rotateY(Math.PI), s.scale($w, $w, $w);
            const a = e.materials[Eb.GLOBE], o = e.materials[Eb.GLOBE_CLOUDS], l = e.materials[Eb.GLOBE_GLOW];
            return {planet: new ib(i, a), clouds: new ib(r, o), glow: new ib(s, l)}
        }(e)), Ww
    }

    class qw extends nb {
        async initialise() {
            const e = await Xw(this.engine);
            this.resources = e, this.add(e.planet), this.add(e.clouds), this.add(e.glow)
        }

        dispose(e) {
            this.resources && (this.remove(this.resources.planet), Jx(this.resources.planet, e), this.remove(this.resources.clouds), Jx(this.resources.clouds, e), this.remove(this.resources.glow), Jx(this.resources.glow, e)), super.dispose(e)
        }
    }

    var Yw;
    !function (e) {
        e.EGYPT = "egypt", e.MEROE = "meroe", e.SUDAN = "sudan"
    }(Yw || (Yw = {}));
    const Kw = {egypt: [-.006146, .37102, .33452], meroe: [-.024295, .40983, .28524], sudan: [.013411, .4227, .26675]};
    const Jw = .025, Zw = yb.GREY_900, Qw = new eh(1, -1), eT = [{path: lb.GLOBE}];

    class tT extends rw {
        constructor(e) {
            if (super(e), this.planet = new qw(this.engine), this.gradient = new zw(this.engine, Zw), this.postProcessing = new Lw(this.engine, this.scene, this.camera), this.annotationRenderer = new kw, this.annotationContainer = document.getElementById("annotation"), this.annotationLabelContainer = document.getElementById("annotation-content"), this.illustrations = [], this.fadeToWhiteOverlay = new Bb(this.engine, yb.SANDSTONE), this.zoomIntoArea = () => {
                if (!this.planet.resources) return;
                const e = qb(this.cameraManager.trackProgress, .25, 1);
                this.gradient.strength = .2 - .8 * e, this.planet.resources.clouds.material.opacity = 1 - e
            }, this.pointerMove = e => {
                var t;
                if (!this.isOnScreen) return;
                const {pointer: n} = e, {x: i, y: r} = n;
                if (this.cameraContainer.sway({y: .03125 * r}, {y: .03125 * -i}), null === (t = this.planet.resources) || void 0 === t ? void 0 : t.glow) {
                    const e = n.distanceTo(Qw), t = Math.min(Math.max(0, .35 * e), 1);
                    bi.to(this.planet.resources.glow.material, {opacity: t})
                }
                this.startRenderLoop()
            }, this.scene.background = Zw, this.scene.add(this.planet), this.scene.add(this.gradient), this.fadeToWhiteOverlay.alpha = 0, this.cameraContainer.add(this.fadeToWhiteOverlay), this.annotationContainer && this.annotationLabelContainer) {
                const [t, n, i] = function (e, t) {
                    const n = [];
                    for (let i = 0; i < e.children.length; i++) {
                        const r = e.children[i], s = r.dataset.annotationId;
                        if (!s || !Kw[s]) continue;
                        const [a, o, l] = Kw[s], c = r.cloneNode(!0), h = new Pw(c);
                        h.matrixAutoUpdate = !1, h.position.set(a, l, -o), h.updateMatrix(), s === Yw.MEROE && (c.style.opacity = "0"), n.push(h), t.add(h)
                    }
                    return n
                }(this.annotationLabelContainer, this.scene);
                this.annotationContainer.appendChild(this.annotationRenderer.domElement), this.annotationRenderer.setSize(e.boundaries.width, e.boundaries.height), this.timeline.to([t.element, n.element], {
                    opacity: 0,
                    duration: Jw
                }, .2), this.timeline.to(i.element, {
                    opacity: 1,
                    duration: Jw
                }, .2), this.timeline.to(i.element, {opacity: 0, duration: Jw}, .475)
            }
            for (let e = 0; e < Ub.length; e++) {
                const t = 0 === e ? 1 : 0, n = new Zb(this.engine, t);
                this.scene.add(n), this.illustrations.push(n)
            }
            this.timeline.to(this.cameraManager, {
                trackProgress: 1,
                onUpdate: this.zoomIntoArea
            }, 0), this.timeline.to(this.fadeToWhiteOverlay, {
                alpha: 1,
                duration: .1
            }, .4), this.timeline.to(this.illustrations[1], {
                alpha: 1,
                duration: .13
            }, 0), this.timeline.to(this.illustrations[1], {
                alpha: 0,
                duration: .1
            }, .15), this.timeline.to(this.illustrations[2], {
                alpha: 1,
                duration: .05
            }, .2), this.timeline.to(this.illustrations[2], {
                alpha: 0,
                duration: .1
            }, .3), e.events.addEventListener(Hy.POINTER_MOVE, this.pointerMove)
        }

        async initialise() {
            var e;
            this.setupCameras(eT), this.gradient.initialise(), this.fadeToWhiteOverlay.initialise(), await this.planet.initialise();
            for (let t = 0; t < Ub.length; t++) {
                const {modelPath: n, materialId: i} = Ub[t];
                null === (e = this.illustrations[t]) || void 0 === e || e.initialise(n, i)
            }
            this.zoomIntoArea()
        }

        resize(e) {
            super.resize(e), this.annotationRenderer.setSize(e.width, e.height)
        }

        update(e) {
            const t = this.cameraManager.getActiveCameraTrack();
            t && (t.track.mixer.update(e), this.annotationRenderer.render(this.scene, this.camera))
        }
    }

    let nT, iT;

    async function rT(e) {
        return nT || (nT = await async function (e) {
            const t = rb(await e.loaders.loadModel(ab.CEMETERY));
            t.translate(0, -.1, 0);
            const n = e.materials[Eb.PYRAMID_FADE];
            return {mesh: new ib(t, n)}
        }(e)), nT
    }

    class sT extends nb {
        constructor() {
            super(...arguments), this.alphaContainer = new Pb
        }

        async initialise() {
            this.resources = await rT(this.engine);
            const e = this.resources.mesh.clone();
            this.alphaContainer.setAlpha(this.alphaContainer.alpha), this.alphaContainer.add(e), this.add(this.alphaContainer)
        }

        dispose(e) {
            this.remove(this.alphaContainer), Jx(this.alphaContainer), super.dispose(e)
        }
    }

    async function aT(e) {
        return iT || (iT = await async function (e) {
            const t = Gw.clone();
            t.scale(80, 1, 80), t.translate(0, -1.5, 0);
            const n = e.materials[Eb.PYRAMID_INFINITE_FLOOR];
            return {mesh: new ib(t, n)}
        }(e)), iT
    }

    class oT extends nb {
        constructor() {
            super(...arguments), this.alphaContainer = new Pb
        }

        async initialise() {
            this.resources = await aT(this.engine);
            const e = this.resources.mesh;
            this.alphaContainer.setAlpha(this.alphaContainer.alpha), this.alphaContainer.add(e), this.add(this.alphaContainer)
        }

        dispose(e) {
            this.remove(this.alphaContainer), Jx(this.alphaContainer), super.dispose(e)
        }
    }

    const lT = yb.SANDSTONE, cT = yb.GREY_900;

    class hT extends rw {
        constructor(e) {
            super(e), this.postProcessing = new Lw(this.engine, this.scene, this.camera), this.illustrations = [], this.pyramid = new Ib(this.engine), this.cemetery = new sT(this.engine), this.cemeteryOutskirts = new oT(this.engine), this.fadeToBlackOverlay = new Bb(this.engine, yb.GREY_999), this.pointerMove = e => {
                if (!this.isOnScreen) return;
                const t = e, {x: n, y: i} = t.pointer;
                this.cameraContainer.sway({y: .1 * i}, {y: .125 * -n}), this.startRenderLoop()
            };
            const t = lT.clone();
            this.scene.background = t, this.scene.fog = new Tm(t, 0, 39), this.scene.add(this.pyramid), this.scene.add(this.cemeteryOutskirts), this.scene.add(this.cemetery), this.scene.add(this.fadeToBlackOverlay), this.fadeToBlackOverlay.initialise(), this.fadeToBlackOverlay.alpha = 0, this.cemeteryOutskirts.alphaContainer.alpha = 1, this.cemetery.alphaContainer.alpha = 1, this.timeline.to(this.cameraManager, {trackProgress: 1}), this.timeline.to(this.scene.fog, {
                near: 26,
                duration: .035
            }, 0), this.timeline.to(this.cemetery.alphaContainer, {
                alpha: 0,
                duration: .1
            }, .025), this.timeline.to(this.cemeteryOutskirts.alphaContainer, {
                alpha: 0,
                duration: .1
            }, .025), this.timeline.to(t, {
                r: cT.r,
                g: cT.g,
                b: cT.b,
                duration: .08
            }, .09), this.timeline.to(t, {
                r: lT.r,
                g: lT.g,
                b: lT.b,
                duration: .01
            }, .18), this.timeline.to(this.fadeToBlackOverlay, {
                alpha: 1,
                duration: .005
            }, "-=0.008"), e.events.addEventListener(Hy.POINTER_MOVE, this.pointerMove)
        }

        async initialise() {
            const e = [{path: lb.MEROE_MOBILE, fov: 60}, {
                path: eb ? lb.MEROE_DESKTOP_RTL : lb.MEROE_DESKTOP,
                mediaQuery: window.matchMedia(xb),
                fov: 32,
                near: .24,
                far: 50
            }, {
                path: eb ? lb.MEROE_LANDSCAPE_RTL : lb.MEROE_LANDSCAPE,
                mediaQuery: window.matchMedia("(min-width: 480px) and (orientation: landscape) and (max-height: 540px)"),
                fov: eb ? 36 : 30
            }];
            this.setupCameras(e), await this.cemeteryOutskirts.initialise();
            const t = [this.cemetery.initialise(), this.pyramid.initialise()];
            await Promise.all(t);
            for (const {modelPath: e, materialId: t} of Fb) {
                const n = new Zb(this.engine);
                n.initialise(e, t), this.scene.add(n), this.illustrations.push(n)
            }
        }

        update(e) {
            const t = this.cameraManager.getActiveCameraTrack();
            if (t) {
                t.track.mixer.update(e);
                for (const e of this.illustrations) e.update(t.track.action.time)
            }
        }
    }

    async function uT(e) {
        return new Promise((t => {
            var n;
            n = async () => {
                var n;
                await (null === (n = e.initialise) || void 0 === n ? void 0 : n.call(e)), t()
            }, "requestIdleCallback" in window ? window.requestIdleCallback(n) : n()
        }))
    }

    class dT {
        constructor(e) {
            this.engine = e, this.scenes = [new tT(e), new hT(e), new Rw(e), new Tw(e)]
        }

        async initialise() {
            const e = this.scenes.map(uT);
            return Promise.all(e)
        }

        resize(e) {
            for (const t of this.scenes) t.resize(e)
        }

        dispose() {
            for (const e of this.scenes) e.dispose()
        }
    }

    var pT, fT;
    !function (e) {
        e[e.UNDEFINED = 0] = "UNDEFINED", e[e.DARK = 1] = "DARK"
    }(pT || (pT = {})), function (e) {
        e.HERO = "Hero", e.SUMMARY = "Summary", e.KUSHITE_KINGDOM = "The Kushite Kingdom", e.KINGDOM_EXPANSION = "Kingdom expansion", e.GOLDEN_AGE = "Golden age", e.THE_NUBIAN_PYRAMIDS = "The Nubian Pyramids", e.XR_PROMPT = "XR Prompt", e.THE_UNIQUE_DESIGN = "The Unique Design", e.STEEP_BY_DESIGN = "Steep by Design", e.WHO_BUILT_THEM = "Who Built Them", e.WHATS_INSIDE = "What's Inside", e.THE_OFFERING_CHAPEL = "The Offering Chapel", e.THE_OCCUPANT_IN_LIFE = "The Occupant in Life", e.AFTERLIFE = "Afterlife", e.UNDERGROUND_TOMB = "Underground Tomb", e.ANTECHAMBER = "Antechamber", e.BURIAL_CHAMBER = "Burial Chamber", e.MUMMIES = "Mummies", e.BRIDGE = "Bridge", e.KINGS_AND_QUEENS = "Kings and Queens"
    }(fT || (fT = {}));
    const mT = [{position: 1e-4, duration: 1, ease: Fy.POWER_3_IN_OUT, theme: pT.DARK, label: fT.HERO}, {
        position: 1e-4,
        duration: 1,
        ease: Fy.POWER_3_IN_OUT,
        theme: pT.DARK,
        label: fT.SUMMARY
    }, {
        position: .003,
        duration: 2,
        ease: Fy.POWER_3_IN_OUT,
        theme: pT.DARK,
        label: fT.KUSHITE_KINGDOM
    }, {
        position: .067,
        duration: 2,
        ease: Fy.POWER_3_IN_OUT,
        theme: pT.DARK,
        label: fT.KINGDOM_EXPANSION
    }, {position: .13, duration: 2, ease: Fy.POWER_1_IN_OUT, theme: pT.DARK, label: fT.GOLDEN_AGE}, {
        position: .265,
        duration: 2,
        ease: Fy.POWER_3_IN_OUT,
        label: fT.THE_NUBIAN_PYRAMIDS
    }, {position: .34, duration: 2, ease: Fy.POWER_1_IN_OUT, theme: pT.DARK, label: fT.XR_PROMPT}, {
        position: .355,
        duration: 2,
        ease: Fy.POWER_1_IN_OUT,
        label: fT.THE_UNIQUE_DESIGN
    }, {position: .38, duration: 1.5, ease: Fy.POWER_1_IN_OUT, label: fT.STEEP_BY_DESIGN}, {
        position: .41,
        duration: 2,
        ease: Fy.POWER_1_IN_OUT,
        label: fT.WHO_BUILT_THEM
    }, {position: .463, duration: 2, ease: Fy.POWER_1_IN_OUT, label: fT.WHATS_INSIDE}, {
        position: .52,
        duration: 5,
        ease: Fy.POWER_1_OUT,
        theme: pT.DARK,
        label: fT.THE_OFFERING_CHAPEL
    }, {
        position: .58,
        duration: 5,
        ease: Fy.POWER_1_IN_OUT,
        theme: pT.DARK,
        label: fT.THE_OCCUPANT_IN_LIFE
    }, {position: .63, duration: 4, ease: Fy.POWER_1_IN_OUT, theme: pT.DARK, label: fT.AFTERLIFE}, {
        position: .795,
        duration: 3,
        ease: Fy.POWER_1_OUT,
        label: fT.UNDERGROUND_TOMB
    }, {position: .84, duration: 2, ease: Fy.POWER_1_IN_OUT, theme: pT.DARK, label: fT.ANTECHAMBER}, {
        position: .89,
        duration: 2,
        ease: Fy.POWER_1_IN_OUT,
        theme: pT.DARK,
        label: fT.BURIAL_CHAMBER
    }, {position: .96, duration: 2, ease: Fy.POWER_1_IN_OUT, theme: pT.DARK, label: fT.MUMMIES}, {
        position: .99,
        duration: 2,
        ease: Fy.POWER_3_IN_OUT,
        theme: pT.DARK,
        label: fT.BRIDGE
    }, {position: .99, duration: 1, ease: Fy.POWER_2_OUT, label: fT.KINGS_AND_QUEENS}];
    var gT, vT, _T, yT, xT;
    !function (e) {
        e[e.UNIQUELY_NUBIAN = 0] = "UNIQUELY_NUBIAN", e[e.STEEP_BY_DESIGN = 1] = "STEEP_BY_DESIGN", e[e.WHO_BUILT_THEM = 2] = "WHO_BUILT_THEM", e[e.WHATS_INSIDE = 3] = "WHATS_INSIDE"
    }(gT || (gT = {})), function (e) {
        e[e.GIFTS = 0] = "GIFTS", e[e.OCCUPANT_IN_LIFE = 1] = "OCCUPANT_IN_LIFE", e[e.AFTERLIFE = 2] = "AFTERLIFE"
    }(vT || (vT = {})), function (e) {
        e[e.STAIRS = 0] = "STAIRS", e[e.ANTECHAMBER = 1] = "ANTECHAMBER", e[e.CHAMBER = 2] = "CHAMBER", e[e.MUMMIES = 3] = "MUMMIES", e[e.BRIDGE = 4] = "BRIDGE"
    }(_T || (_T = {})), function (e) {
        e[e.MEROE = 0] = "MEROE", e[e.CHAPEL = 1] = "CHAPEL", e[e.BURIAL_CHAMBER = 2] = "BURIAL_CHAMBER"
    }(yT || (yT = {})), function (e) {
        e[e.DETECTING_SURFACE = 0] = "DETECTING_SURFACE", e[e.MEROE = 1] = "MEROE", e[e.CHAPEL = 2] = "CHAPEL", e[e.BURIAL_CHAMBER_EXTERIOR = 3] = "BURIAL_CHAMBER_EXTERIOR", e[e.BURIAL_CHAMBER = 4] = "BURIAL_CHAMBER"
    }(xT || (xT = {}));
    const bT = [{
        chapter: yT.MEROE,
        scene: xT.MEROE,
        subChapter: gT.UNIQUELY_NUBIAN,
        label: fT.THE_NUBIAN_PYRAMIDS
    }, {
        chapter: yT.MEROE,
        scene: xT.MEROE,
        subChapter: gT.STEEP_BY_DESIGN,
        label: fT.THE_UNIQUE_DESIGN
    }, {
        chapter: yT.MEROE,
        scene: xT.MEROE,
        subChapter: gT.WHO_BUILT_THEM,
        label: fT.STEEP_BY_DESIGN
    }, {chapter: yT.MEROE, scene: xT.MEROE, subChapter: gT.WHATS_INSIDE, label: fT.WHATS_INSIDE}, {
        chapter: yT.CHAPEL,
        scene: xT.CHAPEL,
        subChapter: vT.GIFTS,
        label: fT.THE_OFFERING_CHAPEL
    }, {
        chapter: yT.CHAPEL,
        scene: xT.CHAPEL,
        subChapter: vT.OCCUPANT_IN_LIFE,
        label: fT.THE_OCCUPANT_IN_LIFE
    }, {
        chapter: yT.CHAPEL,
        scene: xT.CHAPEL,
        subChapter: vT.AFTERLIFE,
        label: fT.AFTERLIFE
    }, {
        chapter: yT.BURIAL_CHAMBER,
        scene: xT.BURIAL_CHAMBER_EXTERIOR,
        subChapter: _T.STAIRS,
        label: fT.UNDERGROUND_TOMB
    }, {
        chapter: yT.BURIAL_CHAMBER,
        scene: xT.BURIAL_CHAMBER,
        subChapter: _T.ANTECHAMBER,
        label: fT.ANTECHAMBER
    }, {
        chapter: yT.BURIAL_CHAMBER,
        scene: xT.BURIAL_CHAMBER,
        subChapter: _T.CHAMBER,
        label: fT.BURIAL_CHAMBER
    }, {
        chapter: yT.BURIAL_CHAMBER,
        scene: xT.BURIAL_CHAMBER,
        subChapter: _T.MUMMIES,
        label: fT.MUMMIES
    }, {chapter: yT.BURIAL_CHAMBER, scene: xT.BURIAL_CHAMBER, subChapter: _T.BRIDGE, label: fT.BRIDGE}];
    var wT, TT;
    !function (e) {
        e.POINTER_DOWN = "pointer-down", e.POINTER_MOVE = "pointer-move", e.POINTER_UP = "pointer-up"
    }(wT || (wT = {}));

    class ST extends Hc {
        constructor(e, t) {
            super(), this.engine = e, this.element = t, this.pointers = new Map, this.onPointerDown = e => {
                this.pointers.size <= 1 && (this.applyPointer(e.pointerId, e.x, e.y), this.dispatchEvent({type: wT.POINTER_DOWN}))
            }, this.onPointerMove = e => {
                this.pointers.has(e.pointerId) && (this.applyPointer(e.pointerId, e.x, e.y), this.dispatchEvent({type: wT.POINTER_MOVE}))
            }, this.onPointerUp = e => {
                this.pointers.delete(e.pointerId), this.dispatchEvent({type: wT.POINTER_UP})
            }
        }

        normalisePointer(e, t) {
            const {width: n, height: i} = this.engine.boundaries;
            return new eh(e / n * 2 - 1, -t / i * 2 + 1)
        }

        applyPointer(e, t, n) {
            const i = this.normalisePointer(t, n);
            this.pointers.set(e, i)
        }

        addEventListeners() {
            this.element.addEventListener("pointerdown", this.onPointerDown), this.element.addEventListener("pointermove", this.onPointerMove), this.element.addEventListener("pointerup", this.onPointerUp)
        }

        removeEventListeners() {
            this.element.removeEventListener("pointerdown", this.onPointerDown), this.element.removeEventListener("pointermove", this.onPointerMove), this.element.removeEventListener("pointerup", this.onPointerUp)
        }

        get mainPointer() {
            const [e] = this.pointers.values();
            return e
        }
    }

    !function (e) {
        e.UPDATE = "update", e.LOST_BEARINGS = "lost-bearings"
    }(TT || (TT = {}));

    class ET extends Hc {
        constructor() {
            super(...arguments), this.surfacePosition = new ph, this.framesWithoutSurface = 0, this._lostSurface = !1
        }

        surfaceFound(e) {
            this.framesWithoutSurface = 0, this._lostSurface && (this._lostSurface = !1), this.surfacePosition.copy(e), this.dispatchEvent({
                type: TT.UPDATE,
                surfacePosition: this.surfacePosition
            })
        }

        lostSurface() {
            this.framesWithoutSurface += 1, 10 === this.framesWithoutSurface && (this._lostSurface = !0, this.dispatchEvent({type: TT.LOST_BEARINGS}))
        }

        detectSurface(e) {
            e ? this.surfaceFound(e) : this.lostSurface()
        }

        get position() {
            return this.surfacePosition
        }
    }

    class MT {
        constructor(e, t) {
            this.engine = e, this.surfaceObserver = new ET, this.session = null, this.localReferenceSpace = null, this.viewerReferenceSpace = null, this.hitTestSource = null, this.transientHitTestSource = null, this.webXrManager = e.renderer.xr, this.pointerHitbox = new ST(this.engine, t)
        }

        async start(e) {
            var t;
            this.webXrManager.enabled = !0;
            try {
                this.session = await navigator.xr.requestSession("immersive-ar", e);
                const n = [this.session.requestReferenceSpace("local"), this.session.requestReferenceSpace("viewer")],
                    i = await Promise.all(n);
                this.localReferenceSpace = i[0], this.viewerReferenceSpace = i[1];
                const r = [this.session.requestHitTestSource({space: this.viewerReferenceSpace}), this.session.requestHitTestSourceForTransientInput({profile: "generic-touchscreen"})],
                    s = await Promise.all(r);
                this.hitTestSource = s[0], this.transientHitTestSource = s[1], this.webXrManager.setReferenceSpaceType("local"), await this.webXrManager.setSession(this.session), (null === (t = e.domOverlay) || void 0 === t ? void 0 : t.root) && (this.domOverlay = e.domOverlay.root, this.domOverlay.hidden = !1)
            } catch (e) {
                return console.warn(e), !1
            }
            return !0
        }

        async stop() {
            this.session && (this.domOverlay && (this.domOverlay.hidden = !0), this.webXrManager.isPresenting && await this.session.end(), this.session = null, this.localReferenceSpace = null, this.hitTestSource = null, this.transientHitTestSource = null)
        }

        getHitPoseFromFrame() {
            if (this.hitTestSource && this.localReferenceSpace && this.frame) {
                const [e] = this.frame.getHitTestResults(this.hitTestSource);
                return null == e ? void 0 : e.getPose(this.localReferenceSpace)
            }
            return null
        }

        detectSurface() {
            const e = this.getHitPoseFromFrame(), t = null == e ? void 0 : e.transform.position;
            if (t) {
                const e = new ph(t.x, t.y, t.z);
                this.surfaceObserver.detectSurface(e)
            }
        }

        update(e) {
            this.frame = e
        }
    }

    let AT;

    async function LT(e) {
        return AT || (AT = await async function (e) {
            const t = rb(await e.loaders.loadModel(ab.BURIAL_CHAMBER));
            t.computeVertexNormals();
            const n = e.materials[Eb.BURIAL_CHAMBER_FILLED];
            return {mesh: new ib(t, n)}
        }(e)), AT
    }

    class CT extends nb {
        async initialise() {
            this.resources = await LT(this.engine);
            const e = this.resources.mesh.clone();
            e.matrixAutoUpdate = !1, this.add(e)
        }
    }

    class RT extends Pb {
        constructor(e = 50) {
            super(), this.add(new fd(new gd(e, e, e), new Bu({
                color: yb.GREY_999,
                side: 1,
                depthWrite: !1,
                transparent: !0
            })))
        }
    }

    class PT extends mu {
        constructor() {
            super(...arguments), this.startPoint = new eh, this.delta = new eh
        }

        pointerDown(e) {
            this.startPoint.copy(e)
        }

        pointerMove(e) {
            this.rotation.x += -(e.y - this.startPoint.y), this.rotation.y += e.x - this.startPoint.x, this.rotation.x = Math.min(Math.max(this.rotation.x, -.5), .5), this.startPoint.copy(e)
        }

        reset() {
            this.rotation.set(0, 0, 0)
        }
    }

    class IT extends nw {
        constructor(e, t) {
            super(e), this.xrManager = t, this.projectionContainer = new mu, this.transformContainer = new mu, this.fadeToBlackOverlay = document.querySelector(".fade-to-black"), this.timelineIn = bi.timeline(vb), this.timelineIn.pause(), this.timelineOut = bi.timeline(vb), this.timelineOut.pause(), this.camera.near = .001, this.camera.far = 1e3, this.scene.add(this.camera), this.projectionContainer.add(this.transformContainer), this.scene.add(this.projectionContainer)
        }

        render() {
            this.engine.renderer.render(this.scene, this.camera)
        }

        setSubChapter(e) {
        }

        async fadeTransition(e, t = 1) {
            this.fadeToBlackOverlay && await bi.to(this.fadeToBlackOverlay, {alpha: e, duration: t})
        }

        async in() {
            this.timelineOut.totalDuration() && (this.timelineOut.progress(0), this.timelineOut.pause()), this.timelineIn.totalDuration() && (this.timelineIn.restart(), this.timelineIn.play()), await this.fadeTransition(0)
        }

        async out() {
            this.timelineOut.totalDuration() && (this.timelineOut.restart(), this.timelineOut.play()), await this.fadeTransition(1)
        }
    }

    const OT = [[-.268, 1.55, -2.95], [-.268, 1.55, -2.95], [.164, 1.55, -.785], [.164, 1.55, -.785], [.164, 1.55, -1]];

    class DT extends IT {
        constructor(e, t) {
            super(e, t), this.userFacingContainer = new mu, this.dragControlsContainer = new PT, this.cameraRotationContainer = new mu, this.subject = new CT(this.engine), this.illustrations = [], this.onPointerStart = () => {
                const {mainPointer: e} = this.xrManager.pointerHitbox;
                this.dragControlsContainer.pointerDown(e)
            }, this.onPointerMove = () => {
                const {mainPointer: e} = this.xrManager.pointerHitbox;
                this.dragControlsContainer.pointerMove(e)
            }, this.userFacingContainer.add(this.subject), this.dragControlsContainer.add(this.userFacingContainer), this.cameraRotationContainer.add(this.dragControlsContainer), this.camera.add(this.cameraRotationContainer);
            const n = new RT;
            this.camera.add(n), t.pointerHitbox.addEventListener(wT.POINTER_DOWN, this.onPointerStart), t.pointerHitbox.addEventListener(wT.POINTER_MOVE, this.onPointerMove)
        }

        async initialise() {
            await this.subject.initialise();
            const [e, t, n] = OT[0];
            this.subject.position.set(e, t, n), this.subject.updateMatrix();
            for (const {modelPath: e, materialId: t} of Vb) {
                const n = new Zb(this.engine);
                n.initialise(e, t), this.subject.add(n), this.illustrations.push(n)
            }
        }

        update(e, t) {
            this.cameraRotationContainer.setRotationFromMatrix(this.camera.matrixWorldInverse)
        }

        setSubChapter(e) {
            const [t, n, i] = OT[e];
            bi.to(this.subject.position, {
                x: t, y: n, z: i, duration: 5, ease: "power1.inOut", onUpdate: () => {
                    this.subject.updateMatrix()
                }
            }), $b(this.illustrations, e - 1)
        }

        reset() {
            this.dragControlsContainer.rotation.set(0, .12 * -Math.PI, 0)
        }
    }

    class NT extends IT {
        constructor(e, t) {
            super(e, t), this.burialChamber = new Cb(this.engine), this.pyramid = new Ib(this.engine), this.transformContainer.add(this.pyramid), this.transformContainer.add(this.burialChamber), this.timelineOut.to([this.pyramid.scale, this.burialChamber.scale], {
                x: 1,
                y: 1,
                z: 1,
                duration: 1,
                ease: "power3.in",
                onUpdate: () => {
                    this.pyramid.updateMatrix(), this.burialChamber.updateMatrix()
                }
            })
        }

        async initialise() {
            const e = [this.pyramid.initialise(), this.burialChamber.initialise(!1)];
            await Promise.all(e), this.pyramid.scale.setScalar(.1), this.burialChamber.scale.setScalar(.1), this.pyramid.updateMatrix(), this.burialChamber.updateMatrix()
        }
    }

    const BT = [-.22, -.29, -2.1];

    class kT extends IT {
        constructor(e, t) {
            super(e, t), this.userFacingContainer = new mu, this.dragControlsContainer = new PT, this.cameraRotationContainer = new mu, this.subject = new Mw(this.engine), this.illustrations = [], this.onPointerStart = () => {
                const {mainPointer: e} = this.xrManager.pointerHitbox;
                this.dragControlsContainer.pointerDown(e)
            }, this.onPointerMove = () => {
                const {mainPointer: e} = this.xrManager.pointerHitbox;
                this.dragControlsContainer.pointerMove(e)
            }, this.userFacingContainer.add(this.subject), this.dragControlsContainer.add(this.userFacingContainer), this.cameraRotationContainer.add(this.dragControlsContainer), this.camera.add(this.cameraRotationContainer), t.pointerHitbox.addEventListener(wT.POINTER_DOWN, this.onPointerStart), t.pointerHitbox.addEventListener(wT.POINTER_MOVE, this.onPointerMove)
        }

        async initialise() {
            await this.subject.initialise();
            const [e, t, n] = BT;
            this.subject.position.set(e, t, n), this.subject.updateMatrix();
            for (let e = 0; e < zb.length; e++) {
                const {modelPath: t, materialId: n} = zb[e], i = 0 === e ? 1 : 0, r = new Zb(this.engine, i);
                r.initialise(t, n), this.subject.add(r), this.illustrations.push(r)
            }
        }

        update(e, t) {
            this.cameraRotationContainer.setRotationFromMatrix(this.camera.matrixWorldInverse)
        }

        setSubChapter(e) {
            $b(this.illustrations, e)
        }

        reset() {
            this.dragControlsContainer.reset()
        }
    }

    let UT;

    async function FT(e) {
        return UT || (UT = await async function (e) {
            const t = await e.loaders.loadTextureFromManifest(bb.RETICLE_ALPHA),
                n = new Bu({alphaMap: t, blending: 2, depthWrite: !1}), i = new fd(Gw, n);
            return i.scale.setScalar(.5), i.updateMatrix(), {mesh: i}
        }(e)), UT
    }

    class HT extends nb {
        constructor(e) {
            super(e), this.matrixAutoUpdate = !0
        }

        async initialise() {
            this.resources = await FT(this.engine);
            const e = this.resources.mesh.clone();
            e.matrixAutoUpdate = !1, this.add(e)
        }
    }

    class zT extends IT {
        constructor(e, t) {
            super(e, t), this.reticle = new HT(this.engine), this.transformContainer.add(this.reticle)
        }

        async initialise() {
            await this.reticle.initialise()
        }
    }

    class GT {
        constructor() {
            this.scaleCurrent = 1, this.scaleModifier = 0, this.scaleMinimum = .2, this.scaleMaximum = 5
        }

        down(e) {
            this.scaleModifier = e / this.scaleCurrent
        }

        move(e) {
            const t = e / this.scaleModifier;
            let n = Math.max(this.scaleMinimum, t);
            n = Math.min(n, this.scaleMaximum), this.scaleCurrent = n
        }
    }

    const VT = new ph;

    class WT {
        constructor() {
            this.rotationContainer = new mu, this.startPoint = new mu, this.startPointWorldPosition = new ph, this.storedAngle = 0, this.currentAngle = 0, this.rotationContainer.add(this.startPoint)
        }

        calculateAngle(e, t, n = VT) {
            this.startPoint.position.z = e, this.startPoint.getWorldPosition(this.startPointWorldPosition), t.sub(n);
            let i = this.startPointWorldPosition.angleTo(t);
            return t.x < this.startPointWorldPosition.x && (i = Math.PI + (Math.PI - i)), i
        }

        down(e, t, n = VT) {
            this.storedAngle = this.calculateAngle(e, t, n)
        }

        move(e, t, n = VT) {
            const i = this.calculateAngle(e, t, n), r = i - this.storedAngle;
            this.currentAngle += r;
            if (Math.abs(r) > Math.PI) {
                const e = this.storedAngle < Math.PI ? -1 : 1;
                this.currentAngle += 2 * Math.PI * e
            }
            return this.storedAngle = i, this.currentAngle
        }

        reset(e = 0) {
            this.storedAngle = e, this.currentAngle = e
        }
    }

    const jT = new class {
        constructor(e, t, n = 0, i = 1 / 0) {
            this.ray = new Vh(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new tu, this.params = {
                Mesh: {},
                Line: {threshold: 1},
                LOD: {},
                Points: {threshold: 1},
                Sprite: {}
            }
        }

        set(e, t) {
            this.ray.set(e, t)
        }

        setFromCamera(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
        }

        intersectObject(e, t = !0, n = []) {
            return O_(e, this, n, t), n.sort(I_), n
        }

        intersectObjects(e, t = !0, n = []) {
            for (let i = 0, r = e.length; i < r; i++) O_(e[i], this, n, t);
            return n.sort(I_), n
        }
    };

    class $T {
        constructor(e, t, n, i) {
            this.camera = e, this.projectionContainer = t, this.floorMesh = n, this.positionMesh = i, this.rotate3d = new WT, this.pinch = new GT, this.pointerCurrent = new eh, this.dummyObject = new mu, this.isPointerDown = !1, this.isMultiplePointersDown = !1, this.isRepositioning = !1, this.isRotating = !1
        }

        intersect(e) {
            return function (e, t, n) {
                jT.setFromCamera(n, t);
                const [i] = jT.intersectObject(e);
                return i
            }(e, this.camera, this.pointerCurrent)
        }

        multiPointer(e) {
            const [t, n] = e, i = t.distanceTo(n);
            this.isMultiplePointersDown ? (this.pinch.move(i), this.dummyObject.scale.setScalar(this.pinch.scaleCurrent)) : (this.pinch.down(i), this.isMultiplePointersDown = !0), this.isRepositioning = !1, this.isRotating = !1
        }

        down(e) {
            if (e.length) if (this.pointerCurrent.copy(e[0]), this.isPointerDown = !0, 2 === e.length) this.multiPointer(e); else {
                if (this.intersect(this.positionMesh)) this.isRepositioning = !0; else {
                    const e = this.intersect(this.floorMesh);
                    if (e) {
                        const {distance: t, point: n} = e;
                        this.isRotating = !0, this.rotate3d.down(t, n, this.projectionContainer.position)
                    }
                }
            }
        }

        move(e) {
            if (e.length) if (this.pointerCurrent.copy(e[0]), e.length > 1) this.multiPointer(e); else if (this.isRotating || this.isRepositioning) {
                const e = this.intersect(this.floorMesh);
                if (e) {
                    const {distance: t, point: n} = e;
                    this.isRepositioning && this.dummyObject.position.copy(n), this.isRotating && (this.dummyObject.rotation.y = this.rotate3d.move(t, n, this.projectionContainer.position))
                }
            }
        }

        up() {
            this.isPointerDown = !1, this.isMultiplePointersDown = !1, this.isRotating = !1, this.isRepositioning = !1
        }

        reset() {
            this.rotate3d.reset(), this.dummyObject.rotation.y = 0, this.pointerCurrent.set(0, 0)
        }
    }

    const XT = .5;

    class qT extends IT {
        constructor(e, t) {
            super(e, t), this.onSelectStart = () => {
                const [...e] = this.xrManager.pointerHitbox.pointers.values();
                this.gestures.down(e)
            }, this.onSelectMove = () => {
                const [...e] = this.xrManager.pointerHitbox.pointers.values();
                this.gestures.move(e)
            }, this.onSelectEnd = () => {
                this.gestures.up();
                const e = Math.min(Math.max(.5, this.scale), 1);
                this.projectionContainer.scale.setScalar(e), this.projectionContainer.rotation.copy(this.rotation)
            };
            const n = new Bu({side: 2}), i = Gw.clone();
            i.scale(10, 10, 10);
            const r = new fd(i, n), s = new gd(XT, XT, XT);
            s.translate(0, XT, 0);
            const a = new fd(s, n);
            this.projectionContainer.add(r), this.projectionContainer.add(a), this.gestures = new $T(this.camera, this.projectionContainer, r, a)
        }

        initialise() {
            this.xrManager.pointerHitbox.addEventListener(wT.POINTER_DOWN, this.onSelectStart), this.xrManager.pointerHitbox.addEventListener(wT.POINTER_MOVE, this.onSelectMove), this.xrManager.pointerHitbox.addEventListener(wT.POINTER_UP, this.onSelectEnd)
        }

        reset() {
            this.gestures.reset(), this.projectionContainer.scale.setScalar(1), this.projectionContainer.rotation.set(0, 0, 0)
        }

        get scale() {
            return this.gestures.pinch.scaleCurrent
        }

        get rotation() {
            return this.gestures.dummyObject.rotation
        }

        get position() {
            return this.gestures.dummyObject.position
        }
    }

    class YT extends IT {
        constructor(e, t) {
            super(e, t), this.pyramid = new Ib(this.engine), this.illustrations = [], this.transformContainer.add(this.pyramid), this.pyramid.scale.setScalar(.1), this.pyramid.updateMatrix(), this.timelineOut.to(this.pyramid.scale, {
                x: 1,
                y: 1,
                z: 1,
                duration: 1,
                ease: "power3.in",
                onUpdate: () => {
                    this.pyramid.updateMatrix()
                }
            })
        }

        async initialise() {
            await this.pyramid.initialise();
            for (let e = 0; e < Wb.length; e++) {
                const {modelPath: t, materialId: n} = Wb[e], i = 0 === e ? 1 : 0, r = new Zb(this.engine, i);
                r.initialise(t, n), this.pyramid.add(r), this.illustrations.push(r)
            }
        }

        setSubChapter(e) {
            $b(this.illustrations, e)
        }
    }

    var KT;
    !function (e) {
        e.SURFACE_FOUND_ONCE = "surface-found", e.SUBJECT_PLACED = "subject-placed"
    }(KT || (KT = {}));

    class JT extends Hc {
        constructor(e) {
            super(), this.engine = e, this.cameraPosition = new ph, this._sceneToRender = null, this.isSubjectPlaced = !1, this.isSurfaceFoundOnce = !1, this.isThroughTutorial = !1, this.onSurfaceUpdate = e => {
                const {surfacePosition: t} = e;
                this.gestureProcessor.projectionContainer.position.copy(t);
                for (const e of this.scenes) e.projectionContainer.position.copy(t);
                this.isSurfaceFoundOnce || (this.dispatchEvent({type: KT.SURFACE_FOUND_ONCE}), this.scenes[xT.DETECTING_SURFACE].reticle.visible = !0, this.isSurfaceFoundOnce = !0)
            }, this.onSelect = () => {
                const e = this.sceneToRender === this.scenes[xT.DETECTING_SURFACE];
                !this.isSubjectPlaced && this.isSurfaceFoundOnce && this.isThroughTutorial && e && (this.sceneToRender = this.scenes[xT.MEROE], this.sceneToRender.in(), this.sceneToRender.setSubChapter(gT.UNIQUELY_NUBIAN), this.isSubjectPlaced = !0, this.sceneToRender.render(), this.lookAtCamera(), this.faceCameraMappedScenesToUser(), this.dispatchEvent({type: KT.SUBJECT_PLACED}))
            };
            const t = document.getElementById("pointer-hitbox");
            this.manager = new MT(e, t), this.gestureProcessor = new qT(this.engine, this.manager), this.scenes = [new zT(e, this.manager), new YT(e, this.manager), new kT(e, this.manager), new NT(e, this.manager), new DT(e, this.manager)], this.scenes[xT.DETECTING_SURFACE].reticle.visible = !1, this.sceneToRender = this.scenes[xT.DETECTING_SURFACE]
        }

        addEventListeners() {
            this.manager.pointerHitbox.addEventListeners(), this.manager.pointerHitbox.addEventListener(wT.POINTER_DOWN, this.onSelect), this.manager.surfaceObserver.addEventListener(TT.UPDATE, this.onSurfaceUpdate)
        }

        removeEventListeners() {
            this.manager.pointerHitbox.removeEventListener(wT.POINTER_DOWN, this.onSelect), this.manager.pointerHitbox.removeEventListeners(), this.manager.surfaceObserver.removeEventListener(TT.UPDATE, this.onSurfaceUpdate)
        }

        applyGestures() {
            const {rotation: e, scale: t} = this.gestureProcessor;
            for (const n of this.scenes) n.projectionContainer.rotation.copy(e), n.projectionContainer.scale.setScalar(t)
        }

        onStarted() {
            this.addEventListeners(), Br(Or.INFORMATION_POINT, {action: Dr.OPEN, label: "XR"})
        }

        faceCameraMappedScenesToUser() {
            if (!this._sceneToRender) return;
            const {matrixWorld: e} = this._sceneToRender.camera;
            this.scenes[xT.CHAPEL].userFacingContainer.setRotationFromMatrix(e), this.scenes[xT.BURIAL_CHAMBER].userFacingContainer.rotation.copy(this.scenes[xT.CHAPEL].userFacingContainer.rotation)
        }

        lookAtCamera() {
            const e = new mu;
            e.lookAt(this.cameraPosition);
            const {y: t} = e.rotation;
            for (const e of this.scenes) e.projectionContainer.rotation.y = t, this.gestureProcessor.gestures.rotate3d.reset(t)
        }

        async initialise() {
            this.gestureProcessor.initialise(), await Promise.all(this.scenes.map((e => e.initialise())))
        }

        async start(e) {
            this.active || (await this.manager.start({..._b, domOverlay: {root: e}}), this.active && this.onStarted())
        }

        async end() {
            this.removeEventListeners(), this.sceneToRender = this.scenes[xT.DETECTING_SURFACE], await this.manager.stop(), this.isSubjectPlaced = !1, this.isSurfaceFoundOnce = !1, this.gestureProcessor.reset(), this.scenes[xT.DETECTING_SURFACE].reticle.visible = !1, Br(Or.INFORMATION_POINT, {
                action: Dr.CLOSE,
                label: "XR"
            })
        }

        resize(e) {
            for (const t of this.scenes) t.resize(e)
        }

        update(e, t) {
            var n, i;
            if (this.active && this.isThroughTutorial) {
                if (this.manager.localReferenceSpace) {
                    const e = null == t ? void 0 : t.getViewerPose(this.manager.localReferenceSpace);
                    if (e) {
                        const {x: t, y: n, z: i} = e.transform.position;
                        this.cameraPosition.set(t, n, i)
                    }
                }
                this.manager.update(t), this.isSubjectPlaced || this.manager.detectSurface(), this.gestureProcessor.gestures.isPointerDown && this.applyGestures(), null === (i = null === (n = this._sceneToRender) || void 0 === n ? void 0 : n.update) || void 0 === i || i.call(n, e, t)
            }
        }

        render() {
            var e;
            this.gestureProcessor.render(), null === (e = this._sceneToRender) || void 0 === e || e.render()
        }

        async dispose() {
            await this.end(), this.gestureProcessor.dispose();
            for (const e of this.scenes) e.dispose()
        }

        set sceneToRender(e) {
            this._sceneToRender = e
        }

        get sceneToRender() {
            return this._sceneToRender
        }

        async setSlide(e) {
            const t = this.sceneToRender, n = this.scenes[e.scene], i = t === n;
            n.setSubChapter(e.subChapter), i || (await (null == t ? void 0 : t.out()), this.gestureProcessor.reset(), this.scenes[xT.CHAPEL].reset(), this.scenes[xT.BURIAL_CHAMBER].reset(), this.faceCameraMappedScenesToUser(), this.applyGestures(), this.sceneToRender = n, null == n || n.in())
        }

        get active() {
            return this.engine.renderer.xr.isPresenting
        }
    }

    class ZT {
        constructor(e) {
            this.engine = e, this.resize = e => {
                var t, n;
                (null === (t = this.xrWorld) || void 0 === t ? void 0 : t.active) ? this.xrWorld.resize(e.boundaries) : null === (n = this.mainWorld) || void 0 === n || n.resize(e.boundaries)
            }, this.xrRenderLoop = (e, t) => {
                var n;
                (null === (n = this.xrWorld) || void 0 === n ? void 0 : n.active) && (this.xrWorld.update(e, t), this.xrWorld.render())
            }, this.engine.events.addEventListener(Hy.RESIZE, this.resize)
        }

        startMain() {
            return this.mainWorld || (this.mainWorld = new dT(this.engine)), this.mainWorld
        }

        async requestXr(e) {
            this.xrWorld || (this.xrWorld = new JT(this.engine), this.xrWorld.initialise()), await this.xrWorld.start(e), this.engine.renderer.setAnimationLoop(this.xrRenderLoop)
        }

        async stopXr() {
            var e;
            await (null === (e = this.xrWorld) || void 0 === e ? void 0 : e.end()), this.engine.renderer.setAnimationLoop(null)
        }

        dispose() {
            var e, t;
            null === (e = this.mainWorld) || void 0 === e || e.dispose(), null === (t = this.xrWorld) || void 0 === t || t.dispose()
        }
    }

    function QT() {
        return /iPhone|iPad|iPod/i.test(navigator.userAgent) || -1 !== navigator.userAgent.toLowerCase().indexOf("macintosh") && Boolean(navigator.maxTouchPoints) && navigator.maxTouchPoints > 2 || /Android/i.test(navigator.userAgent)
    }

    function eS() {
        return Date.now()
    }

    function tS(e, t) {
        return t - e
    }

    function nS(e, t) {
        return sS.debounce(e, t, !0)
    }

    async function iS(e) {
        return new Promise((t => setTimeout(t, e)))
    }

    function rS(e) {
        let t = null, n = null;
        return (...i) => {
            const r = JSON.stringify(i);
            if (r !== n) return n = r, t = e(...i)
        }
    }

    const sS = {
        debounce: function (e, t, n) {
            let i;
            return function (...r) {
                const s = this, a = () => {
                    i = void 0, e.apply(s, r)
                }, o = () => {
                    i = void 0
                };
                n || (clearTimeout(i), i = +setTimeout(a, t)), n && void 0 === i && (e.apply(s, r), i = +setTimeout(o, t))
            }
        }, throttle: nS, wait: iS, waitUntil: function (e, t = 0, n = 100) {
            const i = eS();
            let r, s;
            const a = new Promise(((e, t) => {
                r = e, s = t
            })), o = () => {
                const a = tS(i, eS());
                e() ? r() : t && a > t ? s("Wait until timed out") : setTimeout(o, n)
            };
            return o(), a
        }, repeatUntil: function (e, t, n = 0, i = 100) {
            const r = eS();
            let s, a;
            const o = new Promise(((e, t) => {
                s = e, a = t
            })), l = () => {
                const o = tS(r, eS());
                e() ? s() : n && o > n ? a("Wait until timed out") : (t(), setTimeout(l, i))
            };
            return l(), o
        }, memoizeSimple: function (e) {
            let t = null, n = null;
            return (...i) => {
                const r = JSON.stringify(i);
                return r === n ? t : (n = r, t = e(...i))
            }
        }, memoize: function (e) {
            const t = {};
            return (...n) => {
                const i = JSON.stringify(n);
                if (t[i]) return t[i];
                const r = e(...n);
                return t[i] = r, r
            }
        }, runOnlyOnce: function (e) {
            return rS((() => {
                e()
            }))
        }, runOnceOnChange: rS, setDefault: function (e, t) {
            return Object.is(e, void 0) ? t : e
        }, times: function (e, t) {
            [...Array(e)].forEach(((e, n) => {
                t(n)
            }))
        }
    };

    class aS {
        constructor(e) {
            this.onResize = () => {
                this.engine.resize(window.innerWidth, window.innerHeight, window.devicePixelRatio)
            }, this.resizeDebounced = Py(this.onResize, 500), this.onPointerDown = e => {
                this.engine.pointerDown(e.x, e.y)
            }, this.onPointerMove = e => {
                Ly() || this.engine.pointerMove(e.x, e.y)
            }, this.pointerMoveThrottled = nS(this.onPointerMove, 48), this.onPointerUp = () => {
                this.engine.pointerUp()
            }, this.onVisibilityChange = () => {
                const e = "visible" === document.visibilityState;
                this.engine.visibilityChange(e)
            }, this.onLoad = () => {
                this.addEventListeners(), this.onResize()
            };
            const t = new Iy(window.innerWidth, window.innerHeight, window.devicePixelRatio);
            this.engine = new Qx(document.body, e, t), this.universe = new ZT(this.engine)
        }

        async setup() {
            await this.engine.setup(), await async function (e) {
                const [t, n, i, r] = await e.loaders.loadManifest(wb);
                Tb.DIFFUSE.map = t, Tb.ALPHA.alphaMap = n, Tb.DIFFUSE_AND_ALPHA.map = t, Tb.DIFFUSE_AND_ALPHA.alphaMap = n, Sb.DIFFUSE.map = i, Sb.ALPHA.alphaMap = i, r.wrapS = tc, r.wrapT = tc, r.repeat = new eh(3, 3)
            }(this.engine), this.engine.materials = await async function (e) {
                const t = Object.keys(Eb).length / 2, n = new Array(t);
                n[Eb.GLOBE] = Tb.DIFFUSE, n[Eb.GLOBE_CLOUDS] = Tb.DIFFUSE_AND_ALPHA.clone(), n[Eb.GLOBE_CLOUDS].color = yb.GREY_500, n[Eb.GLOBE_CLOUDS].blending = 2;
                const i = new Bu({
                    alphaMap: Tb.DIFFUSE.map,
                    blending: 2,
                    depthWrite: !1,
                    depthTest: !1,
                    color: yb.GREY_500
                });
                n[Eb.GLOBE_ILLUSTRATION_SUDAN_EGYPT] = i.clone(), n[Eb.GLOBE_ILLUSTRATION_KINGDOM] = i.clone(), n[Eb.GLOBE_ILLUSTRATION_MEROE] = i.clone(), n[Eb.PYRAMID] = Tb.DIFFUSE_AND_ALPHA.clone(), n[Eb.PYRAMID_FADE] = Tb.DIFFUSE_AND_ALPHA.clone(), n[Eb.PYRAMID_FADE].transparent = !0, n[Eb.PYRAMID_GROUND] = Tb.DIFFUSE_AND_ALPHA.clone();
                const r = Sb.ALPHA.clone();
                r.side = 2, r.alphaTest = .1;
                const s = r.clone();
                s.color = yb.SUNSET_ORANGE;
                const a = r.clone();
                a.transparent = !0, a.depthTest = !1, a.blending = 2, n[Eb.PYRAMID_ILLUSTRATION_ANGLE] = s.clone(), n[Eb.PYRAMID_ILLUSTRATION_SHADOUF] = s.clone(), n[Eb.PYRAMID_ILLUSTRATION_QUEEN] = r.clone(), n[Eb.PYRAMID_ILLUSTRATION_BRICKS] = a.clone(), n[Eb.CHAPEL] = Sb.DIFFUSE, n[Eb.CHAPEL_ILLUSTRATION_GIFTS] = r.clone(), n[Eb.CHAPEL_ILLUSTRATION_WALL_NORTH] = r.clone(), n[Eb.CHAPEL_ILLUSTRATION_WALL_SOUTH] = r.clone(), n[Eb.BURIAL_CHAMBER] = new gb({
                    color: yb.SUNSET_ORANGE,
                    wireframe: !0,
                    transparent: !0
                }), n[Eb.BURIAL_CHAMBER].xray = 1, n[Eb.BURIAL_CHAMBER_ILLUSTRATION_GODS] = s.clone(), n[Eb.BURIAL_CHAMBER_ILLUSTRATION_BABIRD] = s.clone(), n[Eb.BURIAL_CHAMBER_ILLUSTRATION_VESSELS] = s.clone();
                const o = r.clone();
                o.color = yb.YELLOW, o.transparent = !0, o.blending = 2, n[Eb.BURIAL_CHAMBER_ILLUSTRATION_GODS_XR] = o.clone(), n[Eb.BURIAL_CHAMBER_ILLUSTRATION_BABIRD_XR] = o.clone(), n[Eb.BURIAL_CHAMBER_ILLUSTRATION_VESSELS_XR] = o.clone();
                const l = await e.loaders.loadTextureFromManifest(bb.GLOBE_GLOW);
                n[Eb.GLOBE_GLOW] = new Bu({blending: 2, depthTest: !1, depthWrite: !1, map: l});
                const c = await e.loaders.loadTextureFromManifest(bb.CEMETERY_OUTSKIRTS);
                n[Eb.PYRAMID_INFINITE_FLOOR] = new Bu({map: c, transparent: !0});
                const h = await e.loaders.loadTextureFromManifest(bb.MATCAP);
                return n[Eb.BURIAL_CHAMBER_FILLED] = new Ev({matcap: h}), n
            }(this.engine);
            const e = this.engine.loaders.textureCache;
            for (const [t, n] of e) this.engine.renderer.initTexture(n);
            this.engine.renderer.xr.enabled = await ny(), this.onLoad()
        }

        addEventListeners() {
            window.addEventListener("resize", this.resizeDebounced), window.addEventListener("pointerdown", this.onPointerDown), window.addEventListener("pointermove", this.pointerMoveThrottled), window.addEventListener("pointerup", this.onPointerUp), window.addEventListener("visibilitychange", this.onVisibilityChange), window.addEventListener("blur", this.onVisibilityChange), window.addEventListener("pageshow", this.onVisibilityChange)
        }

        removeEventListeners() {
            window.removeEventListener("resize", this.resizeDebounced), window.removeEventListener("pointerdown", this.onPointerDown), window.removeEventListener("pointermove", this.pointerMoveThrottled), window.removeEventListener("pointerup", this.onPointerUp), window.removeEventListener("visibilitychange", this.onVisibilityChange), window.removeEventListener("blur", this.onVisibilityChange), window.removeEventListener("pageshow", this.onVisibilityChange)
        }

        dispose() {
            this.removeEventListeners()
        }
    }

    var oS, lS;
    !function (e) {
        e.SPLASH = "xr-tutorial-splash", e.SURFACE = "xr-tutorial-detect-surface", e.PLACEMENT = "xr-tutorial-tap-to-place", e.SWIPE = "xr-tutorial-gesture-swipe", e.SCALE = "xr-tutorial-gesture-scale", e.LOOK_AROUND = "xr-tutorial-look-around", e.EXPLORE_TOOLTIP = "xr-tooltip"
    }(oS || (oS = {})), function (e) {
        e.BASICS_DONE = "basics-done", e.GESTURES_DONE = "gestures-done"
    }(lS || (lS = {}));
    const cS = "active";

    class hS extends Hc {
        constructor() {
            super(), this._isMainTutorialFinished = !1, this._isGestureTutorialStarted = !1, this.gestureTimeline = bi.timeline(vb), this.lookAroundTimeline = bi.timeline(vb), this.hasSeenTooltip = !1, this.dom = {
                splash: document.getElementById(oS.SPLASH),
                surface: document.getElementById(oS.SURFACE),
                placement: document.getElementById(oS.PLACEMENT),
                swipe: document.getElementById(oS.SWIPE),
                scale: document.getElementById(oS.SCALE),
                lookAround: document.getElementById(oS.LOOK_AROUND),
                exploreTooltip: document.getElementById(oS.EXPLORE_TOOLTIP)
            }, this.onMainTutorialFinished = () => {
                this._isMainTutorialFinished = !0, this.dispatchEvent({type: lS.BASICS_DONE})
            }, this.arBasicsTimeline = bi.timeline({...vb, onComplete: this.onMainTutorialFinished});
            this.arBasicsTimeline.to(this.dom.splash, {
                open: !0,
                duration: 1
            }), this.arBasicsTimeline.to(this.dom.splash, {
                open: !1,
                duration: 1
            }), this.arBasicsTimeline.to(this.dom.surface, {
                open: !0,
                duration: 1
            }), this.arBasicsTimeline.pause(), this.gestureTimeline.to(this.dom.swipe, {
                open: !0,
                duration: 1,
                delay: 1
            }), this.gestureTimeline.to(this.dom.swipe, {
                open: !1,
                duration: 1
            }), this.gestureTimeline.to(this.dom.scale, {
                open: !0,
                duration: 1
            }), this.gestureTimeline.to(this.dom.scale, {
                open: !1,
                duration: 1
            }), this.gestureTimeline.pause(), this.lookAroundTimeline.to(this.dom.lookAround, {
                open: !0,
                duration: 1
            }), this.lookAroundTimeline.to(this.dom.lookAround, {
                open: !1,
                duration: 1
            }), this.lookAroundTimeline.pause()
        }

        hideOverlays() {
            this.dom.splash.open = !1, this.dom.surface.open = !1, this.dom.swipe.open = !1, this.dom.scale.open = !1
        }

        hide(e) {
            e.open && (e.open = !1)
        }

        show(e) {
            e.open || (e.open = !0)
        }

        startMainTutorial() {
            this.arBasicsTimeline.play()
        }

        async startGestureTutorial() {
            this._isGestureTutorialStarted = !0, await this.gestureTimeline.play()
        }

        startLookAroundPrompt() {
            this.gestureTimeline.progress(1), this.gestureTimeline.pause(), this.lookAroundTimeline.restart(), this.lookAroundTimeline.play()
        }

        showTooltip() {
            this.hasSeenTooltip || (this.hasSeenTooltip = !0, this.dom.exploreTooltip.classList.add(cS))
        }

        hideTooltip() {
            this.dom.exploreTooltip.classList.remove(cS)
        }

        stop() {
            this.hideOverlays(), this.arBasicsTimeline.pause(), this.arBasicsTimeline.progress(0), this.gestureTimeline.pause(), this.gestureTimeline.progress(0)
        }

        dispose() {
            this.arBasicsTimeline.kill(), this.gestureTimeline.kill(), this.hideOverlays()
        }

        get isMainTutorialFinished() {
            return this._isMainTutorialFinished
        }

        get isGestureTutorialStarted() {
            return this._isGestureTutorialStarted
        }
    }

    var uS;
    !function (e) {
        e.TOGGLE = "data-audio-toggle"
    }(uS || (uS = {}));

    class dS {
        constructor(e, t) {
            this.pkAudio = e, this.captions = t, this.onPlayStateChange = () => {
                const e = this.pkAudio.isPaused;
                for (let t = 0; t < this.playButtons.length; t++) this.playButtons[t].classList.toggle("playing", !e)
            }, this.onPlayPauseClick = () => {
                this.pkAudio.isPaused ? this.pkAudio.play() : this.pkAudio.pause()
            }, this.onVttUpdate = e => {
                var t;
                this.pkAudio.isPaused || null === (t = this.captions) || void 0 === t || t.setText(e.detail.activeCue)
            }, this.onStop = () => {
                var e;
                null === (e = this.captions) || void 0 === e || e.clear()
            };
            const n = `[${uS.TOGGLE}="${e.id}"]`;
            this.playButtons = document.querySelectorAll(n), this.addEventListeners()
        }

        async play() {
            await this.pkAudio.play()
        }

        async stop() {
            this.pkAudio.started && await this.pkAudio.stop()
        }

        dispose() {
            this.removeEventListeners()
        }

        addEventListeners() {
            var e;
            null === (e = this.captions) || void 0 === e || e.addEventListeners(), this.pkAudio.addEventListener(Mr.PLAY_STATE_CHANGE, this.onPlayStateChange), this.pkAudio.addEventListener(Mr.VTT_UPDATE, this.onVttUpdate), this.pkAudio.addEventListener(Mr.STOPPED, this.onStop);
            for (let e = 0; e < this.playButtons.length; e++) this.playButtons[e].addEventListener("click", this.onPlayPauseClick)
        }

        removeEventListeners() {
            var e;
            null === (e = this.captions) || void 0 === e || e.removeEventListeners();
            for (let e = 0; e < this.playButtons.length; e++) this.playButtons[e].removeEventListener("click", this.onPlayPauseClick);
            this.pkAudio.removeEventListener(Mr.PLAY_STATE_CHANGE, this.onPlayStateChange), this.pkAudio.removeEventListener(Mr.VTT_UPDATE, this.onVttUpdate), this.pkAudio.removeEventListener(Mr.STOPPED, this.onStop);
            for (let e = 0; e < this.playButtons.length; e++) this.playButtons[e].removeEventListener("click", this.onPlayPauseClick)
        }
    }

    var pS;
    !function (e) {
        e.BUTTON = ".audio-player__cc-button", e.CAPTIONS = ".xr__captions"
    }(pS || (pS = {}));
    const fS = "xr__captions--visible";

    class mS {
        constructor(e, t = !0) {
            this.element = e, this.visible = t, this.buttons = document.querySelectorAll(pS.BUTTON), this.onToggle = () => {
                this.visible = !this.visible, this.setVisibility(this.visible)
            }, this.visible = t, this.setVisibility(t, !1)
        }

        addEventListeners() {
            for (let e = 0; e < this.buttons.length; e++) this.buttons[e].addEventListener("click", this.onToggle)
        }

        removeEventListeners() {
            for (let e = 0; e < this.buttons.length; e++) this.buttons[e].removeEventListener("click", this.onToggle)
        }

        setVisibility(e, t = !0) {
            this.element.classList.toggle(fS, e);
            for (let t = 0; t < this.buttons.length; t++) this.buttons[t].classList.toggle(fS, e);
            if (!t) return;
            const n = e ? Dr.ENABLE : Dr.DISABLE;
            Br(Or.XR, {action: n, label: "Captions"})
        }

        setText(e) {
            this.element.textContent = e
        }

        clear() {
            this.element.textContent = ""
        }
    }

    var gS;
    !function (e) {
        e.ELEMENT = "data-xr-heading"
    }(gS || (gS = {}));

    class vS {
        constructor(e) {
            this.elements = e
        }

        set chapter(e) {
            for (let t = 0; t < this.elements.length; t++) this.elements[t].classList.toggle("active", e === t)
        }
    }

    var _S, yS;
    !function (e) {
        e.REQUEST = "[data-xr-request]", e.CLOSE = "[data-xr-close]", e.CAROUSEL = "[data-xr-carousel]", e.AUDIO_PLAYER = "pk-audio-player", e.BRIDGE = ".xr__bridge", e.VIGNETTE = "#xr-vignette"
    }(_S || (_S = {})), function (e) {
        e.OPEN = "open", e.CLOSE = "close"
    }(yS || (yS = {}));
    const xS = "xr--tutorial";

    class bS extends Hc {
        constructor(e, t) {
            super(), this.element = e, this.universe = t, this.audioPlayers = [], this.tutorial = new hS, this.bridge = document.querySelector(_S.BRIDGE), this.vignette = document.querySelector(_S.VIGNETTE), this.currentSlide = bT[0], this.onFirstAudioPlayerStopped = () => {
                !this.tutorial.hasSeenTooltip && this.active && this.tutorial.showTooltip()
            }, this.onCarouselIndexChange = async () => {
                if (await this.stopAllAudioPlayers(), this.tutorial.hasSeenTooltip = !0, this.tutorial.hideTooltip(), !this.carousel) return;
                const {activeIndex: e} = this.carousel.swiper;
                await this.setXrProgressionIndex(e)
            }, this.onXrSurfaceFound = () => {
                var e;
                this.tutorial.hide(this.tutorial.dom.surface), (null === (e = this.universe.xrWorld) || void 0 === e ? void 0 : e.isSubjectPlaced) || this.tutorial.show(this.tutorial.dom.placement)
            }, this.onRequestButtonClick = async () => {
                var e;
                this.setToggleButtonDisabledState(!0), await (null === (e = this.universe) || void 0 === e ? void 0 : e.requestXr(this.element)), this.active ? this.onXrStarted() : (document.body.classList.add("xr-error"), this.setToggleButtonDisabledState(!1))
            }, this.onCloseButtonClick = () => {
                this.stopXr()
            }, this.onSubjectPlaced = async () => {
                this.tutorial.hide(this.tutorial.dom.placement), this.tutorial.isGestureTutorialStarted || await this.tutorial.startGestureTutorial(), this.element.classList.remove(xS), this.active && await this.audioPlayers[0].play()
            }, this.onTutorialDone = () => {
                this.universe.xrWorld && (this.universe.xrWorld.isThroughTutorial = !0)
            }, this.stopXr = async () => {
                var e, t, n, i, r;
                this.removeXrListeners(), await this.stopAllAudioPlayers();
                const {xrWorld: s} = this.universe;
                if (s) {
                    await this.universe.stopXr();
                    const t = null === (e = this.universe.mainWorld) || void 0 === e ? void 0 : e.scenes.find((e => e.isOnScreen));
                    null == t || t.render()
                }
                null === (t = this.carousel) || void 0 === t || t.swiper.slideTo(0), null === (n = this.carousel) || void 0 === n || n.swiper.disable(), document.body.classList.remove(By), this.element.classList.add(xS), this.setToggleButtonDisabledState(!1), this.tutorial.hideTooltip(), this.tutorial.hide(this.tutorial.dom.placement), (null === (i = this.bridge) || void 0 === i ? void 0 : i.open) && (this.bridge.open = !1), (null === (r = this.vignette) || void 0 === r ? void 0 : r.open) && (this.vignette.open = !1), this.dispatchEvent({type: yS.CLOSE})
            }, this.requestButtons = document.querySelectorAll(_S.REQUEST), this.closeButtons = document.querySelectorAll(_S.CLOSE);
            const n = document.querySelector(pS.CAPTIONS);
            n && (this.captions = new mS(n));
            const i = document.querySelectorAll(_S.AUDIO_PLAYER);
            for (let e = 0; e < i.length; e++) this.audioPlayers.push(new dS(i[e], this.captions));
            this.audioPlayers[0].pkAudio.addEventListener(Mr.STOPPED, this.onFirstAudioPlayerStopped, {once: !0});
            const r = document.querySelector(_S.CAROUSEL);
            r && (this.carousel = new j_(r, {slidesPerView: 1}));
            const s = document.querySelectorAll(`[${gS.ELEMENT}]`);
            this.headings = new vS(s), this.headings.chapter = 0, this.addEventListeners()
        }

        get active() {
            var e;
            return null === (e = this.universe.xrWorld) || void 0 === e ? void 0 : e.active
        }

        async stopAllAudioPlayers() {
            var e;
            null === (e = this.captions) || void 0 === e || e.clear();
            const t = [];
            for (let e = 0; e < this.audioPlayers.length; e++) t.push(this.audioPlayers[e].stop());
            await Promise.all(t)
        }

        dispose() {
            this.removeEventListeners()
        }

        async setXrProgressionIndex(e) {
            var t, n;
            const {xrWorld: i} = this.universe;
            if (!(null == i ? void 0 : i.active)) return;
            const r = bT[e];
            null === (t = this.carousel) || void 0 === t || t.swiper.disable(), await i.setSlide(r);
            const s = this.audioPlayers[e];
            await (null == s ? void 0 : s.play()), null === (n = this.carousel) || void 0 === n || n.swiper.enable(), this.headings.chapter = r.chapter;
            const a = r.chapter === yT.BURIAL_CHAMBER;
            if (r.scene !== this.currentSlide.scene && this.onSceneChange(r), this.vignette) {
                const e = r.chapter === yT.BURIAL_CHAMBER && r.subChapter > _T.STAIRS;
                this.vignette.open = a && e
            }
            if (this.bridge) {
                const e = r.chapter === yT.BURIAL_CHAMBER && r.subChapter === _T.BRIDGE;
                this.bridge.open = a && e
            }
            this.currentSlide = r;
            const o = `${e}: ${r.label}`;
            Br(Or.XR, {action: Dr.ADVANCE, label: o, nonInteraction: !1})
        }

        onSceneChange(e) {
            switch (e.scene) {
                case xT.BURIAL_CHAMBER:
                case xT.CHAPEL:
                    this.tutorial.startLookAroundPrompt()
            }
        }

        addXrListeners() {
            var e, t;
            const {xrWorld: n} = this.universe;
            n && (n.addEventListener(KT.SURFACE_FOUND_ONCE, this.onXrSurfaceFound), n.addEventListener(KT.SUBJECT_PLACED, this.onSubjectPlaced), null === (e = n.manager.session) || void 0 === e || e.addEventListener("end", this.stopXr), null === (t = this.carousel) || void 0 === t || t.swiper.on("activeIndexChange", this.onCarouselIndexChange))
        }

        removeXrListeners() {
            var e, t;
            const {xrWorld: n} = this.universe;
            n && (n.removeEventListener(KT.SURFACE_FOUND_ONCE, this.onXrSurfaceFound), n.removeEventListener(KT.SUBJECT_PLACED, this.onSubjectPlaced), null === (e = n.manager.session) || void 0 === e || e.removeEventListener("end", this.stopXr), null === (t = this.carousel) || void 0 === t || t.swiper.off("activeIndexChange", this.onCarouselIndexChange))
        }

        onXrStarted() {
            var e;
            document.body.classList.add(By), this.addXrListeners(), (null === (e = this.carousel) || void 0 === e ? void 0 : e.swiper) && (this.carousel.swiper.enable(), this.carousel.swiper.update(), V_(this.carousel.swiper)), this.dispatchEvent({type: yS.OPEN}), this.tutorial.isMainTutorialFinished ? this.tutorial.show(this.tutorial.dom.surface) : this.tutorial.startMainTutorial()
        }

        setToggleButtonDisabledState(e) {
            for (let t = 0; t < this.requestButtons.length; t++) this.requestButtons[t].disabled = e;
            for (let t = 0; t < this.closeButtons.length; t++) this.closeButtons[t].disabled = !e
        }

        addEventListeners() {
            for (let e = 0; e < this.requestButtons.length; e++) this.requestButtons[e].addEventListener("click", this.onRequestButtonClick);
            for (let e = 0; e < this.closeButtons.length; e++) this.closeButtons[e].addEventListener("click", this.onCloseButtonClick);
            this.tutorial.addEventListener(lS.BASICS_DONE, this.onTutorialDone)
        }

        removeEventListeners() {
            for (let e = 0; e < this.requestButtons.length; e++) this.requestButtons[e].removeEventListener("click", this.onRequestButtonClick);
            for (let e = 0; e < this.closeButtons.length; e++) this.closeButtons[e].removeEventListener("click", this.onCloseButtonClick);
            this.tutorial.removeEventListener(lS.BASICS_DONE, this.onTutorialDone)
        }
    }

    class wS {
        constructor() {
            this.watcherConfigs = []
        }

        add(e) {
            if (Array.isArray(e.on)) {
                e.on.forEach((t => {
                    const n = Object.assign({}, e);
                    n.on = t, this.addSingleEvent(n)
                }))
            } else this.addSingleEvent(e)
        }

        addSingleEvent(e) {
            const t = t => {
                e.runWhen ? e.runWhen() && e.callback(t) : e.callback(t)
            };
            if (e.listener = t, "smartResize" === e.on) e.remover = function (e, t) {
                let n = 0;
                const i = t => {
                    const i = window.innerWidth;
                    (!QT() || n !== i) && (e(t), n = i)
                };
                return window.addEventListener("resize", i, t), () => {
                    window.removeEventListener("resize", i)
                }
            }(t, e.eventOptions || {}); else if ("resize" === e.on && e.element !== window) {
                const n = new ResizeObserver((e => {
                    t(e)
                }));
                n.observe(e.element), e.remover = () => {
                    n.unobserve(e.element)
                }
            } else if ("mutation" === e.on) {
                const n = new MutationObserver((e => {
                    t(e)
                }));
                n.observe(e.element, e.eventOptions), e.remover = () => {
                    n.disconnect()
                }
            } else e.element.addEventListener(e.on, t, e.eventOptions || {}), e.remover = () => {
                e.element.removeEventListener(e.on, t, e.eventOptions || {})
            };
            this.watcherConfigs.push(e)
        }

        removeById(e) {
            this.watcherConfigs = this.watcherConfigs.filter((t => {
                if (t.id && t.id === e) {
                    const e = t.remover;
                    return e && e(), !1
                }
                return t
            }))
        }

        removeAll() {
            this.watcherConfigs.forEach((e => {
                const t = e.remover;
                t && t()
            })), this.watcherConfigs = []
        }

        run(e) {
            this.watcherConfigs.filter((t => t.id && t.id === e)).forEach((e => {
                e.callback() && e.callback()
            }))
        }

        dispose() {
            this.removeAll()
        }
    }

    function TS() {
        const e = e => {
            e.preventDefault()
        }, t = new wS;
        return t.add({element: window, on: "wheel", callback: e, eventOptions: {passive: !1}}), t.add({
            element: window,
            on: "touchmove",
            callback: e,
            eventOptions: {passive: !1}
        }), () => {
            t.dispose()
        }
    }

    let SS = TS();

    function ES(e = !0) {
        SS(), e && (SS = TS())
    }

    const MS = .25, {r: AS, g: LS, b: CS} = yb.GREY_900, RS = `rgb(${AS}, ${LS}, ${CS})`;

    function PS(e) {
        const t = document.querySelector(".overlay-fade"), n = e.querySelector("p"), i = bi.timeline();
        return i.to(t, {duration: MS}), i.to(t, {alpha: 1, duration: .75}, "main"), i.to(n, {
            color: RS,
            duration: .5
        }, "main"), i.to(t, {duration: MS}), i.pause(), i
    }

    function IS(e) {
        if (e.touches.length) return e.touches[0]
    }

    var OS;
    !function (e) {
        e.SWIPE = "swipe"
    }(OS || (OS = {}));

    class DS extends Hc {
        constructor() {
            super(), this.storedPointerY = 0, this._enabled = !0, this.forceDisabled = !1, this.isPointerDown = !1, this.onKeydown = e => {
                if (e.metaKey || this.forceDisabled) return;
                let t = ky.NONE;
                switch (e.code) {
                    case Uy.ARROW_DOWN:
                        t = ky.DOWN, e.preventDefault();
                        break;
                    case Uy.ARROW_UP:
                        t = ky.UP, e.preventDefault()
                }
                this.determineScrollTarget(t)
            }, this.onWheel = e => {
                !this.enabled || this.forceDisabled || Math.abs(e.deltaY) < 4 || this.determineScrollTarget(e.deltaY)
            }, this.onTouchStart = e => {
                if (!this._enabled || this.forceDisabled) return;
                const t = IS(e);
                t && (this.isPointerDown = !0, this.storedPointerY = t.clientY)
            }, this.onTouchMove = e => {
                if (!this.isPointerDown) return;
                const t = IS(e);
                if (!t) return;
                const n = t.clientY, i = this.storedPointerY - n;
                Math.abs(i) > 8 && this.determineScrollTarget(i)
            }, this.onTouchEnd = () => {
                this.isPointerDown = !1
            }, this.addEventListeners()
        }

        determineScrollTarget(e) {
            this._enabled && !this.forceDisabled && this.dispatchEvent({type: OS.SWIPE, velocity: e})
        }

        addEventListeners() {
            X_.addEventListener("wheel", this.onWheel, {passive: !0}), X_.addEventListener("touchstart", this.onTouchStart, {passive: !0}), X_.addEventListener("touchmove", this.onTouchMove, {passive: !0}), X_.addEventListener("touchend", this.onTouchEnd, {passive: !0}), window.addEventListener("keydown", this.onKeydown)
        }

        removeEventListeners() {
            X_.removeEventListener("wheel", this.onWheel), X_.removeEventListener("touchstart", this.onTouchStart), X_.removeEventListener("touchmove", this.onTouchMove), X_.removeEventListener("touchend", this.onTouchEnd), window.removeEventListener("keydown", this.onKeydown)
        }

        dispose() {
            this.removeEventListeners()
        }

        set enabled(e) {
            this._enabled = e
        }

        get enabled() {
            return this._enabled
        }
    }

    const NS = "scroll-indicator--visible";

    class BS {
        constructor(e) {
            this.element = e, this.isVisible = !0, this.setVisibility = () => {
                this.isVisible && (this.isVisible = !1, this.element.classList.remove(NS)), this.startTimer()
            }, this.onTimeOut = () => {
                this.element.classList.add(NS), this.isVisible = !0
            }, this.addEventListeners()
        }

        startTimer() {
            window.clearTimeout(this.timeout), this.timeout = window.setTimeout(this.onTimeOut, 1e4)
        }

        addEventListeners() {
            X_.addEventListener("scroll", this.setVisibility)
        }

        removeEventListeners() {
            X_.removeEventListener("scroll", this.setVisibility)
        }
    }

    const kS = bi.utils.toArray(document.querySelectorAll("[data-scroll-jack]"));

    function US(e) {
        return kS.find((t => t.dataset.scrollJack === e))
    }

    class FS {
        constructor(e, t) {
            this.element = e, this.slideProperties = t, this.onViewportToggle = e => {
                this.element.classList.toggle("on-screen", e.isActive)
            }, this.previousTarget = US(e.dataset.scrollJackPrevious), this.nextTarget = US(e.dataset.scrollJackNext), this.viewportScrollTrigger = qo.create({
                scroller: X_,
                trigger: e,
                onToggle: this.onViewportToggle
            })
        }
    }

    function HS(e) {
        document.body.classList.toggle("slide-theme--dark", e === pT.DARK)
    }

    function zS(e) {
        const {theme: t, duration: n} = e.slideProperties, i = Ly() ? 0 : n;
        var r;
        HS(t || pT.UNDEFINED), r = i, document.body.style.setProperty("--slide-delay", `${r}s`)
    }

    const GS = "active";

    class VS {
        constructor() {
            this.slides = new WeakMap, this.gestures = new DS, this.sectionTriggers = [], this.isTransitioning = !1, this.onSwipe = e => {
                this.goToSlideFromVelocity(e.velocity)
            }, this.onScrollIndicatorClick = () => {
                this.goToSlideFromVelocity(ky.DOWN)
            }, this.onSlideToggle = (e, t) => {
                var n;
                e.isActive && (null === (n = this.currentSlide) || void 0 === n || n.element.classList.remove(GS), t.element.classList.add(GS), this.currentSlide = t, this.gestures.enabled && (this.goTo(t, 0), Br(Or.SCROLLY_TELLING, {
                    action: Dr.ADVANCE,
                    label: t.slideProperties.label,
                    nonInteraction: !0
                })))
            }, this.gestures.enabled = !1;
            const e = bi.utils.toArray("[data-scroll-jack]");
            for (let t = 0; t < e.length; t++) {
                const n = new FS(e[t], mT[t]);
                mT[t].label === fT.KINGS_AND_QUEENS && (n.beforeAnimation = PS(e[t - 1])), this.sectionTriggers.push(qo.create({
                    trigger: n.element,
                    start: "top center",
                    end: "bottom center",
                    scroller: X_,
                    onToggle: e => this.onSlideToggle(e, n)
                })), this.slides.set(e[t], n)
            }
            this.gestures.enabled = !0;
            const t = document.querySelector(".scroll-prompt");
            t && (this.scrollIndicator = new BS(t), t.addEventListener("click", this.onScrollIndicatorClick)), this.gestures.addEventListener(OS.SWIPE, this.onSwipe), this.currentSlide && this.goTo(this.currentSlide, 0)
        }

        async goToSlideFromVelocity(e) {
            const t = Math.sign(e);
            if (!t || !this.currentSlide || !this.gestures.enabled) return;
            const n = function (e, t) {
                if (t) return t > 0 ? e.nextTarget : e.previousTarget
            }(this.currentSlide, t);
            if (!n) return;
            const i = this.slides.get(n);
            i && await this.interactionGoTo(i)
        }

        async interactionGoTo(e) {
            this.gestures.enabled = !1, await this.goTo(e), await iS(750), this.gestures.enabled = !0, Br(Or.SCROLLY_TELLING, {
                action: Dr.ADVANCE,
                label: e.slideProperties.label,
                nonInteraction: !1
            })
        }

        async goTo(e, t = 1) {
            var n, i;
            const r = Ly() ? 0 : t, s = 0 === r;
            this.isTransitioning = !0, e !== this.currentSlide && (null === (n = this.currentSlide) || void 0 === n || n.element.classList.remove(GS)), zS(e), null === (i = this.webglTimeline) || void 0 === i || i.animateToSlide(e, s), e.beforeAnimation && await e.beforeAnimation.play(), t && await async function (e, t = 1) {
                await bi.to(X_, {scrollTo: e.element, ease: e.slideProperties.ease, duration: t})
            }(e, r), e.beforeAnimation && await e.beforeAnimation.reverse(), s && await iS(500), this.isTransitioning = !1
        }
    }

    class WS {
        constructor(e) {
            this.timeline = function (e) {
                const t = bi.timeline({...vb, paused: !0});
                for (const n of e.scenes) n.isOnScreen = !1, n.timeline.paused(!1), t.add(n.timeline);
                return t
            }(e), this.totalDuration = this.timeline.totalDuration()
        }

        async animateToSlide(e, t = !1) {
            var n;
            const {duration: i, ease: r, position: s} = e.slideProperties, a = this.totalDuration * s;
            null === (n = this.tween) || void 0 === n || n.kill(), t ? this.timeline.progress(s) : (this.tween = this.timeline.tweenTo(a, {
                duration: i,
                ease: r
            }), await this.tween)
        }
    }

    class jS {
        constructor() {
            this.scrollJack = new VS, this.webglFadeOverlay = document.querySelector(".editorial-fade"), this._enabled = !0, this.onScrollJackEnter = e => {
                this.toggleScroll(e), this.scrollJack.gestures.forceDisabled = !1, this.scrollJack.gestures.enabled = !0, this.webglFadeOverlay && bi.to(this.webglFadeOverlay, {
                    delay: 1,
                    duration: 2,
                    alpha: 0
                })
            }, this.onScrollJackLeave = e => {
                this.scrollJack.gestures.forceDisabled = !0, this.toggleScroll(e), HS(pT.UNDEFINED), this.webglFadeOverlay && bi.set(this.webglFadeOverlay, {alpha: 1})
            };
            const e = document.getElementById("scrolljack");
            this.scrollTrigger = qo.create({
                scroller: X_,
                trigger: e,
                start: 0,
                end: "bottom top",
                onEnterBack: this.onScrollJackEnter,
                onLeave: this.onScrollJackLeave
            })
        }

        set enabled(e) {
            this._enabled = e, this.scrollJack.gestures.forceDisabled = !e, 1 === this.scrollTrigger.progress && this.onScrollJackLeave(this.scrollTrigger);
            for (const t of this.scrollJack.sectionTriggers) e ? t.enable(!1, !0) : t.disable(!1, !1)
        }

        initialiseWebglAnimation(e) {
            this.scrollJack.webglTimeline = new WS(e);
            const t = this.scrollJack.currentSlide;
            t && t.slideProperties.position > .001 && this.scrollJack.webglTimeline.animateToSlide(t, !0)
        }

        resize() {
            qo.refresh()
        }

        toggleScroll(e) {
            ES(e.progress >= 0 && e.progress < 1)
        }
    }

    var $S;
    !function (e) {
        e.LINK = ".navigation__link", e.LINE = ".navigation__line-inset"
    }($S || ($S = {}));

    class XS {
        constructor(e, t) {
            var n;
            this.element = e, this.order = t, this.lineElement = e.querySelector($S.LINE), this.linkElement = e.querySelector($S.LINK), this.hash = null === (n = this.linkElement) || void 0 === n ? void 0 : n.hash;
            let i = "top bottom";
            "#top" === this.hash ? (this.destinationElement = document.querySelector(".summary"), i = 0) : this.hash && (this.destinationElement = document.querySelector(this.hash)), this.destinationElement && qo.create({
                trigger: this.destinationElement,
                scroller: X_,
                start: i,
                end: "bottom top",
                scrub: !0,
                onToggle: t => {
                    e.classList.toggle("active", t.isActive)
                },
                onUpdate: e => {
                    this.lineElement && (this.lineElement.style.transform = `scaleY(${e.progress})`)
                }
            })
        }
    }

    class qS {
        constructor() {
            this.overlay = document.getElementById("transition"), this.timeline = bi.timeline({paused: !0});
            const e = document.getElementById("transition-graphic-group");
            e && e.children.length && (this.tabs = new dy(e.children));
            const t = this.overlay.querySelector(".transition-mask");
            this.timeline.set(t, {xPercent: 110}), this.timeline.to(t, {
                xPercent: 0,
                ease: "power3.inOut",
                duration: 1
            }), this.timeline.to(t, {xPercent: -110, ease: "power2.inOut", delay: 0, duration: .6})
        }

        get isVisible() {
            return this.overlay.open
        }

        show(e) {
            this.tabs && (this.tabs.activeIndex = e), this.overlay.open = !0, this.timeline.play(0)
        }

        hide() {
            this.overlay.open = !1
        }

        async transitionEnd() {
            const e = this.overlay;
            return new Promise((t => {
                const n = () => {
                    e.removeEventListener("transitionend", n), t()
                };
                e.addEventListener("transitionend", n)
            }))
        }
    }

    var YS;
    !function (e) {
        e.LIST_ITEM = ".navigation__list-item"
    }(YS || (YS = {}));

    class KS {
        constructor() {
            this.items = new WeakMap, this.transition = new qS, this.onLinkClick = async e => {
                const t = e.currentTarget;
                if (!(null == t ? void 0 : t.href)) return;
                const n = this.items.get(t), i = null == n ? void 0 : n.destinationElement;
                if (!i) return;
                e.preventDefault();
                const r = i.getBoundingClientRect().top, s = Math.abs(r) >= 200;
                s && (this.transition.show(n.order), await this.transition.transitionEnd()), bi.set(X_, {
                    scrollTo: {
                        y: n.destinationElement,
                        offsetY: -2
                    }
                }), s && (n.hash && (window.location.hash = n.hash, Br(Or.NAVIGATION, {
                    action: Dr.CLICK,
                    label: n.hash
                })), await iS(1e3), this.transition.hide())
            };
            const e = document.querySelectorAll(YS.LIST_ITEM);
            for (let t = 0; t < e.length; t++) {
                const n = e[t], i = new XS(n, t);
                i.linkElement && (this.items.set(i.linkElement, i), i.linkElement.addEventListener("click", this.onLinkClick))
            }
        }
    }

    bi.registerPlugin(qo, as), qo.config({autoRefreshEvents: "visibilitychange"});
    new class {
        constructor() {
            this.carousels = [], this.copyToClipboardButtons = [], this.overlayControls = [], this.shareButtons = [], this.viewportFadeAnimations = [], this.gtmElements = [], this.videoControllers = [], this.videoElements = [], this.featureDetection = new ay, this.onMainWorldInitialised = async () => {
                var e;
                const t = null === (e = this.webglManager) || void 0 === e ? void 0 : e.universe.mainWorld,
                    n = this.scrollManager;
                t && n && (n.initialiseWebglAnimation(t), this.loadingScreen.open = !1)
            }, this.onXrOpen = () => {
                ES(!1), this.scrollManager && (this.scrollManager.enabled = !1)
            }, this.onXrClose = () => {
                ES(), this.scrollManager && (this.scrollManager.enabled = !0)
            }, this.onResize = () => {
                const e = `${window.innerHeight}px`;
                document.body.style.setProperty(ry.VH, e)
            }, this.onResizeDebounced = () => {
                this.featureDetection.resize(), this.podcast.overlay.open && this.podcast.resize(), window.requestAnimationFrame((() => {
                    var e;
                    return null === (e = this.scrollManager) || void 0 === e ? void 0 : e.resize()
                }))
            }, this.onVisibilityChange = () => {
                for (const e of this.videoElements) e.documentVisibilityChange()
            }, ES();
            const e = document.querySelectorAll("[data-video-id]");
            for (let t = 0; t < e.length; t++) this.videoElements.push(new Cy(e[t]));
            this.loadingScreen = document.getElementById("webgl-loading-screen"), this.scrollManager = new jS, this.navigation = new KS;
            const t = document.querySelectorAll(`[${Sy.CONTROLLER}]`);
            for (let e = 0; e < t.length; e++) {
                const n = t[e];
                this.videoControllers.push(new My(n))
            }
            const n = document.querySelector("[data-overlay=podcast]");
            this.podcast = new wy(n);
            const i = document.getElementById("language-selector");
            i && (this.localeSelector = new ly(i));
            const r = document.querySelector(".section-webgl");
            if (r) {
                const e = r.querySelector("canvas");
                if (e) {
                    this.webglManager = new aS(e), this.webglManager.engine.events.addEventListener(Hy.RESIZE, this.onResizeDebounced), this.webglManager.engine.events.addEventListener(Hy.VISIBILITY_CHANGE, this.onVisibilityChange), this.webglManager.setup().then((() => {
                        this.webglManager.universe.startMain().initialise().then(this.onMainWorldInitialised)
                    }));
                    const t = document.getElementById("xr-dom");
                    t && (this.xr = new bS(t, this.webglManager.universe), this.xr.addEventListener(yS.OPEN, this.onXrOpen), this.xr.addEventListener(yS.CLOSE, this.onXrClose))
                }
            }
            const s = document.querySelectorAll(`[${G_.CONTROLLER}]`);
            for (let e = 0; e < s.length; e++) {
                const t = s[e];
                this.copyToClipboardButtons.push(new $_(t))
            }
            const a = document.querySelectorAll("[data-gtm-element]");
            for (let e = 0; e < a.length; e++) {
                const t = a[e];
                this.gtmElements.push(new oy(t))
            }
            const o = document.querySelectorAll(`[${Ty.BUTTON}]`);
            for (let e = 0; e < o.length; e++) {
                const t = o[e];
                this.shareButtons.push(new Ey(t))
            }
            const l = document.querySelectorAll(`[${cy.OVERLAY}]`);
            for (let e = 0; e < l.length; e++) {
                const t = l[e];
                this.overlayControls.push(new hy(t))
            }
            const c = document.querySelectorAll("[data-viewport-fade]");
            for (let e = 0; e < c.length; e++) {
                const t = c[e];
                this.viewportFadeAnimations.push(Ry(t))
            }
            const h = document.querySelectorAll(`[${z_.CAROUSEL}]`);
            for (let e = 0; e < h.length; e++) {
                const t = h[e];
                this.carousels.push(new j_(t))
            }
            this.overlayElements = document.querySelectorAll("pk-overlay");
            for (let e = 0; e < this.overlayElements.length; e++) {
                const t = this.overlayElements[e];
                t.addEventListener(kr.OPEN, (() => {
                    ES(!1)
                })), t.addEventListener(kr.CLOSE, (() => {
                    this.scrollManager && this.scrollManager.scrollTrigger.progress < 1 && ES()
                }))
            }
            window.addEventListener("resize", this.onResize), this.onResize(), this.onResizeDebounced()
        }
    }
}();